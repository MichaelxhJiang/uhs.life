[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Retry = Package.retry.Retry;\nvar IdMap = Package['id-map'].IdMap;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar Hook = Package['callback-hook'].Hook;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\nvar Symbol = Package['ecmascript-runtime-server'].Symbol;\nvar Map = Package['ecmascript-runtime-server'].Map;\nvar Set = Package['ecmascript-runtime-server'].Set;\n\n/* Package-scope variables */\nvar toSockjsUrl, toWebsocketUrl, allConnections, DDP;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"ddp-client\":{\"stream_client_nodejs.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/stream_client_nodejs.js                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");                                                //\n                                                                                                                       //\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);                                                       //\n                                                                                                                       //\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }                      //\n                                                                                                                       //\nvar module1 = module;                                                                                                  // 1\nvar DDP = void 0,                                                                                                      // 1\n    LivedataTest = void 0;                                                                                             // 1\nmodule1.watch(require(\"./namespace.js\"), {                                                                             // 1\n  DDP: function (v) {                                                                                                  // 1\n    DDP = v;                                                                                                           // 1\n  },                                                                                                                   // 1\n  LivedataTest: function (v) {                                                                                         // 1\n    LivedataTest = v;                                                                                                  // 1\n  }                                                                                                                    // 1\n}, 0);                                                                                                                 // 1\n                                                                                                                       //\n// @param endpoint {String} URL to Meteor app                                                                          // 3\n//   \"http://subdomain.meteor.com/\" or \"/\" or                                                                          // 4\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                           // 5\n//                                                                                                                     // 6\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",                                          // 7\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns                                       // 8\n// us should work.                                                                                                     // 9\n//                                                                                                                     // 10\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,                                       // 11\n// because it used a built-in sockjs mechanism. We could do it with WebSocket                                          // 12\n// ping frames or with DDP-level messages.)                                                                            // 13\nLivedataTest.ClientStream = function () {                                                                              // 14\n  function ClientStream(endpoint, options) {                                                                           // 15\n    (0, _classCallCheck3.default)(this, ClientStream);                                                                 // 15\n    var self = this;                                                                                                   // 16\n    options = options || {};                                                                                           // 17\n    self.options = Object.assign({                                                                                     // 19\n      retry: true                                                                                                      // 20\n    }, options);                                                                                                       // 19\n    self.client = null; // created in _launchConnection                                                                // 23\n                                                                                                                       //\n    self.endpoint = endpoint;                                                                                          // 24\n    self.headers = self.options.headers || {};                                                                         // 26\n    self.npmFayeOptions = self.options.npmFayeOptions || {};                                                           // 27\n                                                                                                                       //\n    self._initCommon(self.options); //// Kickoff!                                                                      // 29\n                                                                                                                       //\n                                                                                                                       //\n    self._launchConnection();                                                                                          // 32\n  } // data is a utf8 string. Data sent while not connected is dropped on                                              // 33\n  // the floor, and it is up the user of this API to retransmit lost                                                   // 36\n  // messages on 'reset'                                                                                               // 37\n                                                                                                                       //\n                                                                                                                       //\n  ClientStream.prototype.send = function () {                                                                          // 14\n    function send(data) {                                                                                              // 14\n      var self = this;                                                                                                 // 39\n                                                                                                                       //\n      if (self.currentStatus.connected) {                                                                              // 40\n        self.client.send(data);                                                                                        // 41\n      }                                                                                                                // 42\n    }                                                                                                                  // 43\n                                                                                                                       //\n    return send;                                                                                                       // 14\n  }(); // Changes where this connection points                                                                         // 14\n                                                                                                                       //\n                                                                                                                       //\n  ClientStream.prototype._changeUrl = function () {                                                                    // 14\n    function _changeUrl(url) {                                                                                         // 14\n      var self = this;                                                                                                 // 47\n      self.endpoint = url;                                                                                             // 48\n    }                                                                                                                  // 49\n                                                                                                                       //\n    return _changeUrl;                                                                                                 // 14\n  }();                                                                                                                 // 14\n                                                                                                                       //\n  ClientStream.prototype._onConnect = function () {                                                                    // 14\n    function _onConnect(client) {                                                                                      // 14\n      var self = this;                                                                                                 // 52\n                                                                                                                       //\n      if (client !== self.client) {                                                                                    // 54\n        // This connection is not from the last call to _launchConnection.                                             // 55\n        // But _launchConnection calls _cleanup which closes previous connections.                                     // 56\n        // It's our belief that this stifles future 'open' events, but maybe                                           // 57\n        // we are wrong?                                                                                               // 58\n        throw new Error(\"Got open from inactive client \" + !!self.client);                                             // 59\n      }                                                                                                                // 60\n                                                                                                                       //\n      if (self._forcedToDisconnect) {                                                                                  // 62\n        // We were asked to disconnect between trying to open the connection and                                       // 63\n        // actually opening it. Let's just pretend this never happened.                                                // 64\n        self.client.close();                                                                                           // 65\n        self.client = null;                                                                                            // 66\n        return;                                                                                                        // 67\n      }                                                                                                                // 68\n                                                                                                                       //\n      if (self.currentStatus.connected) {                                                                              // 70\n        // We already have a connection. It must have been the case that we                                            // 71\n        // started two parallel connection attempts (because we wanted to                                              // 72\n        // 'reconnect now' on a hanging connection and we had no way to cancel the                                     // 73\n        // connection attempt.) But this shouldn't happen (similarly to the client                                     // 74\n        // !== self.client check above).                                                                               // 75\n        throw new Error(\"Two parallel connections?\");                                                                  // 76\n      }                                                                                                                // 77\n                                                                                                                       //\n      self._clearConnectionTimer(); // update status                                                                   // 79\n                                                                                                                       //\n                                                                                                                       //\n      self.currentStatus.status = \"connected\";                                                                         // 82\n      self.currentStatus.connected = true;                                                                             // 83\n      self.currentStatus.retryCount = 0;                                                                               // 84\n      self.statusChanged(); // fire resets. This must come after status change so that clients                         // 85\n      // can call send from within a reset callback.                                                                   // 88\n                                                                                                                       //\n      _.each(self.eventCallbacks.reset, function (callback) {                                                          // 89\n        callback();                                                                                                    // 89\n      });                                                                                                              // 89\n    }                                                                                                                  // 90\n                                                                                                                       //\n    return _onConnect;                                                                                                 // 14\n  }();                                                                                                                 // 14\n                                                                                                                       //\n  ClientStream.prototype._cleanup = function () {                                                                      // 14\n    function _cleanup(maybeError) {                                                                                    // 14\n      var self = this;                                                                                                 // 93\n                                                                                                                       //\n      self._clearConnectionTimer();                                                                                    // 95\n                                                                                                                       //\n      if (self.client) {                                                                                               // 96\n        var client = self.client;                                                                                      // 97\n        self.client = null;                                                                                            // 98\n        client.close();                                                                                                // 99\n                                                                                                                       //\n        _.each(self.eventCallbacks.disconnect, function (callback) {                                                   // 101\n          callback(maybeError);                                                                                        // 102\n        });                                                                                                            // 103\n      }                                                                                                                // 104\n    }                                                                                                                  // 105\n                                                                                                                       //\n    return _cleanup;                                                                                                   // 14\n  }();                                                                                                                 // 14\n                                                                                                                       //\n  ClientStream.prototype._clearConnectionTimer = function () {                                                         // 14\n    function _clearConnectionTimer() {                                                                                 // 14\n      var self = this;                                                                                                 // 108\n                                                                                                                       //\n      if (self.connectionTimer) {                                                                                      // 110\n        clearTimeout(self.connectionTimer);                                                                            // 111\n        self.connectionTimer = null;                                                                                   // 112\n      }                                                                                                                // 113\n    }                                                                                                                  // 114\n                                                                                                                       //\n    return _clearConnectionTimer;                                                                                      // 14\n  }();                                                                                                                 // 14\n                                                                                                                       //\n  ClientStream.prototype._getProxyUrl = function () {                                                                  // 14\n    function _getProxyUrl(targetUrl) {                                                                                 // 14\n      var self = this; // Similar to code in tools/http-helpers.js.                                                    // 117\n                                                                                                                       //\n      var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null; // if we're going to a secure url, try the https_proxy env variable first.\n                                                                                                                       //\n      if (targetUrl.match(/^wss:/)) {                                                                                  // 121\n        proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;                                           // 122\n      }                                                                                                                // 123\n                                                                                                                       //\n      return proxy;                                                                                                    // 124\n    }                                                                                                                  // 125\n                                                                                                                       //\n    return _getProxyUrl;                                                                                               // 14\n  }();                                                                                                                 // 14\n                                                                                                                       //\n  ClientStream.prototype._launchConnection = function () {                                                             // 14\n    function _launchConnection() {                                                                                     // 14\n      var self = this;                                                                                                 // 128\n                                                                                                                       //\n      self._cleanup(); // cleanup the old socket, if there was one.                                                    // 129\n      // Since server-to-server DDP is still an experimental feature, we only                                          // 131\n      // require the module if we actually create a server-to-server                                                   // 132\n      // connection.                                                                                                   // 133\n                                                                                                                       //\n                                                                                                                       //\n      var FayeWebSocket = Npm.require('faye-websocket');                                                               // 134\n                                                                                                                       //\n      var deflate = Npm.require('permessage-deflate');                                                                 // 135\n                                                                                                                       //\n      var targetUrl = toWebsocketUrl(self.endpoint);                                                                   // 137\n      var fayeOptions = {                                                                                              // 138\n        headers: self.headers,                                                                                         // 139\n        extensions: [deflate]                                                                                          // 140\n      };                                                                                                               // 138\n      fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);                                                        // 142\n                                                                                                                       //\n      var proxyUrl = self._getProxyUrl(targetUrl);                                                                     // 143\n                                                                                                                       //\n      if (proxyUrl) {                                                                                                  // 144\n        fayeOptions.proxy = {                                                                                          // 145\n          origin: proxyUrl                                                                                             // 145\n        };                                                                                                             // 145\n      }                                                                                                                // 146\n                                                                                                                       //\n      ; // We would like to specify 'ddp' as the subprotocol here. The npm module we                                   // 146\n      // used to use as a client would fail the handshake if we ask for a                                              // 149\n      // subprotocol and the server doesn't send one back (and sockjs doesn't).                                        // 150\n      // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if                                        // 151\n      // Faye is erroneous or not.  So for now, we don't specify protocols.                                            // 152\n                                                                                                                       //\n      var subprotocols = [];                                                                                           // 153\n      var client = self.client = new FayeWebSocket.Client(targetUrl, subprotocols, fayeOptions);                       // 155\n                                                                                                                       //\n      self._clearConnectionTimer();                                                                                    // 158\n                                                                                                                       //\n      self.connectionTimer = Meteor.setTimeout(function () {                                                           // 159\n        self._lostConnection(new DDP.ConnectionError(\"DDP connection timed out\"));                                     // 161\n      }, self.CONNECT_TIMEOUT);                                                                                        // 163\n      self.client.on('open', Meteor.bindEnvironment(function () {                                                      // 166\n        return self._onConnect(client);                                                                                // 167\n      }, \"stream connect callback\"));                                                                                  // 168\n                                                                                                                       //\n      var clientOnIfCurrent = function (event, description, f) {                                                       // 170\n        self.client.on(event, Meteor.bindEnvironment(function () {                                                     // 171\n          // Ignore events from any connection we've already cleaned up.                                               // 172\n          if (client !== self.client) return;                                                                          // 173\n          f.apply(this, arguments);                                                                                    // 175\n        }, description));                                                                                              // 176\n      };                                                                                                               // 177\n                                                                                                                       //\n      clientOnIfCurrent('error', 'stream error callback', function (error) {                                           // 179\n        if (!self.options._dontPrintErrors) Meteor._debug(\"stream error\", error.message); // Faye's 'error' object is not a JS error (and among other things,\n        // doesn't stringify well). Convert it to one.                                                                 // 184\n                                                                                                                       //\n        self._lostConnection(new DDP.ConnectionError(error.message));                                                  // 185\n      });                                                                                                              // 186\n      clientOnIfCurrent('close', 'stream close callback', function () {                                                // 189\n        self._lostConnection();                                                                                        // 190\n      });                                                                                                              // 191\n      clientOnIfCurrent('message', 'stream message callback', function (message) {                                     // 194\n        // Ignore binary frames, where message.data is a Buffer                                                        // 195\n        if (typeof message.data !== \"string\") return;                                                                  // 196\n                                                                                                                       //\n        _.each(self.eventCallbacks.message, function (callback) {                                                      // 199\n          callback(message.data);                                                                                      // 200\n        });                                                                                                            // 201\n      });                                                                                                              // 202\n    }                                                                                                                  // 203\n                                                                                                                       //\n    return _launchConnection;                                                                                          // 14\n  }();                                                                                                                 // 14\n                                                                                                                       //\n  return ClientStream;                                                                                                 // 14\n}();                                                                                                                   // 14\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"stream_client_common.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/stream_client_common.js                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar DDP = void 0,                                                                                                      // 1\n    LivedataTest = void 0;                                                                                             // 1\nmodule.watch(require(\"./namespace.js\"), {                                                                              // 1\n  DDP: function (v) {                                                                                                  // 1\n    DDP = v;                                                                                                           // 1\n  },                                                                                                                   // 1\n  LivedataTest: function (v) {                                                                                         // 1\n    LivedataTest = v;                                                                                                  // 1\n  }                                                                                                                    // 1\n}, 0);                                                                                                                 // 1\n                                                                                                                       //\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                             // 3\nvar startsWith = function (str, starts) {                                                                              // 4\n  return str.length >= starts.length && str.substring(0, starts.length) === starts;                                    // 5\n};                                                                                                                     // 7\n                                                                                                                       //\nvar endsWith = function (str, ends) {                                                                                  // 8\n  return str.length >= ends.length && str.substring(str.length - ends.length) === ends;                                // 9\n}; // @param url {String} URL to Meteor app, eg:                                                                       // 11\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                          // 14\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                 // 15\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                                    // 16\n// for scheme \"http\" and subPath \"sockjs\"                                                                              // 17\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                                 // 18\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                      // 19\n                                                                                                                       //\n                                                                                                                       //\nvar translateUrl = function (url, newSchemeBase, subPath) {                                                            // 20\n  if (!newSchemeBase) {                                                                                                // 21\n    newSchemeBase = \"http\";                                                                                            // 22\n  }                                                                                                                    // 23\n                                                                                                                       //\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                                // 25\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                      // 26\n  var newScheme;                                                                                                       // 27\n                                                                                                                       //\n  if (ddpUrlMatch) {                                                                                                   // 28\n    // Remove scheme and split off the host.                                                                           // 29\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                               // 30\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";                                          // 31\n    var slashPos = urlAfterDDP.indexOf('/');                                                                           // 32\n    var host = slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                        // 33\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos); // In the host (ONLY!), change '*' characters into random digits. This\n    // allows different stream connections to connect to different hostnames                                           // 38\n    // and avoid browser per-hostname connection limits.                                                               // 39\n                                                                                                                       //\n    host = host.replace(/\\*/g, function () {                                                                           // 40\n      return Math.floor(Random.fraction() * 10);                                                                       // 41\n    });                                                                                                                // 42\n    return newScheme + '://' + host + rest;                                                                            // 44\n  } else if (httpUrlMatch) {                                                                                           // 45\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";                                                // 46\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                             // 47\n    url = newScheme + \"://\" + urlAfterHttp;                                                                            // 48\n  } // Prefix FQDNs but not relative URLs                                                                              // 49\n                                                                                                                       //\n                                                                                                                       //\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {                                                            // 52\n    url = newSchemeBase + \"://\" + url;                                                                                 // 53\n  } // XXX This is not what we should be doing: if I have a site                                                       // 54\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect                                                 // 57\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if                                                     // 58\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")                                                 // 59\n  // to connect to \"/foo/bar\").                                                                                        // 60\n  //                                                                                                                   // 61\n  // We should make this properly honor absolute paths rather than                                                     // 62\n  // forcing the path to be relative to the site root. Simultaneously,                                                 // 63\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site                                                      // 64\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs                                                // 65\n                                                                                                                       //\n                                                                                                                       //\n  url = Meteor._relativeToSiteRootUrl(url);                                                                            // 66\n  if (endsWith(url, \"/\")) return url + subPath;else return url + \"/\" + subPath;                                        // 68\n};                                                                                                                     // 72\n                                                                                                                       //\ntoSockjsUrl = function (url) {                                                                                         // 74\n  return translateUrl(url, \"http\", \"sockjs\");                                                                          // 75\n};                                                                                                                     // 76\n                                                                                                                       //\ntoWebsocketUrl = function (url) {                                                                                      // 78\n  var ret = translateUrl(url, \"ws\", \"websocket\");                                                                      // 79\n  return ret;                                                                                                          // 80\n};                                                                                                                     // 81\n                                                                                                                       //\nLivedataTest.toSockjsUrl = toSockjsUrl;                                                                                // 83\n                                                                                                                       //\n_.extend(LivedataTest.ClientStream.prototype, {                                                                        // 86\n  // Register for callbacks.                                                                                           // 88\n  on: function (name, callback) {                                                                                      // 89\n    var self = this;                                                                                                   // 90\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect') throw new Error(\"unknown event type: \" + name);\n    if (!self.eventCallbacks[name]) self.eventCallbacks[name] = [];                                                    // 95\n    self.eventCallbacks[name].push(callback);                                                                          // 97\n  },                                                                                                                   // 98\n  _initCommon: function (options) {                                                                                    // 101\n    var self = this;                                                                                                   // 102\n    options = options || {}; //// Constants                                                                            // 103\n    // how long to wait until we declare the connection attempt                                                        // 107\n    // failed.                                                                                                         // 108\n                                                                                                                       //\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;                                                          // 109\n    self.eventCallbacks = {}; // name -> [callback]                                                                    // 111\n                                                                                                                       //\n    self._forcedToDisconnect = false; //// Reactive status                                                             // 113\n                                                                                                                       //\n    self.currentStatus = {                                                                                             // 116\n      status: \"connecting\",                                                                                            // 117\n      connected: false,                                                                                                // 118\n      retryCount: 0                                                                                                    // 119\n    };                                                                                                                 // 116\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency();                                 // 123\n                                                                                                                       //\n    self.statusChanged = function () {                                                                                 // 124\n      if (self.statusListeners) self.statusListeners.changed();                                                        // 125\n    }; //// Retry logic                                                                                                // 127\n                                                                                                                       //\n                                                                                                                       //\n    self._retry = new Retry();                                                                                         // 130\n    self.connectionTimer = null;                                                                                       // 131\n  },                                                                                                                   // 133\n  // Trigger a reconnect.                                                                                              // 135\n  reconnect: function (options) {                                                                                      // 136\n    var self = this;                                                                                                   // 137\n    options = options || {};                                                                                           // 138\n                                                                                                                       //\n    if (options.url) {                                                                                                 // 140\n      self._changeUrl(options.url);                                                                                    // 141\n    }                                                                                                                  // 142\n                                                                                                                       //\n    if (options._sockjsOptions) {                                                                                      // 144\n      self.options._sockjsOptions = options._sockjsOptions;                                                            // 145\n    }                                                                                                                  // 146\n                                                                                                                       //\n    if (self.currentStatus.connected) {                                                                                // 148\n      if (options._force || options.url) {                                                                             // 149\n        // force reconnect.                                                                                            // 150\n        self._lostConnection(new DDP.ForcedReconnectError());                                                          // 151\n      } // else, noop.                                                                                                 // 152\n                                                                                                                       //\n                                                                                                                       //\n      return;                                                                                                          // 153\n    } // if we're mid-connection, stop it.                                                                             // 154\n                                                                                                                       //\n                                                                                                                       //\n    if (self.currentStatus.status === \"connecting\") {                                                                  // 157\n      // Pretend it's a clean close.                                                                                   // 158\n      self._lostConnection();                                                                                          // 159\n    }                                                                                                                  // 160\n                                                                                                                       //\n    self._retry.clear();                                                                                               // 162\n                                                                                                                       //\n    self.currentStatus.retryCount -= 1; // don't count manual retries                                                  // 163\n                                                                                                                       //\n    self._retryNow();                                                                                                  // 164\n  },                                                                                                                   // 165\n  disconnect: function (options) {                                                                                     // 167\n    var self = this;                                                                                                   // 168\n    options = options || {}; // Failed is permanent. If we're failed, don't let people go back                         // 169\n    // online by calling 'disconnect' then 'reconnect'.                                                                // 172\n                                                                                                                       //\n    if (self._forcedToDisconnect) return; // If _permanent is set, permanently disconnect a stream. Once a stream      // 173\n    // is forced to disconnect, it can never reconnect. This is for                                                    // 177\n    // error cases such as ddp version mismatch, where trying again                                                    // 178\n    // won't fix the problem.                                                                                          // 179\n                                                                                                                       //\n    if (options._permanent) {                                                                                          // 180\n      self._forcedToDisconnect = true;                                                                                 // 181\n    }                                                                                                                  // 182\n                                                                                                                       //\n    self._cleanup();                                                                                                   // 184\n                                                                                                                       //\n    self._retry.clear();                                                                                               // 185\n                                                                                                                       //\n    self.currentStatus = {                                                                                             // 187\n      status: options._permanent ? \"failed\" : \"offline\",                                                               // 188\n      connected: false,                                                                                                // 189\n      retryCount: 0                                                                                                    // 190\n    };                                                                                                                 // 187\n    if (options._permanent && options._error) self.currentStatus.reason = options._error;                              // 193\n    self.statusChanged();                                                                                              // 196\n  },                                                                                                                   // 197\n  // maybeError is set unless it's a clean protocol-level close.                                                       // 199\n  _lostConnection: function (maybeError) {                                                                             // 200\n    var self = this;                                                                                                   // 201\n                                                                                                                       //\n    self._cleanup(maybeError);                                                                                         // 203\n                                                                                                                       //\n    self._retryLater(maybeError); // sets status. no need to do it here.                                               // 204\n                                                                                                                       //\n  },                                                                                                                   // 205\n  // fired when we detect that we've gone online. try to reconnect                                                     // 207\n  // immediately.                                                                                                      // 208\n  _online: function () {                                                                                               // 209\n    // if we've requested to be offline by disconnecting, don't reconnect.                                             // 210\n    if (this.currentStatus.status != \"offline\") this.reconnect();                                                      // 211\n  },                                                                                                                   // 213\n  _retryLater: function (maybeError) {                                                                                 // 215\n    var self = this;                                                                                                   // 216\n    var timeout = 0;                                                                                                   // 218\n                                                                                                                       //\n    if (self.options.retry || maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\") {                     // 219\n      timeout = self._retry.retryLater(self.currentStatus.retryCount, _.bind(self._retryNow, self));                   // 221\n      self.currentStatus.status = \"waiting\";                                                                           // 225\n      self.currentStatus.retryTime = new Date().getTime() + timeout;                                                   // 226\n    } else {                                                                                                           // 227\n      self.currentStatus.status = \"failed\";                                                                            // 228\n      delete self.currentStatus.retryTime;                                                                             // 229\n    }                                                                                                                  // 230\n                                                                                                                       //\n    self.currentStatus.connected = false;                                                                              // 232\n    self.statusChanged();                                                                                              // 233\n  },                                                                                                                   // 234\n  _retryNow: function () {                                                                                             // 236\n    var self = this;                                                                                                   // 237\n    if (self._forcedToDisconnect) return;                                                                              // 239\n    self.currentStatus.retryCount += 1;                                                                                // 242\n    self.currentStatus.status = \"connecting\";                                                                          // 243\n    self.currentStatus.connected = false;                                                                              // 244\n    delete self.currentStatus.retryTime;                                                                               // 245\n    self.statusChanged();                                                                                              // 246\n                                                                                                                       //\n    self._launchConnection();                                                                                          // 248\n  },                                                                                                                   // 249\n  // Get current status. Reactive.                                                                                     // 252\n  status: function () {                                                                                                // 253\n    var self = this;                                                                                                   // 254\n    if (self.statusListeners) self.statusListeners.depend();                                                           // 255\n    return self.currentStatus;                                                                                         // 257\n  }                                                                                                                    // 258\n});                                                                                                                    // 86\n                                                                                                                       //\nDDP.ConnectionError = Meteor.makeErrorType(\"DDP.ConnectionError\", function (message) {                                 // 261\n  var self = this;                                                                                                     // 263\n  self.message = message;                                                                                              // 264\n});                                                                                                                    // 265\nDDP.ForcedReconnectError = Meteor.makeErrorType(\"DDP.ForcedReconnectError\", function () {});                           // 267\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"livedata_common.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/livedata_common.js                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar DDP = void 0,                                                                                                      // 1\n    LivedataTest = void 0;                                                                                             // 1\nmodule.watch(require(\"./namespace.js\"), {                                                                              // 1\n  DDP: function (v) {                                                                                                  // 1\n    DDP = v;                                                                                                           // 1\n  },                                                                                                                   // 1\n  LivedataTest: function (v) {                                                                                         // 1\n    LivedataTest = v;                                                                                                  // 1\n  }                                                                                                                    // 1\n}, 0);                                                                                                                 // 1\nLivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS; // This is private but it's used in a few places. accounts-base uses\n// it to get the current user. Meteor.setTimeout and friends clear                                                     // 6\n// it. We can probably find a better way to factor this.                                                               // 7\n                                                                                                                       //\nDDP._CurrentMethodInvocation = new Meteor.EnvironmentVariable();                                                       // 8\nDDP._CurrentPublicationInvocation = new Meteor.EnvironmentVariable(); // XXX: Keep DDP._CurrentInvocation for backwards-compatibility.\n                                                                                                                       //\nDDP._CurrentInvocation = DDP._CurrentMethodInvocation;                                                                 // 12\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"random_stream.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/random_stream.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar DDP = void 0;                                                                                                      // 1\nmodule.watch(require(\"./namespace.js\"), {                                                                              // 1\n  DDP: function (v) {                                                                                                  // 1\n    DDP = v;                                                                                                           // 1\n  }                                                                                                                    // 1\n}, 0);                                                                                                                 // 1\n                                                                                                                       //\n// Returns the named sequence of pseudo-random values.                                                                 // 3\n// The scope will be DDP._CurrentMethodInvocation.get(), so the stream will produce                                    // 4\n// consistent values for method calls on the client and server.                                                        // 5\nDDP.randomStream = function (name) {                                                                                   // 6\n  var scope = DDP._CurrentMethodInvocation.get();                                                                      // 7\n                                                                                                                       //\n  return DDPCommon.RandomStream.get(scope, name);                                                                      // 8\n};                                                                                                                     // 9\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"livedata_connection.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/livedata_connection.js                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");                                                                //\n                                                                                                                       //\nvar _typeof3 = _interopRequireDefault(_typeof2);                                                                       //\n                                                                                                                       //\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }                      //\n                                                                                                                       //\nvar DDP = void 0,                                                                                                      // 1\n    LivedataTest = void 0;                                                                                             // 1\nmodule.watch(require(\"./namespace.js\"), {                                                                              // 1\n  DDP: function (v) {                                                                                                  // 1\n    DDP = v;                                                                                                           // 1\n  },                                                                                                                   // 1\n  LivedataTest: function (v) {                                                                                         // 1\n    LivedataTest = v;                                                                                                  // 1\n  }                                                                                                                    // 1\n}, 0);                                                                                                                 // 1\nvar MongoIDMap = void 0;                                                                                               // 1\nmodule.watch(require(\"./id_map.js\"), {                                                                                 // 1\n  MongoIDMap: function (v) {                                                                                           // 1\n    MongoIDMap = v;                                                                                                    // 1\n  }                                                                                                                    // 1\n}, 1);                                                                                                                 // 1\n                                                                                                                       //\nif (Meteor.isServer) {                                                                                                 // 4\n  var Fiber = Npm.require('fibers');                                                                                   // 5\n                                                                                                                       //\n  var Future = Npm.require('fibers/future');                                                                           // 6\n} // @param url {String|Object} URL to Meteor app,                                                                     // 7\n//   or an object as a test hook (see code)                                                                            // 10\n// Options:                                                                                                            // 11\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                       // 12\n//   headers: extra headers to send on the websockets connection, for                                                  // 13\n//     server-to-server DDP only                                                                                       // 14\n//   _sockjsOptions: Specifies options to pass through to the sockjs client                                            // 15\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                          // 16\n//                                                                                                                     // 17\n// XXX There should be a way to destroy a DDP connection, causing all                                                  // 18\n// outstanding method calls to fail.                                                                                   // 19\n//                                                                                                                     // 20\n// XXX Our current way of handling failure and reconnection is great                                                   // 21\n// for an app (where we want to tolerate being disconnected as an                                                      // 22\n// expect state, and keep trying forever to reconnect) but cumbersome                                                  // 23\n// for something like a command line tool that wants to make a                                                         // 24\n// connection, call a method, and print an error if connection                                                         // 25\n// fails. We should have better usability in the latter case (while                                                    // 26\n// still transparently reconnecting if it's just a transient failure                                                   // 27\n// or the server migrating us).                                                                                        // 28\n                                                                                                                       //\n                                                                                                                       //\nvar Connection = function (url, options) {                                                                             // 29\n  var self = this;                                                                                                     // 30\n  options = _.extend({                                                                                                 // 31\n    onConnected: function () {},                                                                                       // 32\n    onDDPVersionNegotiationFailure: function (description) {                                                           // 33\n      Meteor._debug(description);                                                                                      // 34\n    },                                                                                                                 // 35\n    heartbeatInterval: 17500,                                                                                          // 36\n    heartbeatTimeout: 15000,                                                                                           // 37\n    npmFayeOptions: {},                                                                                                // 38\n    // These options are only for testing.                                                                             // 39\n    reloadWithOutstanding: false,                                                                                      // 40\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,                                                            // 41\n    retry: true,                                                                                                       // 42\n    respondToPings: true,                                                                                              // 43\n    // When updates are coming within this ms interval, batch them together.                                           // 44\n    bufferedWritesInterval: 5,                                                                                         // 45\n    // Flush buffers immediately if writes are happening continuously for more than this many ms.                      // 46\n    bufferedWritesMaxAge: 500                                                                                          // 47\n  }, options); // If set, called when we reconnect, queuing method calls _before_ the                                  // 31\n  // existing outstanding ones.                                                                                        // 51\n  // NOTE: This feature has been preserved for backwards compatibility. The                                            // 52\n  // preferred method of setting a callback on reconnect is to use                                                     // 53\n  // DDP.onReconnect.                                                                                                  // 54\n                                                                                                                       //\n  self.onReconnect = null; // as a test hook, allow passing a stream instead of a url.                                 // 55\n                                                                                                                       //\n  if ((typeof url === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(url)) === \"object\") {                          // 58\n    self._stream = url;                                                                                                // 59\n  } else {                                                                                                             // 60\n    self._stream = new LivedataTest.ClientStream(url, {                                                                // 61\n      retry: options.retry,                                                                                            // 62\n      headers: options.headers,                                                                                        // 63\n      _sockjsOptions: options._sockjsOptions,                                                                          // 64\n      // Used to keep some tests quiet, or for other cases in which                                                    // 65\n      // the right thing to do with connection errors is to silently                                                   // 66\n      // fail (e.g. sending package usage stats). At some point we                                                     // 67\n      // should have a real API for handling client-stream-level                                                       // 68\n      // errors.                                                                                                       // 69\n      _dontPrintErrors: options._dontPrintErrors,                                                                      // 70\n      connectTimeoutMs: options.connectTimeoutMs,                                                                      // 71\n      npmFayeOptions: options.npmFayeOptions                                                                           // 72\n    });                                                                                                                // 61\n  }                                                                                                                    // 74\n                                                                                                                       //\n  self._lastSessionId = null;                                                                                          // 76\n  self._versionSuggestion = null; // The last proposed DDP version.                                                    // 77\n                                                                                                                       //\n  self._version = null; // The DDP version agreed on by client and server.                                             // 78\n                                                                                                                       //\n  self._stores = {}; // name -> object with methods                                                                    // 79\n                                                                                                                       //\n  self._methodHandlers = {}; // name -> func                                                                           // 80\n                                                                                                                       //\n  self._nextMethodId = 1;                                                                                              // 81\n  self._supportedDDPVersions = options.supportedDDPVersions;                                                           // 82\n  self._heartbeatInterval = options.heartbeatInterval;                                                                 // 84\n  self._heartbeatTimeout = options.heartbeatTimeout; // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all                                       // 88\n  // of their writes to be written to the local cache). Map from method ID to                                          // 89\n  // MethodInvoker object.                                                                                             // 90\n                                                                                                                       //\n  self._methodInvokers = {}; // Tracks methods which the user has called but whose result messages have not            // 91\n  // arrived yet.                                                                                                      // 94\n  //                                                                                                                   // 95\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                             // 96\n  // represents a set of methods that can run at the same time. The first block                                        // 97\n  // represents the methods which are currently in flight; subsequent blocks                                           // 98\n  // must wait for previous blocks to be fully finished before they can be sent                                        // 99\n  // to the server.                                                                                                    // 100\n  //                                                                                                                   // 101\n  // Each block is an object with the following fields:                                                                // 102\n  // - methods: a list of MethodInvoker objects                                                                        // 103\n  // - wait: a boolean; if true, this block had a single method invoked with                                           // 104\n  //         the \"wait\" option                                                                                         // 105\n  //                                                                                                                   // 106\n  // There will never be adjacent blocks with wait=false, because the only thing                                       // 107\n  // that makes methods need to be serialized is a wait method.                                                        // 108\n  //                                                                                                                   // 109\n  // Methods are removed from the first block when their \"result\" is                                                   // 110\n  // received. The entire first block is only removed when all of the in-flight                                        // 111\n  // methods have received their results (so the \"methods\" list is empty) *AND*                                        // 112\n  // all of the data written by those methods are visible in the local cache. So                                       // 113\n  // it is possible for the first block's methods list to be empty, if we are                                          // 114\n  // still waiting for some objects to quiesce.                                                                        // 115\n  //                                                                                                                   // 116\n  // Example:                                                                                                          // 117\n  //  _outstandingMethodBlocks = [                                                                                     // 118\n  //    {wait: false, methods: []},                                                                                    // 119\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                          // 120\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                             // 121\n  //                            <MethodInvoker for 'bar'>]}]                                                           // 122\n  // This means that there were some methods which were sent to the server and                                         // 123\n  // which have returned their results, but some of the data written by                                                // 124\n  // the methods may not be visible in the local cache. Once all that data is                                          // 125\n  // visible, we will send a 'login' method. Once the login method has returned                                        // 126\n  // and all the data is visible (including re-running subs if userId changes),                                        // 127\n  // we will send the 'foo' and 'bar' methods in parallel.                                                             // 128\n                                                                                                                       //\n  self._outstandingMethodBlocks = []; // method ID -> array of objects with keys 'collection' and 'id', listing        // 129\n  // documents written by a given method's stub. keys are associated with                                              // 132\n  // methods whose stub wrote at least one document, and whose data-done message                                       // 133\n  // has not yet been received.                                                                                        // 134\n                                                                                                                       //\n  self._documentsWrittenByStub = {}; // collection -> IdMap of \"server document\" object. A \"server document\" has:      // 135\n  // - \"document\": the version of the document according the                                                           // 137\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                         // 138\n  //   received from the server)                                                                                       // 139\n  //   It is undefined if we think the document does not exist                                                         // 140\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document                                         // 141\n  //   whose \"data done\" messages have not yet been processed                                                          // 142\n                                                                                                                       //\n  self._serverDocuments = {}; // Array of callbacks to be called after the next update of the local                    // 143\n  // cache. Used for:                                                                                                  // 146\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                                // 147\n  //    the relevant data is flushed.                                                                                  // 148\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect                                              // 149\n  //    quiescence. Specifically, methods whose result was received over the old                                       // 150\n  //    connection (so we don't re-send it) but whose data had not been made                                           // 151\n  //    visible.                                                                                                       // 152\n                                                                                                                       //\n  self._afterUpdateCallbacks = []; // In two contexts, we buffer all incoming data messages and then process them      // 153\n  // all at once in a single update:                                                                                   // 156\n  //   - During reconnect, we buffer all data messages until all subs that had                                         // 157\n  //     been ready before reconnect are ready again, and all methods that are                                         // 158\n  //     active have returned their \"data done message\"; then                                                          // 159\n  //   - During the execution of a \"wait\" method, we buffer all data messages                                          // 160\n  //     until the wait method gets its \"data done\" message. (If the wait method                                       // 161\n  //     occurs during reconnect, it doesn't get any special handling.)                                                // 162\n  // all data messages are processed in one update.                                                                    // 163\n  //                                                                                                                   // 164\n  // The following fields are used for this \"quiescence\" process.                                                      // 165\n  // This buffers the messages that aren't being processed yet.                                                        // 167\n                                                                                                                       //\n  self._messagesBufferedUntilQuiescence = []; // Map from method ID -> true. Methods are removed from this when their  // 168\n  // \"data done\" message is received, and we will not quiesce until it is                                              // 170\n  // empty.                                                                                                            // 171\n                                                                                                                       //\n  self._methodsBlockingQuiescence = {}; // map from sub ID -> true for subs that were ready (ie, called the sub        // 172\n  // ready callback) before reconnect but haven't become ready again yet                                               // 174\n                                                                                                                       //\n  self._subsBeingRevived = {}; // map from sub._id -> true                                                             // 175\n  // if true, the next data update should reset all stores. (set during                                                // 176\n  // reconnect.)                                                                                                       // 177\n                                                                                                                       //\n  self._resetStores = false; // name -> array of updates for (yet to be created) collections                           // 178\n                                                                                                                       //\n  self._updatesForUnknownStores = {}; // if we're blocking a migration, the retry func                                 // 181\n                                                                                                                       //\n  self._retryMigrate = null;                                                                                           // 183\n  self.__flushBufferedWrites = Meteor.bindEnvironment(self._flushBufferedWrites, \"flushing DDP buffered writes\", self); // Collection name -> array of messages.\n                                                                                                                       //\n  self._bufferedWrites = {}; // When current buffer of updates must be flushed at, in ms timestamp.                    // 188\n                                                                                                                       //\n  self._bufferedWritesFlushAt = null; // Timeout handle for the next processing of all pending writes                  // 190\n                                                                                                                       //\n  self._bufferedWritesFlushHandle = null;                                                                              // 192\n  self._bufferedWritesInterval = options.bufferedWritesInterval;                                                       // 194\n  self._bufferedWritesMaxAge = options.bufferedWritesMaxAge; // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id                                                                                                            // 198\n  //   - name                                                                                                          // 199\n  //   - params                                                                                                        // 200\n  //   - inactive (if true, will be cleaned up if not reused in re-run)                                                // 201\n  //   - ready (has the 'ready' message been received?)                                                                // 202\n  //   - readyCallback (an optional callback to call when ready)                                                       // 203\n  //   - errorCallback (an optional callback to call if the sub terminates with                                        // 204\n  //                    an error, XXX COMPAT WITH 1.0.3.1)                                                             // 205\n  //   - stopCallback (an optional callback to call when the sub terminates                                            // 206\n  //     for any reason, with an error argument if an error triggered the stop)                                        // 207\n                                                                                                                       //\n  self._subscriptions = {}; // Reactive userId.                                                                        // 208\n                                                                                                                       //\n  self._userId = null;                                                                                                 // 211\n  self._userIdDeps = new Tracker.Dependency(); // Block auto-reload while we're waiting for method responses.          // 212\n                                                                                                                       //\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                           // 215\n    Package.reload.Reload._onMigrate(function (retry) {                                                                // 216\n      if (!self._readyToMigrate()) {                                                                                   // 217\n        if (self._retryMigrate) throw new Error(\"Two migrations in progress?\");                                        // 218\n        self._retryMigrate = retry;                                                                                    // 220\n        return false;                                                                                                  // 221\n      } else {                                                                                                         // 222\n        return [true];                                                                                                 // 223\n      }                                                                                                                // 224\n    });                                                                                                                // 225\n  }                                                                                                                    // 226\n                                                                                                                       //\n  var onMessage = function (raw_msg) {                                                                                 // 228\n    try {                                                                                                              // 229\n      var msg = DDPCommon.parseDDP(raw_msg);                                                                           // 230\n    } catch (e) {                                                                                                      // 231\n      Meteor._debug(\"Exception while parsing DDP\", e);                                                                 // 232\n                                                                                                                       //\n      return;                                                                                                          // 233\n    } // Any message counts as receiving a pong, as it demonstrates that                                               // 234\n    // the server is still alive.                                                                                      // 237\n                                                                                                                       //\n                                                                                                                       //\n    if (self._heartbeat) {                                                                                             // 238\n      self._heartbeat.messageReceived();                                                                               // 239\n    }                                                                                                                  // 240\n                                                                                                                       //\n    if (msg === null || !msg.msg) {                                                                                    // 242\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back                                                // 243\n      // compat.  Remove this 'if' once the server stops sending welcome                                               // 244\n      // messages (stream_server.js).                                                                                  // 245\n      if (!(msg && msg.server_id)) Meteor._debug(\"discarding invalid livedata message\", msg);                          // 246\n      return;                                                                                                          // 248\n    }                                                                                                                  // 249\n                                                                                                                       //\n    if (msg.msg === 'connected') {                                                                                     // 251\n      self._version = self._versionSuggestion;                                                                         // 252\n                                                                                                                       //\n      self._livedata_connected(msg);                                                                                   // 253\n                                                                                                                       //\n      options.onConnected();                                                                                           // 254\n    } else if (msg.msg === 'failed') {                                                                                 // 255\n      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                       // 257\n        self._versionSuggestion = msg.version;                                                                         // 258\n                                                                                                                       //\n        self._stream.reconnect({                                                                                       // 259\n          _force: true                                                                                                 // 259\n        });                                                                                                            // 259\n      } else {                                                                                                         // 260\n        var description = \"DDP version negotiation failed; server requested version \" + msg.version;                   // 261\n                                                                                                                       //\n        self._stream.disconnect({                                                                                      // 263\n          _permanent: true,                                                                                            // 263\n          _error: description                                                                                          // 263\n        });                                                                                                            // 263\n                                                                                                                       //\n        options.onDDPVersionNegotiationFailure(description);                                                           // 264\n      }                                                                                                                // 265\n    } else if (msg.msg === 'ping' && options.respondToPings) {                                                         // 266\n      self._send({                                                                                                     // 268\n        msg: \"pong\",                                                                                                   // 268\n        id: msg.id                                                                                                     // 268\n      });                                                                                                              // 268\n    } else if (msg.msg === 'pong') {// noop, as we assume everything's a pong                                          // 269\n    } else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg)) self._livedata_data(msg);else if (msg.msg === 'nosub') self._livedata_nosub(msg);else if (msg.msg === 'result') self._livedata_result(msg);else if (msg.msg === 'error') self._livedata_error(msg);else Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };                                                                                                                   // 283\n                                                                                                                       //\n  var onReset = function () {                                                                                          // 285\n    // Send a connect message at the beginning of the stream.                                                          // 286\n    // NOTE: reset is called even on the first connection, so this is                                                  // 287\n    // the only place we send this message.                                                                            // 288\n    var msg = {                                                                                                        // 289\n      msg: 'connect'                                                                                                   // 289\n    };                                                                                                                 // 289\n    if (self._lastSessionId) msg.session = self._lastSessionId;                                                        // 290\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                            // 292\n    self._versionSuggestion = msg.version;                                                                             // 293\n    msg.support = self._supportedDDPVersions;                                                                          // 294\n                                                                                                                       //\n    self._send(msg); // Mark non-retry calls as failed. This has to be done early as getting these methods out of the  // 295\n    // current block is pretty important to making sure that quiescence is properly calculated, as                     // 298\n    // well as possibly moving on to another useful block.                                                             // 299\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if                    // 301\n    // we are connecting for the first time.                                                                           // 302\n                                                                                                                       //\n                                                                                                                       //\n    if (self._outstandingMethodBlocks.length > 0) {                                                                    // 303\n      // If there is an outstanding method block, we only care about the first one as that is the                      // 304\n      // one that could have already sent messages with no response, that are not allowed to retry.                    // 305\n      var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                               // 306\n      self._outstandingMethodBlocks[0].methods = currentMethodBlock.filter(function (methodInvoker) {                  // 307\n        // Methods with 'noRetry' option set are not allowed to re-send after                                          // 309\n        // recovering dropped connection.                                                                              // 310\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {                                                      // 311\n          // Make sure that the method is told that it failed.                                                         // 312\n          methodInvoker.receiveResult(new Meteor.Error('invocation-failed', 'Method invocation might have failed due to dropped connection. ' + 'Failing because `noRetry` option was passed to Meteor.apply.'));\n        } // Only keep a method if it wasn't sent or it's allowed to retry.                                            // 316\n        // This may leave the block empty, but we don't move on to the next                                            // 319\n        // block until the callback has been delivered, in _outstandingMethodFinished.                                 // 320\n                                                                                                                       //\n                                                                                                                       //\n        return !(methodInvoker.sentMessage && methodInvoker.noRetry);                                                  // 321\n      });                                                                                                              // 322\n    } // Now, to minimize setup latency, go ahead and blast out all of                                                 // 323\n    // our pending methods ands subscriptions before we've even taken                                                  // 326\n    // the necessary RTT to know if we successfully reconnected. (1)                                                   // 327\n    // They're supposed to be idempotent, and where they are not,                                                      // 328\n    // they can block retry in apply; (2) even if we did reconnect,                                                    // 329\n    // we're not sure what messages might have gotten lost                                                             // 330\n    // (in either direction) since we were disconnected (TCP being                                                     // 331\n    // sloppy about that.)                                                                                             // 332\n    // If the current block of methods all got their results (but didn't all get                                       // 334\n    // their data visible), discard the empty block now.                                                               // 335\n                                                                                                                       //\n                                                                                                                       //\n    if (!_.isEmpty(self._outstandingMethodBlocks) && _.isEmpty(self._outstandingMethodBlocks[0].methods)) {            // 336\n      self._outstandingMethodBlocks.shift();                                                                           // 338\n    } // Mark all messages as unsent, they have not yet been sent on this                                              // 339\n    // connection.                                                                                                     // 342\n                                                                                                                       //\n                                                                                                                       //\n    _.each(self._methodInvokers, function (m) {                                                                        // 343\n      m.sentMessage = false;                                                                                           // 344\n    }); // If an `onReconnect` handler is set, call it first. Go through                                               // 345\n    // some hoops to ensure that methods that are called from within                                                   // 348\n    // `onReconnect` get executed _before_ ones that were originally                                                   // 349\n    // outstanding (since `onReconnect` is used to re-establish auth                                                   // 350\n    // certificates)                                                                                                   // 351\n                                                                                                                       //\n                                                                                                                       //\n    self._callOnReconnectAndSendAppropriateOutstandingMethods(); // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.                                                                          // 355\n                                                                                                                       //\n                                                                                                                       //\n    _.each(self._subscriptions, function (sub, id) {                                                                   // 356\n      self._send({                                                                                                     // 357\n        msg: 'sub',                                                                                                    // 358\n        id: id,                                                                                                        // 359\n        name: sub.name,                                                                                                // 360\n        params: sub.params                                                                                             // 361\n      });                                                                                                              // 357\n    });                                                                                                                // 363\n  };                                                                                                                   // 364\n                                                                                                                       //\n  var onDisconnect = function () {                                                                                     // 366\n    if (self._heartbeat) {                                                                                             // 367\n      self._heartbeat.stop();                                                                                          // 368\n                                                                                                                       //\n      self._heartbeat = null;                                                                                          // 369\n    }                                                                                                                  // 370\n  };                                                                                                                   // 371\n                                                                                                                       //\n  if (Meteor.isServer) {                                                                                               // 373\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));                             // 374\n                                                                                                                       //\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));                                   // 375\n                                                                                                                       //\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));                    // 376\n  } else {                                                                                                             // 377\n    self._stream.on('message', onMessage);                                                                             // 378\n                                                                                                                       //\n    self._stream.on('reset', onReset);                                                                                 // 379\n                                                                                                                       //\n    self._stream.on('disconnect', onDisconnect);                                                                       // 380\n  }                                                                                                                    // 381\n}; // A MethodInvoker manages sending a method to the server and calling the user's                                    // 382\n// callbacks. On construction, it registers itself in the connection's                                                 // 385\n// _methodInvokers map; it removes itself once the method is fully finished and                                        // 386\n// the callback is invoked. This occurs when it has both received a result,                                            // 387\n// and the data written by it is fully visible.                                                                        // 388\n                                                                                                                       //\n                                                                                                                       //\nvar MethodInvoker = function (options) {                                                                               // 389\n  var self = this; // Public (within this file) fields.                                                                // 390\n                                                                                                                       //\n  self.methodId = options.methodId;                                                                                    // 393\n  self.sentMessage = false;                                                                                            // 394\n  self._callback = options.callback;                                                                                   // 396\n  self._connection = options.connection;                                                                               // 397\n  self._message = options.message;                                                                                     // 398\n                                                                                                                       //\n  self._onResultReceived = options.onResultReceived || function () {};                                                 // 399\n                                                                                                                       //\n  self._wait = options.wait;                                                                                           // 400\n  self.noRetry = options.noRetry;                                                                                      // 401\n  self._methodResult = null;                                                                                           // 402\n  self._dataVisible = false; // Register with the connection.                                                          // 403\n                                                                                                                       //\n  self._connection._methodInvokers[self.methodId] = self;                                                              // 406\n};                                                                                                                     // 407\n                                                                                                                       //\n_.extend(MethodInvoker.prototype, {                                                                                    // 408\n  // Sends the method message to the server. May be called additional times if                                         // 409\n  // we lose the connection and reconnect before receiving a result.                                                   // 410\n  sendMessage: function () {                                                                                           // 411\n    var self = this; // This function is called before sending a method (including resending on                        // 412\n    // reconnect). We should only (re)send methods where we don't already have a                                       // 414\n    // result!                                                                                                         // 415\n                                                                                                                       //\n    if (self.gotResult()) throw new Error(\"sendingMethod is called on method with result\"); // If we're re-sending it, it doesn't matter if data was written the first\n    // time.                                                                                                           // 421\n                                                                                                                       //\n    self._dataVisible = false;                                                                                         // 422\n    self.sentMessage = true; // If this is a wait method, make all data messages be buffered until it is               // 423\n    // done.                                                                                                           // 426\n                                                                                                                       //\n    if (self._wait) self._connection._methodsBlockingQuiescence[self.methodId] = true; // Actually send the message.   // 427\n                                                                                                                       //\n    self._connection._send(self._message);                                                                             // 431\n  },                                                                                                                   // 432\n  // Invoke the callback, if we have both a result and know that all data has                                          // 433\n  // been written to the local cache.                                                                                  // 434\n  _maybeInvokeCallback: function () {                                                                                  // 435\n    var self = this;                                                                                                   // 436\n                                                                                                                       //\n    if (self._methodResult && self._dataVisible) {                                                                     // 437\n      // Call the callback. (This won't throw: the callback was wrapped with                                           // 438\n      // bindEnvironment.)                                                                                             // 439\n      self._callback(self._methodResult[0], self._methodResult[1]); // Forget about this method.                       // 440\n                                                                                                                       //\n                                                                                                                       //\n      delete self._connection._methodInvokers[self.methodId]; // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.                                                                         // 446\n                                                                                                                       //\n      self._connection._outstandingMethodFinished();                                                                   // 447\n    }                                                                                                                  // 448\n  },                                                                                                                   // 449\n  // Call with the result of the method from the server. Only may be called                                            // 450\n  // once; once it is called, you should not call sendMessage again.                                                   // 451\n  // If the user provided an onResultReceived callback, call it immediately.                                           // 452\n  // Then invoke the main callback if data is also visible.                                                            // 453\n  receiveResult: function (err, result) {                                                                              // 454\n    var self = this;                                                                                                   // 455\n    if (self.gotResult()) throw new Error(\"Methods should only receive results once\");                                 // 456\n    self._methodResult = [err, result];                                                                                // 458\n                                                                                                                       //\n    self._onResultReceived(err, result);                                                                               // 459\n                                                                                                                       //\n    self._maybeInvokeCallback();                                                                                       // 460\n  },                                                                                                                   // 461\n  // Call this when all data written by the method is visible. This means that                                         // 462\n  // the method has returns its \"data is done\" message *AND* all server                                                // 463\n  // documents that are buffered at that time have been written to the local                                           // 464\n  // cache. Invokes the main callback if the result has been received.                                                 // 465\n  dataVisible: function () {                                                                                           // 466\n    var self = this;                                                                                                   // 467\n    self._dataVisible = true;                                                                                          // 468\n                                                                                                                       //\n    self._maybeInvokeCallback();                                                                                       // 469\n  },                                                                                                                   // 470\n  // True if receiveResult has been called.                                                                            // 471\n  gotResult: function () {                                                                                             // 472\n    var self = this;                                                                                                   // 473\n    return !!self._methodResult;                                                                                       // 474\n  }                                                                                                                    // 475\n});                                                                                                                    // 408\n                                                                                                                       //\n_.extend(Connection.prototype, {                                                                                       // 478\n  // 'name' is the name of the data on the wire that should go in the                                                  // 479\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                       // 480\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                       // 481\n  registerStore: function (name, wrappedStore) {                                                                       // 482\n    var self = this;                                                                                                   // 483\n    if (name in self._stores) return false; // Wrap the input object in an object which makes any store method not     // 485\n    // implemented by 'store' into a no-op.                                                                            // 489\n                                                                                                                       //\n    var store = {};                                                                                                    // 490\n                                                                                                                       //\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals', 'retrieveOriginals', 'getDoc', '_getCollection'], function (method) {\n      store[method] = function () {                                                                                    // 494\n        return wrappedStore[method] ? wrappedStore[method].apply(wrappedStore, arguments) : undefined;                 // 495\n      };                                                                                                               // 498\n    });                                                                                                                // 499\n                                                                                                                       //\n    self._stores[name] = store;                                                                                        // 501\n    var queued = self._updatesForUnknownStores[name];                                                                  // 503\n                                                                                                                       //\n    if (queued) {                                                                                                      // 504\n      store.beginUpdate(queued.length, false);                                                                         // 505\n                                                                                                                       //\n      _.each(queued, function (msg) {                                                                                  // 506\n        store.update(msg);                                                                                             // 507\n      });                                                                                                              // 508\n                                                                                                                       //\n      store.endUpdate();                                                                                               // 509\n      delete self._updatesForUnknownStores[name];                                                                      // 510\n    }                                                                                                                  // 511\n                                                                                                                       //\n    return true;                                                                                                       // 513\n  },                                                                                                                   // 514\n  /**                                                                                                                  // 516\n   * @memberOf Meteor                                                                                                  //\n   * @importFromPackage meteor                                                                                         //\n   * @summary Subscribe to a record set.  Returns a handle that provides                                               //\n   * `stop()` and `ready()` methods.                                                                                   //\n   * @locus Client                                                                                                     //\n   * @param {String} name Name of the subscription.  Matches the name of the                                           //\n   * server's `publish()` call.                                                                                        //\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher                                          //\n   * function on server.                                                                                               //\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`                                               //\n   * and `onReady` callbacks. If there is an error, it is passed as an                                                 //\n   * argument to `onStop`. If a function is passed instead of an object, it                                            //\n   * is interpreted as an `onReady` callback.                                                                          //\n   */subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                         //\n    var self = this;                                                                                                   // 532\n    var params = Array.prototype.slice.call(arguments, 1);                                                             // 534\n    var callbacks = {};                                                                                                // 535\n                                                                                                                       //\n    if (params.length) {                                                                                               // 536\n      var lastParam = params[params.length - 1];                                                                       // 537\n                                                                                                                       //\n      if (_.isFunction(lastParam)) {                                                                                   // 538\n        callbacks.onReady = params.pop();                                                                              // 539\n      } else if (lastParam && // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                         // 540\n      // onStop with an error callback instead.                                                                        // 542\n      _.any([lastParam.onReady, lastParam.onError, lastParam.onStop], _.isFunction)) {                                 // 543\n        callbacks = params.pop();                                                                                      // 545\n      }                                                                                                                // 546\n    } // Is there an existing sub with the same name and param, run in an                                              // 547\n    // invalidated Computation? This will happen if we are rerunning an                                                // 550\n    // existing computation.                                                                                           // 551\n    //                                                                                                                 // 552\n    // For example, consider a rerun of:                                                                               // 553\n    //                                                                                                                 // 554\n    //     Tracker.autorun(function () {                                                                               // 555\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));                                                              // 556\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));                                                              // 557\n    //     });                                                                                                         // 558\n    //                                                                                                                 // 559\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"                                                 // 560\n    // subcribe to an existing inactive subscription in order to not                                                   // 561\n    // unsub and resub the subscription unnecessarily.                                                                 // 562\n    //                                                                                                                 // 563\n    // We only look for one such sub; if there are N apparently-identical subs                                         // 564\n    // being invalidated, we will require N matching subscribe calls to keep                                           // 565\n    // them all active.                                                                                                // 566\n                                                                                                                       //\n                                                                                                                       //\n    var existing = _.find(self._subscriptions, function (sub) {                                                        // 567\n      return sub.inactive && sub.name === name && EJSON.equals(sub.params, params);                                    // 568\n    });                                                                                                                // 570\n                                                                                                                       //\n    var id;                                                                                                            // 572\n                                                                                                                       //\n    if (existing) {                                                                                                    // 573\n      id = existing.id;                                                                                                // 574\n      existing.inactive = false; // reactivate                                                                         // 575\n                                                                                                                       //\n      if (callbacks.onReady) {                                                                                         // 577\n        // If the sub is not already ready, replace any ready callback with the                                        // 578\n        // one provided now. (It's not really clear what users would expect for                                        // 579\n        // an onReady callback inside an autorun; the semantics we provide is                                          // 580\n        // that at the time the sub first becomes ready, we call the last                                              // 581\n        // onReady callback provided, if any.)                                                                         // 582\n        // If the sub is already ready, run the ready callback right away.                                             // 583\n        // It seems that users would expect an onReady callback inside an                                              // 584\n        // autorun to trigger once the the sub first becomes ready and also                                            // 585\n        // when re-subs happens.                                                                                       // 586\n        if (existing.ready) {                                                                                          // 587\n          callbacks.onReady();                                                                                         // 588\n        } else {                                                                                                       // 589\n          existing.readyCallback = callbacks.onReady;                                                                  // 590\n        }                                                                                                              // 591\n      } // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call                                             // 592\n      // onStop with an optional error argument                                                                        // 595\n                                                                                                                       //\n                                                                                                                       //\n      if (callbacks.onError) {                                                                                         // 596\n        // Replace existing callback if any, so that errors aren't                                                     // 597\n        // double-reported.                                                                                            // 598\n        existing.errorCallback = callbacks.onError;                                                                    // 599\n      }                                                                                                                // 600\n                                                                                                                       //\n      if (callbacks.onStop) {                                                                                          // 602\n        existing.stopCallback = callbacks.onStop;                                                                      // 603\n      }                                                                                                                // 604\n    } else {                                                                                                           // 605\n      // New sub! Generate an id, save it locally, and send message.                                                   // 606\n      id = Random.id();                                                                                                // 607\n      self._subscriptions[id] = {                                                                                      // 608\n        id: id,                                                                                                        // 609\n        name: name,                                                                                                    // 610\n        params: EJSON.clone(params),                                                                                   // 611\n        inactive: false,                                                                                               // 612\n        ready: false,                                                                                                  // 613\n        readyDeps: new Tracker.Dependency(),                                                                           // 614\n        readyCallback: callbacks.onReady,                                                                              // 615\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                      // 616\n        errorCallback: callbacks.onError,                                                                              // 617\n        stopCallback: callbacks.onStop,                                                                                // 618\n        connection: self,                                                                                              // 619\n        remove: function () {                                                                                          // 620\n          delete this.connection._subscriptions[this.id];                                                              // 621\n          this.ready && this.readyDeps.changed();                                                                      // 622\n        },                                                                                                             // 623\n        stop: function () {                                                                                            // 624\n          this.connection._send({                                                                                      // 625\n            msg: 'unsub',                                                                                              // 625\n            id: id                                                                                                     // 625\n          });                                                                                                          // 625\n                                                                                                                       //\n          this.remove();                                                                                               // 626\n                                                                                                                       //\n          if (callbacks.onStop) {                                                                                      // 628\n            callbacks.onStop();                                                                                        // 629\n          }                                                                                                            // 630\n        }                                                                                                              // 631\n      };                                                                                                               // 608\n                                                                                                                       //\n      self._send({                                                                                                     // 633\n        msg: 'sub',                                                                                                    // 633\n        id: id,                                                                                                        // 633\n        name: name,                                                                                                    // 633\n        params: params                                                                                                 // 633\n      });                                                                                                              // 633\n    } // return a handle to the application.                                                                           // 634\n                                                                                                                       //\n                                                                                                                       //\n    var handle = {                                                                                                     // 637\n      stop: function () {                                                                                              // 638\n        if (!_.has(self._subscriptions, id)) return;                                                                   // 639\n                                                                                                                       //\n        self._subscriptions[id].stop();                                                                                // 642\n      },                                                                                                               // 643\n      ready: function () {                                                                                             // 644\n        // return false if we've unsubscribed.                                                                         // 645\n        if (!_.has(self._subscriptions, id)) return false;                                                             // 646\n        var record = self._subscriptions[id];                                                                          // 648\n        record.readyDeps.depend();                                                                                     // 649\n        return record.ready;                                                                                           // 650\n      },                                                                                                               // 651\n      subscriptionId: id                                                                                               // 652\n    };                                                                                                                 // 637\n                                                                                                                       //\n    if (Tracker.active) {                                                                                              // 655\n      // We're in a reactive computation, so we'd like to unsubscribe when the                                         // 656\n      // computation is invalidated... but not if the rerun just re-subscribes                                         // 657\n      // to the same subscription!  When a rerun happens, we use onInvalidate                                          // 658\n      // as a change to mark the subscription \"inactive\" so that it can                                                // 659\n      // be reused from the rerun.  If it isn't reused, it's killed from                                               // 660\n      // an afterFlush.                                                                                                // 661\n      Tracker.onInvalidate(function (c) {                                                                              // 662\n        if (_.has(self._subscriptions, id)) self._subscriptions[id].inactive = true;                                   // 663\n        Tracker.afterFlush(function () {                                                                               // 666\n          if (_.has(self._subscriptions, id) && self._subscriptions[id].inactive) handle.stop();                       // 667\n        });                                                                                                            // 670\n      });                                                                                                              // 671\n    }                                                                                                                  // 672\n                                                                                                                       //\n    return handle;                                                                                                     // 674\n  },                                                                                                                   // 675\n  // options:                                                                                                          // 677\n  // - onLateError {Function(error)} called if an error was received after the ready event.                            // 678\n  //     (errors received before ready cause an error to be thrown)                                                    // 679\n  _subscribeAndWait: function (name, args, options) {                                                                  // 680\n    var self = this;                                                                                                   // 681\n    var f = new Future();                                                                                              // 682\n    var ready = false;                                                                                                 // 683\n    var handle;                                                                                                        // 684\n    args = args || [];                                                                                                 // 685\n    args.push({                                                                                                        // 686\n      onReady: function () {                                                                                           // 687\n        ready = true;                                                                                                  // 688\n        f['return']();                                                                                                 // 689\n      },                                                                                                               // 690\n      onError: function (e) {                                                                                          // 691\n        if (!ready) f['throw'](e);else options && options.onLateError && options.onLateError(e);                       // 692\n      }                                                                                                                // 696\n    });                                                                                                                // 686\n    handle = self.subscribe.apply(self, [name].concat(args));                                                          // 699\n    f.wait();                                                                                                          // 700\n    return handle;                                                                                                     // 701\n  },                                                                                                                   // 702\n  methods: function (methods) {                                                                                        // 704\n    var self = this;                                                                                                   // 705\n                                                                                                                       //\n    _.each(methods, function (func, name) {                                                                            // 706\n      if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");                     // 707\n      if (self._methodHandlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");             // 709\n      self._methodHandlers[name] = func;                                                                               // 711\n    });                                                                                                                // 712\n  },                                                                                                                   // 713\n  /**                                                                                                                  // 715\n   * @memberOf Meteor                                                                                                  //\n   * @importFromPackage meteor                                                                                         //\n   * @summary Invokes a method passing any number of arguments.                                                        //\n   * @locus Anywhere                                                                                                   //\n   * @param {String} name Name of method to invoke                                                                     //\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments                                                       //\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */call: function (name /* .. [arguments] .. callback */) {                                                          //\n    // if it's a function, the last argument is the result callback,                                                   // 725\n    // not a parameter to the remote method.                                                                           // 726\n    var args = Array.prototype.slice.call(arguments, 1);                                                               // 727\n    if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();                         // 728\n    return this.apply(name, args, callback);                                                                           // 730\n  },                                                                                                                   // 731\n  // @param options {Optional Object}                                                                                  // 733\n  //   wait: Boolean - Should we wait to call this until all current methods                                           // 734\n  //                   are fully finished, and block subsequent method calls                                           // 735\n  //                   until this method is fully finished?                                                            // 736\n  //                   (does not affect methods called from within this method)                                        // 737\n  //   onResultReceived: Function - a callback to call as soon as the method                                           // 738\n  //                                result is received. the data written by                                            // 739\n  //                                the method may not yet be in the cache!                                            // 740\n  //   returnStubValue: Boolean - If true then in cases where we would have                                            // 741\n  //                              otherwise discarded the stub's return value                                          // 742\n  //                              and returned undefined, instead we go ahead                                          // 743\n  //                              and return it.  Specifically, this is any                                            // 744\n  //                              time other than when (a) we are already                                              // 745\n  //                              inside a stub or (b) we are in Node and no                                           // 746\n  //                              callback was provided.  Currently we require                                         // 747\n  //                              this flag to be explicitly passed to reduce                                          // 748\n  //                              the likelihood that stub return values will                                          // 749\n  //                              be confused with server return values; we                                            // 750\n  //                              may improve this in future.                                                          // 751\n  // @param callback {Optional Function}                                                                               // 752\n  /**                                                                                                                  // 754\n   * @memberOf Meteor                                                                                                  //\n   * @importFromPackage meteor                                                                                         //\n   * @summary Invoke a method passing an array of arguments.                                                           //\n   * @locus Anywhere                                                                                                   //\n   * @param {String} name Name of method to invoke                                                                     //\n   * @param {EJSONable[]} args Method arguments                                                                        //\n   * @param {Object} [options]                                                                                         //\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Boolean} options.throwStubExceptions (Client only) If true, exceptions thrown by method stubs will be thrown instead of logged, and the method will not be invoked on the server.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).          //\n   */apply: function (name, args, options, callback) {                                                                 //\n    var self = this; // We were passed 3 arguments. They may be either (name, args, options)                           // 769\n    // or (name, args, callback)                                                                                       // 772\n                                                                                                                       //\n    if (!callback && typeof options === 'function') {                                                                  // 773\n      callback = options;                                                                                              // 774\n      options = {};                                                                                                    // 775\n    }                                                                                                                  // 776\n                                                                                                                       //\n    options = options || {};                                                                                           // 777\n                                                                                                                       //\n    if (callback) {                                                                                                    // 779\n      // XXX would it be better form to do the binding in stream.on,                                                   // 780\n      // or caller, instead of here?                                                                                   // 781\n      // XXX improve error message (and how we report it)                                                              // 782\n      callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");                     // 783\n    } // Keep our args safe from mutation (eg if we don't send the message for a                                       // 787\n    // while because of a wait method).                                                                                // 790\n                                                                                                                       //\n                                                                                                                       //\n    args = EJSON.clone(args); // Lazily allocate method ID once we know that it'll be needed.                          // 791\n                                                                                                                       //\n    var methodId = function () {                                                                                       // 794\n      var id;                                                                                                          // 795\n      return function () {                                                                                             // 796\n        if (id === undefined) id = '' + self._nextMethodId++;                                                          // 797\n        return id;                                                                                                     // 799\n      };                                                                                                               // 800\n    }();                                                                                                               // 801\n                                                                                                                       //\n    var enclosing = DDP._CurrentMethodInvocation.get();                                                                // 803\n                                                                                                                       //\n    var alreadyInSimulation = enclosing && enclosing.isSimulation; // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client                                         // 807\n    // and the server; if the client doesn't generate any 'random' values                                              // 808\n    // then we don't expect the server to generate any either.                                                         // 809\n    // Less commonly, the server may perform different actions from the client,                                        // 810\n    // and may in fact generate values where the client did not, but we don't                                          // 811\n    // have any client-side values to match, so even here we may as well just                                          // 812\n    // use a random seed on the server.  In that case, we don't pass the                                               // 813\n    // randomSeed to save bandwidth, and we don't even generate it to save a                                           // 814\n    // bit of CPU and to avoid consuming entropy.                                                                      // 815\n                                                                                                                       //\n    var randomSeed = null;                                                                                             // 816\n                                                                                                                       //\n    var randomSeedGenerator = function () {                                                                            // 817\n      if (randomSeed === null) {                                                                                       // 818\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);                                                           // 819\n      }                                                                                                                // 820\n                                                                                                                       //\n      return randomSeed;                                                                                               // 821\n    }; // Run the stub, if we have one. The stub is supposed to make some                                              // 822\n    // temporary writes to the database to give the user a smooth experience                                           // 825\n    // until the actual result of executing the method comes back from the                                             // 826\n    // server (whereupon the temporary writes to the database will be reversed                                         // 827\n    // during the beginUpdate/endUpdate process.)                                                                      // 828\n    //                                                                                                                 // 829\n    // Normally, we ignore the return value of the stub (even if it is an                                              // 830\n    // exception), in favor of the real return value from the server. The                                              // 831\n    // exception is if the *caller* is a stub. In that case, we're not going                                           // 832\n    // to do a RPC, so we use the return value of the stub as our return                                               // 833\n    // value.                                                                                                          // 834\n                                                                                                                       //\n                                                                                                                       //\n    var stub = self._methodHandlers[name];                                                                             // 836\n                                                                                                                       //\n    if (stub) {                                                                                                        // 837\n      var setUserId = function (userId) {                                                                              // 838\n        self.setUserId(userId);                                                                                        // 839\n      };                                                                                                               // 840\n                                                                                                                       //\n      var invocation = new DDPCommon.MethodInvocation({                                                                // 842\n        isSimulation: true,                                                                                            // 843\n        userId: self.userId(),                                                                                         // 844\n        setUserId: setUserId,                                                                                          // 845\n        randomSeed: function () {                                                                                      // 846\n          return randomSeedGenerator();                                                                                // 846\n        }                                                                                                              // 846\n      });                                                                                                              // 842\n      if (!alreadyInSimulation) self._saveOriginals();                                                                 // 849\n                                                                                                                       //\n      try {                                                                                                            // 852\n        // Note that unlike in the corresponding server code, we never audit                                           // 853\n        // that stubs check() their arguments.                                                                         // 854\n        var stubReturnValue = DDP._CurrentMethodInvocation.withValue(invocation, function () {                         // 855\n          if (Meteor.isServer) {                                                                                       // 856\n            // Because saveOriginals and retrieveOriginals aren't reentrant,                                           // 857\n            // don't allow stubs to yield.                                                                             // 858\n            return Meteor._noYieldsAllowed(function () {                                                               // 859\n              // re-clone, so that the stub can't affect our caller's values                                           // 860\n              return stub.apply(invocation, EJSON.clone(args));                                                        // 861\n            });                                                                                                        // 862\n          } else {                                                                                                     // 863\n            return stub.apply(invocation, EJSON.clone(args));                                                          // 864\n          }                                                                                                            // 865\n        });                                                                                                            // 866\n      } catch (e) {                                                                                                    // 867\n        var exception = e;                                                                                             // 869\n      }                                                                                                                // 870\n                                                                                                                       //\n      if (!alreadyInSimulation) self._retrieveAndStoreOriginals(methodId());                                           // 872\n    } // If we're in a simulation, stop and return the result we have,                                                 // 874\n    // rather than going on to do an RPC. If there was no stub,                                                        // 877\n    // we'll end up returning undefined.                                                                               // 878\n                                                                                                                       //\n                                                                                                                       //\n    if (alreadyInSimulation) {                                                                                         // 879\n      if (callback) {                                                                                                  // 880\n        callback(exception, stubReturnValue);                                                                          // 881\n        return undefined;                                                                                              // 882\n      }                                                                                                                // 883\n                                                                                                                       //\n      if (exception) throw exception;                                                                                  // 884\n      return stubReturnValue;                                                                                          // 886\n    } // If an exception occurred in a stub, and we're ignoring it                                                     // 887\n    // because we're doing an RPC and want to use what the server                                                      // 890\n    // returns instead, log it so the developer knows                                                                  // 891\n    // (unless they explicitly ask to see the error).                                                                  // 892\n    //                                                                                                                 // 893\n    // Tests can set the 'expected' flag on an exception so it won't                                                   // 894\n    // go to log.                                                                                                      // 895\n                                                                                                                       //\n                                                                                                                       //\n    if (exception) {                                                                                                   // 896\n      if (options.throwStubExceptions) {                                                                               // 897\n        throw exception;                                                                                               // 898\n      } else if (!exception.expected) {                                                                                // 899\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" + name + \"'\", exception, exception.stack);\n      }                                                                                                                // 902\n    } // At this point we're definitely doing an RPC, and we're going to                                               // 903\n    // return the value of the RPC to the caller.                                                                      // 907\n    // If the caller didn't give a callback, decide what to do.                                                        // 909\n                                                                                                                       //\n                                                                                                                       //\n    if (!callback) {                                                                                                   // 910\n      if (Meteor.isClient) {                                                                                           // 911\n        // On the client, we don't have fibers, so we can't block. The                                                 // 912\n        // only thing we can do is to return undefined and discard the                                                 // 913\n        // result of the RPC. If an error occurred then print the error                                                // 914\n        // to the console.                                                                                             // 915\n        callback = function (err) {                                                                                    // 916\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\", err.message);                                  // 917\n        };                                                                                                             // 919\n      } else {                                                                                                         // 920\n        // On the server, make the function synchronous. Throw on                                                      // 921\n        // errors, return on success.                                                                                  // 922\n        var future = new Future();                                                                                     // 923\n        callback = future.resolver();                                                                                  // 924\n      }                                                                                                                // 925\n    } // Send the RPC. Note that on the client, it is important that the                                               // 926\n    // stub have finished before we send the RPC, so that we know we have                                              // 928\n    // a complete list of which local documents the stub wrote.                                                        // 929\n                                                                                                                       //\n                                                                                                                       //\n    var message = {                                                                                                    // 930\n      msg: 'method',                                                                                                   // 931\n      method: name,                                                                                                    // 932\n      params: args,                                                                                                    // 933\n      id: methodId()                                                                                                   // 934\n    }; // Send the randomSeed only if we used it                                                                       // 930\n                                                                                                                       //\n    if (randomSeed !== null) {                                                                                         // 938\n      message.randomSeed = randomSeed;                                                                                 // 939\n    }                                                                                                                  // 940\n                                                                                                                       //\n    var methodInvoker = new MethodInvoker({                                                                            // 942\n      methodId: methodId(),                                                                                            // 943\n      callback: callback,                                                                                              // 944\n      connection: self,                                                                                                // 945\n      onResultReceived: options.onResultReceived,                                                                      // 946\n      wait: !!options.wait,                                                                                            // 947\n      message: message,                                                                                                // 948\n      noRetry: !!options.noRetry                                                                                       // 949\n    });                                                                                                                // 942\n                                                                                                                       //\n    if (options.wait) {                                                                                                // 952\n      // It's a wait method! Wait methods go in their own block.                                                       // 953\n      self._outstandingMethodBlocks.push({                                                                             // 954\n        wait: true,                                                                                                    // 955\n        methods: [methodInvoker]                                                                                       // 955\n      });                                                                                                              // 955\n    } else {                                                                                                           // 956\n      // Not a wait method. Start a new block if the previous block was a wait                                         // 957\n      // block, and add it to the last block of methods.                                                               // 958\n      if (_.isEmpty(self._outstandingMethodBlocks) || _.last(self._outstandingMethodBlocks).wait) self._outstandingMethodBlocks.push({\n        wait: false,                                                                                                   // 961\n        methods: []                                                                                                    // 961\n      });                                                                                                              // 961\n                                                                                                                       //\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                               // 962\n    } // If we added it to the first block, send it out now.                                                           // 963\n                                                                                                                       //\n                                                                                                                       //\n    if (self._outstandingMethodBlocks.length === 1) methodInvoker.sendMessage(); // If we're using the default callback on the server,\n    // block waiting for the result.                                                                                   // 970\n                                                                                                                       //\n    if (future) {                                                                                                      // 971\n      return future.wait();                                                                                            // 972\n    }                                                                                                                  // 973\n                                                                                                                       //\n    return options.returnStubValue ? stubReturnValue : undefined;                                                      // 974\n  },                                                                                                                   // 975\n  // Before calling a method stub, prepare all stores to track changes and allow                                       // 977\n  // _retrieveAndStoreOriginals to get the original versions of changed                                                // 978\n  // documents.                                                                                                        // 979\n  _saveOriginals: function () {                                                                                        // 980\n    var self = this;                                                                                                   // 981\n    if (!self._waitingForQuiescence()) self._flushBufferedWrites();                                                    // 982\n                                                                                                                       //\n    _.each(self._stores, function (s) {                                                                                // 984\n      s.saveOriginals();                                                                                               // 985\n    });                                                                                                                // 986\n  },                                                                                                                   // 987\n  // Retrieves the original versions of all documents modified by the stub for                                         // 988\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                       // 989\n  // by document) and _documentsWrittenByStub (keyed by method ID).                                                    // 990\n  _retrieveAndStoreOriginals: function (methodId) {                                                                    // 991\n    var self = this;                                                                                                   // 992\n    if (self._documentsWrittenByStub[methodId]) throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");   // 993\n    var docsWritten = [];                                                                                              // 996\n                                                                                                                       //\n    _.each(self._stores, function (s, collection) {                                                                    // 997\n      var originals = s.retrieveOriginals(); // not all stores define retrieveOriginals                                // 998\n                                                                                                                       //\n      if (!originals) return;                                                                                          // 1000\n      originals.forEach(function (doc, id) {                                                                           // 1002\n        docsWritten.push({                                                                                             // 1003\n          collection: collection,                                                                                      // 1003\n          id: id                                                                                                       // 1003\n        });                                                                                                            // 1003\n        if (!_.has(self._serverDocuments, collection)) self._serverDocuments[collection] = new MongoIDMap();           // 1004\n                                                                                                                       //\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});                                          // 1006\n                                                                                                                       //\n        if (serverDoc.writtenByStubs) {                                                                                // 1007\n          // We're not the first stub to write this doc. Just add our method ID                                        // 1008\n          // to the record.                                                                                            // 1009\n          serverDoc.writtenByStubs[methodId] = true;                                                                   // 1010\n        } else {                                                                                                       // 1011\n          // First stub! Save the original value and our method ID.                                                    // 1012\n          serverDoc.document = doc;                                                                                    // 1013\n          serverDoc.flushCallbacks = [];                                                                               // 1014\n          serverDoc.writtenByStubs = {};                                                                               // 1015\n          serverDoc.writtenByStubs[methodId] = true;                                                                   // 1016\n        }                                                                                                              // 1017\n      });                                                                                                              // 1018\n    });                                                                                                                // 1019\n                                                                                                                       //\n    if (!_.isEmpty(docsWritten)) {                                                                                     // 1020\n      self._documentsWrittenByStub[methodId] = docsWritten;                                                            // 1021\n    }                                                                                                                  // 1022\n  },                                                                                                                   // 1023\n  // This is very much a private function we use to make the tests                                                     // 1025\n  // take up fewer server resources after they complete.                                                               // 1026\n  _unsubscribeAll: function () {                                                                                       // 1027\n    var self = this;                                                                                                   // 1028\n                                                                                                                       //\n    _.each(_.clone(self._subscriptions), function (sub, id) {                                                          // 1029\n      // Avoid killing the autoupdate subscription so that developers                                                  // 1030\n      // still get hot code pushes when writing tests.                                                                 // 1031\n      //                                                                                                               // 1032\n      // XXX it's a hack to encode knowledge about autoupdate here,                                                    // 1033\n      // but it doesn't seem worth it yet to have a special API for                                                    // 1034\n      // subscriptions to preserve after unit tests.                                                                   // 1035\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {                                                           // 1036\n        self._subscriptions[id].stop();                                                                                // 1037\n      }                                                                                                                // 1038\n    });                                                                                                                // 1039\n  },                                                                                                                   // 1040\n  // Sends the DDP stringification of the given message object                                                         // 1042\n  _send: function (obj) {                                                                                              // 1043\n    var self = this;                                                                                                   // 1044\n                                                                                                                       //\n    self._stream.send(DDPCommon.stringifyDDP(obj));                                                                    // 1045\n  },                                                                                                                   // 1046\n  // We detected via DDP-level heartbeats that we've lost the                                                          // 1048\n  // connection.  Unlike `disconnect` or `close`, a lost connection                                                    // 1049\n  // will be automatically retried.                                                                                    // 1050\n  _lostConnection: function (error) {                                                                                  // 1051\n    var self = this;                                                                                                   // 1052\n                                                                                                                       //\n    self._stream._lostConnection(error);                                                                               // 1053\n  },                                                                                                                   // 1054\n  /**                                                                                                                  // 1056\n   * @summary Get the current connection status. A reactive data source.                                               //\n   * @locus Client                                                                                                     //\n   * @memberOf Meteor                                                                                                  //\n   * @importFromPackage meteor                                                                                         //\n   */status: function () /*passthrough args*/{                                                                         //\n    var self = this;                                                                                                   // 1063\n    return self._stream.status.apply(self._stream, arguments);                                                         // 1064\n  },                                                                                                                   // 1065\n  /**                                                                                                                  // 1067\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.                    //\n   This method does nothing if the client is already connected.                                                        //\n   * @locus Client                                                                                                     //\n   * @memberOf Meteor                                                                                                  //\n   * @importFromPackage meteor                                                                                         //\n   */reconnect: function () /*passthrough args*/{                                                                      //\n    var self = this;                                                                                                   // 1076\n    return self._stream.reconnect.apply(self._stream, arguments);                                                      // 1077\n  },                                                                                                                   // 1078\n  /**                                                                                                                  // 1080\n   * @summary Disconnect the client from the server.                                                                   //\n   * @locus Client                                                                                                     //\n   * @memberOf Meteor                                                                                                  //\n   * @importFromPackage meteor                                                                                         //\n   */disconnect: function () /*passthrough args*/{                                                                     //\n    var self = this;                                                                                                   // 1087\n    return self._stream.disconnect.apply(self._stream, arguments);                                                     // 1088\n  },                                                                                                                   // 1089\n  close: function () {                                                                                                 // 1091\n    var self = this;                                                                                                   // 1092\n    return self._stream.disconnect({                                                                                   // 1093\n      _permanent: true                                                                                                 // 1093\n    });                                                                                                                // 1093\n  },                                                                                                                   // 1094\n  ///                                                                                                                  // 1096\n  /// Reactive user system                                                                                             // 1097\n  ///                                                                                                                  // 1098\n  userId: function () {                                                                                                // 1099\n    var self = this;                                                                                                   // 1100\n    if (self._userIdDeps) self._userIdDeps.depend();                                                                   // 1101\n    return self._userId;                                                                                               // 1103\n  },                                                                                                                   // 1104\n  setUserId: function (userId) {                                                                                       // 1106\n    var self = this; // Avoid invalidating dependents if setUserId is called with current value.                       // 1107\n                                                                                                                       //\n    if (self._userId === userId) return;                                                                               // 1109\n    self._userId = userId;                                                                                             // 1111\n    if (self._userIdDeps) self._userIdDeps.changed();                                                                  // 1112\n  },                                                                                                                   // 1114\n  // Returns true if we are in a state after reconnect of waiting for subs to be                                       // 1116\n  // revived or early methods to finish their data, or we are waiting for a                                            // 1117\n  // \"wait\" method to finish.                                                                                          // 1118\n  _waitingForQuiescence: function () {                                                                                 // 1119\n    var self = this;                                                                                                   // 1120\n    return !_.isEmpty(self._subsBeingRevived) || !_.isEmpty(self._methodsBlockingQuiescence);                          // 1121\n  },                                                                                                                   // 1123\n  // Returns true if any method whose message has been sent to the server has                                          // 1125\n  // not yet invoked its user callback.                                                                                // 1126\n  _anyMethodsAreOutstanding: function () {                                                                             // 1127\n    var self = this;                                                                                                   // 1128\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                        // 1129\n  },                                                                                                                   // 1130\n  _livedata_connected: function (msg) {                                                                                // 1132\n    var self = this;                                                                                                   // 1133\n                                                                                                                       //\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {                                                   // 1135\n      self._heartbeat = new DDPCommon.Heartbeat({                                                                      // 1136\n        heartbeatInterval: self._heartbeatInterval,                                                                    // 1137\n        heartbeatTimeout: self._heartbeatTimeout,                                                                      // 1138\n        onTimeout: function () {                                                                                       // 1139\n          self._lostConnection(new DDP.ConnectionError(\"DDP heartbeat timed out\"));                                    // 1140\n        },                                                                                                             // 1142\n        sendPing: function () {                                                                                        // 1143\n          self._send({                                                                                                 // 1144\n            msg: 'ping'                                                                                                // 1144\n          });                                                                                                          // 1144\n        }                                                                                                              // 1145\n      });                                                                                                              // 1136\n                                                                                                                       //\n      self._heartbeat.start();                                                                                         // 1147\n    } // If this is a reconnect, we'll have to reset all stores.                                                       // 1148\n                                                                                                                       //\n                                                                                                                       //\n    if (self._lastSessionId) self._resetStores = true;                                                                 // 1151\n                                                                                                                       //\n    if (typeof msg.session === \"string\") {                                                                             // 1154\n      var reconnectedToPreviousSession = self._lastSessionId === msg.session;                                          // 1155\n      self._lastSessionId = msg.session;                                                                               // 1156\n    }                                                                                                                  // 1157\n                                                                                                                       //\n    if (reconnectedToPreviousSession) {                                                                                // 1159\n      // Successful reconnection -- pick up where we left off.  Note that right                                        // 1160\n      // now, this never happens: the server never connects us to a previous                                           // 1161\n      // session, because DDP doesn't provide enough data for the server to know                                       // 1162\n      // what messages the client has processed. We need to improve DDP to make                                        // 1163\n      // this possible, at which point we'll probably need more code here.                                             // 1164\n      return;                                                                                                          // 1165\n    } // Server doesn't have our data any more. Re-sync a new session.                                                 // 1166\n    // Forget about messages we were buffering for unknown collections. They'll                                        // 1170\n    // be resent if still relevant.                                                                                    // 1171\n                                                                                                                       //\n                                                                                                                       //\n    self._updatesForUnknownStores = {};                                                                                // 1172\n                                                                                                                       //\n    if (self._resetStores) {                                                                                           // 1174\n      // Forget about the effects of stubs. We'll be resetting all collections                                         // 1175\n      // anyway.                                                                                                       // 1176\n      self._documentsWrittenByStub = {};                                                                               // 1177\n      self._serverDocuments = {};                                                                                      // 1178\n    } // Clear _afterUpdateCallbacks.                                                                                  // 1179\n                                                                                                                       //\n                                                                                                                       //\n    self._afterUpdateCallbacks = []; // Mark all named subscriptions which are ready (ie, we already called the        // 1182\n    // ready callback) as needing to be revived.                                                                       // 1185\n    // XXX We should also block reconnect quiescence until unnamed subscriptions                                       // 1186\n    //     (eg, autopublish) are done re-publishing to avoid flicker!                                                  // 1187\n                                                                                                                       //\n    self._subsBeingRevived = {};                                                                                       // 1188\n                                                                                                                       //\n    _.each(self._subscriptions, function (sub, id) {                                                                   // 1189\n      if (sub.ready) self._subsBeingRevived[id] = true;                                                                // 1190\n    }); // Arrange for \"half-finished\" methods to have their callbacks run, and                                        // 1192\n    // track methods that were sent on this connection so that we don't                                                // 1195\n    // quiesce until they are all done.                                                                                // 1196\n    //                                                                                                                 // 1197\n    // Start by clearing _methodsBlockingQuiescence: methods sent before                                               // 1198\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection                                       // 1199\n    // that we drop here will be restored by the loop below.                                                           // 1200\n                                                                                                                       //\n                                                                                                                       //\n    self._methodsBlockingQuiescence = {};                                                                              // 1201\n                                                                                                                       //\n    if (self._resetStores) {                                                                                           // 1202\n      _.each(self._methodInvokers, function (invoker) {                                                                // 1203\n        if (invoker.gotResult()) {                                                                                     // 1204\n          // This method already got its result, but it didn't call its callback                                       // 1205\n          // because its data didn't become visible. We did not resend the                                             // 1206\n          // method RPC. We'll call its callback when we get a full quiesce,                                           // 1207\n          // since that's as close as we'll get to \"data must be visible\".                                             // 1208\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                       // 1209\n        } else if (invoker.sentMessage) {                                                                              // 1210\n          // This method has been sent on this connection (maybe as a resend                                           // 1211\n          // from the last connection, maybe from onReconnect, maybe just very                                         // 1212\n          // quickly before processing the connected message).                                                         // 1213\n          //                                                                                                           // 1214\n          // We don't need to do anything special to ensure its callbacks get                                          // 1215\n          // called, but we'll count it as a method which is preventing                                                // 1216\n          // reconnect quiescence. (eg, it might be a login method that was run                                        // 1217\n          // from onReconnect, and we don't want to see flicker by seeing a                                            // 1218\n          // logged-out state.)                                                                                        // 1219\n          self._methodsBlockingQuiescence[invoker.methodId] = true;                                                    // 1220\n        }                                                                                                              // 1221\n      });                                                                                                              // 1222\n    }                                                                                                                  // 1223\n                                                                                                                       //\n    self._messagesBufferedUntilQuiescence = []; // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.                                                                                 // 1228\n                                                                                                                       //\n    if (!self._waitingForQuiescence()) {                                                                               // 1229\n      if (self._resetStores) {                                                                                         // 1230\n        _.each(self._stores, function (s) {                                                                            // 1231\n          s.beginUpdate(0, true);                                                                                      // 1232\n          s.endUpdate();                                                                                               // 1233\n        });                                                                                                            // 1234\n                                                                                                                       //\n        self._resetStores = false;                                                                                     // 1235\n      }                                                                                                                // 1236\n                                                                                                                       //\n      self._runAfterUpdateCallbacks();                                                                                 // 1237\n    }                                                                                                                  // 1238\n  },                                                                                                                   // 1239\n  _processOneDataMessage: function (msg, updates) {                                                                    // 1242\n    var self = this; // Using underscore here so as not to need to capitalize.                                         // 1243\n                                                                                                                       //\n    self['_process_' + msg.msg](msg, updates);                                                                         // 1245\n  },                                                                                                                   // 1246\n  _livedata_data: function (msg) {                                                                                     // 1249\n    var self = this;                                                                                                   // 1250\n                                                                                                                       //\n    if (self._waitingForQuiescence()) {                                                                                // 1252\n      self._messagesBufferedUntilQuiescence.push(msg);                                                                 // 1253\n                                                                                                                       //\n      if (msg.msg === \"nosub\") delete self._subsBeingRevived[msg.id];                                                  // 1255\n                                                                                                                       //\n      _.each(msg.subs || [], function (subId) {                                                                        // 1258\n        delete self._subsBeingRevived[subId];                                                                          // 1259\n      });                                                                                                              // 1260\n                                                                                                                       //\n      _.each(msg.methods || [], function (methodId) {                                                                  // 1261\n        delete self._methodsBlockingQuiescence[methodId];                                                              // 1262\n      });                                                                                                              // 1263\n                                                                                                                       //\n      if (self._waitingForQuiescence()) return; // No methods or subs are blocking quiescence!                         // 1265\n      // We'll now process and all of our buffered messages, reset all stores,                                         // 1269\n      // and apply them all at once.                                                                                   // 1270\n                                                                                                                       //\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                           // 1271\n        self._processOneDataMessage(bufferedMsg, self._bufferedWrites);                                                // 1272\n      });                                                                                                              // 1273\n                                                                                                                       //\n      self._messagesBufferedUntilQuiescence = [];                                                                      // 1274\n    } else {                                                                                                           // 1275\n      self._processOneDataMessage(msg, self._bufferedWrites);                                                          // 1276\n    } // Immediately flush writes when:                                                                                // 1277\n    //  1. Buffering is disabled. Or;                                                                                  // 1280\n    //  2. any non-(added/changed/removed) message arrives.                                                            // 1281\n                                                                                                                       //\n                                                                                                                       //\n    var standardWrite = _.include(['added', 'changed', 'removed'], msg.msg);                                           // 1282\n                                                                                                                       //\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {                                                        // 1283\n      self._flushBufferedWrites();                                                                                     // 1284\n                                                                                                                       //\n      return;                                                                                                          // 1285\n    }                                                                                                                  // 1286\n                                                                                                                       //\n    if (self._bufferedWritesFlushAt === null) {                                                                        // 1288\n      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;                                 // 1289\n    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {                                                   // 1290\n      self._flushBufferedWrites();                                                                                     // 1292\n                                                                                                                       //\n      return;                                                                                                          // 1293\n    }                                                                                                                  // 1294\n                                                                                                                       //\n    if (self._bufferedWritesFlushHandle) {                                                                             // 1296\n      clearTimeout(self._bufferedWritesFlushHandle);                                                                   // 1297\n    }                                                                                                                  // 1298\n                                                                                                                       //\n    self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites, self._bufferedWritesInterval);            // 1299\n  },                                                                                                                   // 1301\n  _flushBufferedWrites: function () {                                                                                  // 1303\n    var self = this;                                                                                                   // 1304\n                                                                                                                       //\n    if (self._bufferedWritesFlushHandle) {                                                                             // 1305\n      clearTimeout(self._bufferedWritesFlushHandle);                                                                   // 1306\n      self._bufferedWritesFlushHandle = null;                                                                          // 1307\n    }                                                                                                                  // 1308\n                                                                                                                       //\n    self._bufferedWritesFlushAt = null; // We need to clear the buffer before passing it to                            // 1310\n    //  performWrites. As there's no guarantee that it                                                                 // 1312\n    //  will exit cleanly.                                                                                             // 1313\n                                                                                                                       //\n    var writes = self._bufferedWrites;                                                                                 // 1314\n    self._bufferedWrites = {};                                                                                         // 1315\n                                                                                                                       //\n    self._performWrites(writes);                                                                                       // 1316\n  },                                                                                                                   // 1317\n  _performWrites: function (updates) {                                                                                 // 1319\n    var self = this;                                                                                                   // 1320\n                                                                                                                       //\n    if (self._resetStores || !_.isEmpty(updates)) {                                                                    // 1322\n      // Begin a transactional update of each store.                                                                   // 1323\n      _.each(self._stores, function (s, storeName) {                                                                   // 1324\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0, self._resetStores);                   // 1325\n      });                                                                                                              // 1327\n                                                                                                                       //\n      self._resetStores = false;                                                                                       // 1328\n                                                                                                                       //\n      _.each(updates, function (updateMessages, storeName) {                                                           // 1330\n        var store = self._stores[storeName];                                                                           // 1331\n                                                                                                                       //\n        if (store) {                                                                                                   // 1332\n          _.each(updateMessages, function (updateMessage) {                                                            // 1333\n            store.update(updateMessage);                                                                               // 1334\n          });                                                                                                          // 1335\n        } else {                                                                                                       // 1336\n          // Nobody's listening for this data. Queue it up until                                                       // 1337\n          // someone wants it.                                                                                         // 1338\n          // XXX memory use will grow without bound if you forget to                                                   // 1339\n          // create a collection or just don't care about it... going                                                  // 1340\n          // to have to do something about that.                                                                       // 1341\n          if (!_.has(self._updatesForUnknownStores, storeName)) self._updatesForUnknownStores[storeName] = [];         // 1342\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName], updateMessages);                        // 1344\n        }                                                                                                              // 1346\n      }); // End update transaction.                                                                                   // 1347\n                                                                                                                       //\n                                                                                                                       //\n      _.each(self._stores, function (s) {                                                                              // 1350\n        s.endUpdate();                                                                                                 // 1350\n      });                                                                                                              // 1350\n    }                                                                                                                  // 1351\n                                                                                                                       //\n    self._runAfterUpdateCallbacks();                                                                                   // 1353\n  },                                                                                                                   // 1354\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                            // 1356\n  // relevant docs have been flushed, as well as dataVisible callbacks at                                              // 1357\n  // reconnect-quiescence time.                                                                                        // 1358\n  _runAfterUpdateCallbacks: function () {                                                                              // 1359\n    var self = this;                                                                                                   // 1360\n    var callbacks = self._afterUpdateCallbacks;                                                                        // 1361\n    self._afterUpdateCallbacks = [];                                                                                   // 1362\n                                                                                                                       //\n    _.each(callbacks, function (c) {                                                                                   // 1363\n      c();                                                                                                             // 1364\n    });                                                                                                                // 1365\n  },                                                                                                                   // 1366\n  _pushUpdate: function (updates, collection, msg) {                                                                   // 1368\n    var self = this;                                                                                                   // 1369\n                                                                                                                       //\n    if (!_.has(updates, collection)) {                                                                                 // 1370\n      updates[collection] = [];                                                                                        // 1371\n    }                                                                                                                  // 1372\n                                                                                                                       //\n    updates[collection].push(msg);                                                                                     // 1373\n  },                                                                                                                   // 1374\n  _getServerDoc: function (collection, id) {                                                                           // 1376\n    var self = this;                                                                                                   // 1377\n    if (!_.has(self._serverDocuments, collection)) return null;                                                        // 1378\n    var serverDocsForCollection = self._serverDocuments[collection];                                                   // 1380\n    return serverDocsForCollection.get(id) || null;                                                                    // 1381\n  },                                                                                                                   // 1382\n  _process_added: function (msg, updates) {                                                                            // 1384\n    var self = this;                                                                                                   // 1385\n    var id = MongoID.idParse(msg.id);                                                                                  // 1386\n                                                                                                                       //\n    var serverDoc = self._getServerDoc(msg.collection, id);                                                            // 1387\n                                                                                                                       //\n    if (serverDoc) {                                                                                                   // 1388\n      // Some outstanding stub wrote here.                                                                             // 1389\n      var isExisting = serverDoc.document !== undefined;                                                               // 1390\n      serverDoc.document = msg.fields || {};                                                                           // 1392\n      serverDoc.document._id = id;                                                                                     // 1393\n                                                                                                                       //\n      if (self._resetStores) {                                                                                         // 1395\n        // During reconnect the server is sending adds for existing ids.                                               // 1396\n        // Always push an update so that document stays in the store after                                             // 1397\n        // reset. Use current version of the document for this update, so                                              // 1398\n        // that stub-written values are preserved.                                                                     // 1399\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);                                                  // 1400\n                                                                                                                       //\n        if (currentDoc !== undefined) msg.fields = currentDoc;                                                         // 1401\n                                                                                                                       //\n        self._pushUpdate(updates, msg.collection, msg);                                                                // 1404\n      } else if (isExisting) {                                                                                         // 1405\n        throw new Error(\"Server sent add for existing id: \" + msg.id);                                                 // 1406\n      }                                                                                                                // 1407\n    } else {                                                                                                           // 1408\n      self._pushUpdate(updates, msg.collection, msg);                                                                  // 1409\n    }                                                                                                                  // 1410\n  },                                                                                                                   // 1411\n  _process_changed: function (msg, updates) {                                                                          // 1413\n    var self = this;                                                                                                   // 1414\n                                                                                                                       //\n    var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));                                       // 1415\n                                                                                                                       //\n    if (serverDoc) {                                                                                                   // 1417\n      if (serverDoc.document === undefined) throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);      // 1418\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);                                                       // 1420\n    } else {                                                                                                           // 1421\n      self._pushUpdate(updates, msg.collection, msg);                                                                  // 1422\n    }                                                                                                                  // 1423\n  },                                                                                                                   // 1424\n  _process_removed: function (msg, updates) {                                                                          // 1426\n    var self = this;                                                                                                   // 1427\n                                                                                                                       //\n    var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));                                       // 1428\n                                                                                                                       //\n    if (serverDoc) {                                                                                                   // 1430\n      // Some outstanding stub wrote here.                                                                             // 1431\n      if (serverDoc.document === undefined) throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);       // 1432\n      serverDoc.document = undefined;                                                                                  // 1434\n    } else {                                                                                                           // 1435\n      self._pushUpdate(updates, msg.collection, {                                                                      // 1436\n        msg: 'removed',                                                                                                // 1437\n        collection: msg.collection,                                                                                    // 1438\n        id: msg.id                                                                                                     // 1439\n      });                                                                                                              // 1436\n    }                                                                                                                  // 1441\n  },                                                                                                                   // 1442\n  _process_updated: function (msg, updates) {                                                                          // 1444\n    var self = this; // Process \"method done\" messages.                                                                // 1445\n                                                                                                                       //\n    _.each(msg.methods, function (methodId) {                                                                          // 1447\n      _.each(self._documentsWrittenByStub[methodId], function (written) {                                              // 1448\n        var serverDoc = self._getServerDoc(written.collection, written.id);                                            // 1449\n                                                                                                                       //\n        if (!serverDoc) throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));                              // 1450\n        if (!serverDoc.writtenByStubs[methodId]) throw new Error(\"Doc \" + JSON.stringify(written) + \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];                                                                     // 1455\n                                                                                                                       //\n        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                     // 1456\n          // All methods whose stubs wrote this method have completed! We can                                          // 1457\n          // now copy the saved document to the database (reverting the stub's                                         // 1458\n          // change if the server did not write to this object, or applying the                                        // 1459\n          // server's writes if it did).                                                                               // 1460\n          // This is a fake ddp 'replace' message.  It's just for talking                                              // 1462\n          // between livedata connections and minimongo.  (We have to stringify                                        // 1463\n          // the ID because it's supposed to look like a wire message.)                                                // 1464\n          self._pushUpdate(updates, written.collection, {                                                              // 1465\n            msg: 'replace',                                                                                            // 1466\n            id: MongoID.idStringify(written.id),                                                                       // 1467\n            replace: serverDoc.document                                                                                // 1468\n          }); // Call all flush callbacks.                                                                             // 1465\n                                                                                                                       //\n                                                                                                                       //\n          _.each(serverDoc.flushCallbacks, function (c) {                                                              // 1471\n            c();                                                                                                       // 1472\n          }); // Delete this completed serverDocument. Don't bother to GC empty                                        // 1473\n          // IdMaps inside self._serverDocuments, since there probably aren't                                          // 1476\n          // many collections and they'll be written repeatedly.                                                       // 1477\n                                                                                                                       //\n                                                                                                                       //\n          self._serverDocuments[written.collection].remove(written.id);                                                // 1478\n        }                                                                                                              // 1479\n      });                                                                                                              // 1480\n                                                                                                                       //\n      delete self._documentsWrittenByStub[methodId]; // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.                                                                      // 1484\n                                                                                                                       //\n      var callbackInvoker = self._methodInvokers[methodId];                                                            // 1485\n      if (!callbackInvoker) throw new Error(\"No callback invoker for method \" + methodId);                             // 1486\n                                                                                                                       //\n      self._runWhenAllServerDocsAreFlushed(_.bind(callbackInvoker.dataVisible, callbackInvoker));                      // 1488\n    });                                                                                                                // 1490\n  },                                                                                                                   // 1491\n  _process_ready: function (msg, updates) {                                                                            // 1493\n    var self = this; // Process \"sub ready\" messages. \"sub ready\" messages don't take effect                           // 1494\n    // until all current server documents have been flushed to the local                                               // 1496\n    // database. We can use a write fence to implement this.                                                           // 1497\n                                                                                                                       //\n    _.each(msg.subs, function (subId) {                                                                                // 1498\n      self._runWhenAllServerDocsAreFlushed(function () {                                                               // 1499\n        var subRecord = self._subscriptions[subId]; // Did we already unsubscribe?                                     // 1500\n                                                                                                                       //\n        if (!subRecord) return; // Did we already receive a ready message? (Oops!)                                     // 1502\n                                                                                                                       //\n        if (subRecord.ready) return;                                                                                   // 1505\n        subRecord.ready = true;                                                                                        // 1507\n        subRecord.readyCallback && subRecord.readyCallback();                                                          // 1508\n        subRecord.readyDeps.changed();                                                                                 // 1509\n      });                                                                                                              // 1510\n    });                                                                                                                // 1511\n  },                                                                                                                   // 1512\n  // Ensures that \"f\" will be called after all documents currently in                                                  // 1514\n  // _serverDocuments have been written to the local cache. f will not be called                                       // 1515\n  // if the connection is lost before then!                                                                            // 1516\n  _runWhenAllServerDocsAreFlushed: function (f) {                                                                      // 1517\n    var self = this;                                                                                                   // 1518\n                                                                                                                       //\n    var runFAfterUpdates = function () {                                                                               // 1519\n      self._afterUpdateCallbacks.push(f);                                                                              // 1520\n    };                                                                                                                 // 1521\n                                                                                                                       //\n    var unflushedServerDocCount = 0;                                                                                   // 1522\n                                                                                                                       //\n    var onServerDocFlush = function () {                                                                               // 1523\n      --unflushedServerDocCount;                                                                                       // 1524\n                                                                                                                       //\n      if (unflushedServerDocCount === 0) {                                                                             // 1525\n        // This was the last doc to flush! Arrange to run f after the updates                                          // 1526\n        // have been applied.                                                                                          // 1527\n        runFAfterUpdates();                                                                                            // 1528\n      }                                                                                                                // 1529\n    };                                                                                                                 // 1530\n                                                                                                                       //\n    _.each(self._serverDocuments, function (collectionDocs) {                                                          // 1531\n      collectionDocs.forEach(function (serverDoc) {                                                                    // 1532\n        var writtenByStubForAMethodWithSentMessage = _.any(serverDoc.writtenByStubs, function (dummy, methodId) {      // 1533\n          var invoker = self._methodInvokers[methodId];                                                                // 1535\n          return invoker && invoker.sentMessage;                                                                       // 1536\n        });                                                                                                            // 1537\n                                                                                                                       //\n        if (writtenByStubForAMethodWithSentMessage) {                                                                  // 1538\n          ++unflushedServerDocCount;                                                                                   // 1539\n          serverDoc.flushCallbacks.push(onServerDocFlush);                                                             // 1540\n        }                                                                                                              // 1541\n      });                                                                                                              // 1542\n    });                                                                                                                // 1543\n                                                                                                                       //\n    if (unflushedServerDocCount === 0) {                                                                               // 1544\n      // There aren't any buffered docs --- we can call f as soon as the current                                       // 1545\n      // round of updates is applied!                                                                                  // 1546\n      runFAfterUpdates();                                                                                              // 1547\n    }                                                                                                                  // 1548\n  },                                                                                                                   // 1549\n  _livedata_nosub: function (msg) {                                                                                    // 1551\n    var self = this; // First pass it through _livedata_data, which only uses it to help get                           // 1552\n    // towards quiescence.                                                                                             // 1555\n                                                                                                                       //\n    self._livedata_data(msg); // Do the rest of our processing immediately, with no                                    // 1556\n    // buffering-until-quiescence.                                                                                     // 1559\n    // we weren't subbed anyway, or we initiated the unsub.                                                            // 1561\n                                                                                                                       //\n                                                                                                                       //\n    if (!_.has(self._subscriptions, msg.id)) return; // XXX COMPAT WITH 1.0.3.1 #errorCallback                         // 1562\n                                                                                                                       //\n    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                     // 1566\n    var stopCallback = self._subscriptions[msg.id].stopCallback;                                                       // 1567\n                                                                                                                       //\n    self._subscriptions[msg.id].remove();                                                                              // 1569\n                                                                                                                       //\n    var meteorErrorFromMsg = function (msgArg) {                                                                       // 1571\n      return msgArg && msgArg.error && new Meteor.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }; // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                       // 1574\n                                                                                                                       //\n                                                                                                                       //\n    if (errorCallback && msg.error) {                                                                                  // 1577\n      errorCallback(meteorErrorFromMsg(msg));                                                                          // 1578\n    }                                                                                                                  // 1579\n                                                                                                                       //\n    if (stopCallback) {                                                                                                // 1581\n      stopCallback(meteorErrorFromMsg(msg));                                                                           // 1582\n    }                                                                                                                  // 1583\n  },                                                                                                                   // 1584\n  _process_nosub: function () {// This is called as part of the \"buffer until quiescence\" process, but                 // 1586\n    // nosub's effect is always immediate. It only goes in the buffer at all                                           // 1588\n    // because it's possible for a nosub to be the thing that triggers                                                 // 1589\n    // quiescence, if we were waiting for a sub to be revived and it dies                                              // 1590\n    // instead.                                                                                                        // 1591\n  },                                                                                                                   // 1592\n  _livedata_result: function (msg) {                                                                                   // 1594\n    // id, result or error. error has error (code), reason, details                                                    // 1595\n    var self = this; // Lets make sure there are no buffered writes before returning result.                           // 1597\n                                                                                                                       //\n    if (!_.isEmpty(self._bufferedWrites)) {                                                                            // 1600\n      self._flushBufferedWrites();                                                                                     // 1601\n    } // find the outstanding request                                                                                  // 1602\n    // should be O(1) in nearly all realistic use cases                                                                // 1605\n                                                                                                                       //\n                                                                                                                       //\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                    // 1606\n      Meteor._debug(\"Received method result but no methods outstanding\");                                              // 1607\n                                                                                                                       //\n      return;                                                                                                          // 1608\n    }                                                                                                                  // 1609\n                                                                                                                       //\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                                 // 1610\n    var m;                                                                                                             // 1611\n                                                                                                                       //\n    for (var i = 0; i < currentMethodBlock.length; i++) {                                                              // 1612\n      m = currentMethodBlock[i];                                                                                       // 1613\n      if (m.methodId === msg.id) break;                                                                                // 1614\n    }                                                                                                                  // 1616\n                                                                                                                       //\n    if (!m) {                                                                                                          // 1618\n      Meteor._debug(\"Can't match method response to original method call\", msg);                                       // 1619\n                                                                                                                       //\n      return;                                                                                                          // 1620\n    } // Remove from current method block. This may leave the block empty, but we                                      // 1621\n    // don't move on to the next block until the callback has been delivered, in                                       // 1624\n    // _outstandingMethodFinished.                                                                                     // 1625\n                                                                                                                       //\n                                                                                                                       //\n    currentMethodBlock.splice(i, 1);                                                                                   // 1626\n                                                                                                                       //\n    if (_.has(msg, 'error')) {                                                                                         // 1628\n      m.receiveResult(new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details));                         // 1629\n    } else {                                                                                                           // 1632\n      // msg.result may be undefined if the method didn't return a                                                     // 1633\n      // value                                                                                                         // 1634\n      m.receiveResult(undefined, msg.result);                                                                          // 1635\n    }                                                                                                                  // 1636\n  },                                                                                                                   // 1637\n  // Called by MethodInvoker after a method's callback is invoked.  If this was                                        // 1639\n  // the last outstanding method in the current block, runs the next block. If                                         // 1640\n  // there are no more methods, consider accepting a hot code push.                                                    // 1641\n  _outstandingMethodFinished: function () {                                                                            // 1642\n    var self = this;                                                                                                   // 1643\n    if (self._anyMethodsAreOutstanding()) return; // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that                                             // 1648\n    // half-finished before disconnect/reconnect.)                                                                     // 1649\n                                                                                                                       //\n    if (!_.isEmpty(self._outstandingMethodBlocks)) {                                                                   // 1650\n      var firstBlock = self._outstandingMethodBlocks.shift();                                                          // 1651\n                                                                                                                       //\n      if (!_.isEmpty(firstBlock.methods)) throw new Error(\"No methods outstanding but nonempty block: \" + JSON.stringify(firstBlock)); // Send the outstanding methods now in the first block.\n                                                                                                                       //\n      if (!_.isEmpty(self._outstandingMethodBlocks)) self._sendOutstandingMethods();                                   // 1657\n    } // Maybe accept a hot code push.                                                                                 // 1659\n                                                                                                                       //\n                                                                                                                       //\n    self._maybeMigrate();                                                                                              // 1662\n  },                                                                                                                   // 1663\n  // Sends messages for all the methods in the first block in                                                          // 1665\n  // _outstandingMethodBlocks.                                                                                         // 1666\n  _sendOutstandingMethods: function () {                                                                               // 1667\n    var self = this;                                                                                                   // 1668\n    if (_.isEmpty(self._outstandingMethodBlocks)) return;                                                              // 1669\n                                                                                                                       //\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                                    // 1671\n      m.sendMessage();                                                                                                 // 1672\n    });                                                                                                                // 1673\n  },                                                                                                                   // 1674\n  _livedata_error: function (msg) {                                                                                    // 1676\n    Meteor._debug(\"Received error from server: \", msg.reason);                                                         // 1677\n                                                                                                                       //\n    if (msg.offendingMessage) Meteor._debug(\"For: \", msg.offendingMessage);                                            // 1678\n  },                                                                                                                   // 1680\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function () {                                                  // 1682\n    var self = this;                                                                                                   // 1683\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                                    // 1684\n    self._outstandingMethodBlocks = [];                                                                                // 1685\n    self.onReconnect && self.onReconnect();                                                                            // 1687\n                                                                                                                       //\n    DDP._reconnectHook.each(function (callback) {                                                                      // 1688\n      callback(self);                                                                                                  // 1689\n      return true;                                                                                                     // 1690\n    });                                                                                                                // 1691\n                                                                                                                       //\n    if (_.isEmpty(oldOutstandingMethodBlocks)) return; // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just                                           // 1697\n    // restore all outstanding methods and run the first block.                                                        // 1698\n                                                                                                                       //\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                    // 1699\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                      // 1700\n                                                                                                                       //\n      self._sendOutstandingMethods();                                                                                  // 1701\n                                                                                                                       //\n      return;                                                                                                          // 1702\n    } // OK, there are blocks on both sides. Special case: merge the last block of                                     // 1703\n    // the reconnect methods with the first block of the original methods, if                                          // 1706\n    // neither of them are \"wait\" blocks.                                                                              // 1707\n                                                                                                                       //\n                                                                                                                       //\n    if (!_.last(self._outstandingMethodBlocks).wait && !oldOutstandingMethodBlocks[0].wait) {                          // 1708\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                     // 1710\n        _.last(self._outstandingMethodBlocks).methods.push(m); // If this \"last block\" is also the first block, send the message.\n                                                                                                                       //\n                                                                                                                       //\n        if (self._outstandingMethodBlocks.length === 1) m.sendMessage();                                               // 1714\n      });                                                                                                              // 1716\n                                                                                                                       //\n      oldOutstandingMethodBlocks.shift();                                                                              // 1718\n    } // Now add the rest of the original blocks on.                                                                   // 1719\n                                                                                                                       //\n                                                                                                                       //\n    _.each(oldOutstandingMethodBlocks, function (block) {                                                              // 1722\n      self._outstandingMethodBlocks.push(block);                                                                       // 1723\n    });                                                                                                                // 1724\n  },                                                                                                                   // 1725\n  // We can accept a hot code push if there are no methods in flight.                                                  // 1727\n  _readyToMigrate: function () {                                                                                       // 1728\n    var self = this;                                                                                                   // 1729\n    return _.isEmpty(self._methodInvokers);                                                                            // 1730\n  },                                                                                                                   // 1731\n  // If we were blocking a migration, see if it's now possible to continue.                                            // 1733\n  // Call whenever the set of outstanding/blocked methods shrinks.                                                     // 1734\n  _maybeMigrate: function () {                                                                                         // 1735\n    var self = this;                                                                                                   // 1736\n                                                                                                                       //\n    if (self._retryMigrate && self._readyToMigrate()) {                                                                // 1737\n      self._retryMigrate();                                                                                            // 1738\n                                                                                                                       //\n      self._retryMigrate = null;                                                                                       // 1739\n    }                                                                                                                  // 1740\n  }                                                                                                                    // 1741\n});                                                                                                                    // 478\n                                                                                                                       //\nLivedataTest.Connection = Connection; // @param url {String} URL to Meteor app,                                        // 1744\n//     e.g.:                                                                                                           // 1747\n//     \"subdomain.meteor.com\",                                                                                         // 1748\n//     \"http://subdomain.meteor.com\",                                                                                  // 1749\n//     \"/\",                                                                                                            // 1750\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                  // 1751\n/**                                                                                                                    // 1753\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere                                                                                                     //\n * @param {String} url The URL of another Meteor application.                                                          //\n */                                                                                                                    //\n                                                                                                                       //\nDDP.connect = function (url, options) {                                                                                // 1758\n  var ret = new Connection(url, options);                                                                              // 1759\n  allConnections.push(ret); // hack. see below.                                                                        // 1760\n                                                                                                                       //\n  return ret;                                                                                                          // 1761\n};                                                                                                                     // 1762\n                                                                                                                       //\nDDP._reconnectHook = new Hook({                                                                                        // 1764\n  bindEnvironment: false                                                                                               // 1764\n}); /**                                                                                                                // 1764\n     * @summary Register a function to call as the first step of                                                       //\n     * reconnecting. This function can call methods which will be executed before                                      //\n     * any other outstanding methods. For example, this can be used to re-establish                                    //\n     * the appropriate authentication context on the connection.                                                       //\n     * @locus Anywhere                                                                                                 //\n     * @param {Function} callback The function to call. It will be called with a                                       //\n     * single argument, the [connection object](#ddp_connect) that is reconnecting.                                    //\n     */                                                                                                                //\n                                                                                                                       //\nDDP.onReconnect = function (callback) {                                                                                // 1775\n  return DDP._reconnectHook.register(callback);                                                                        // 1776\n}; // Hack for `spiderable` package: a way to see if the page is done                                                  // 1777\n// loading all the data it needs.                                                                                      // 1780\n//                                                                                                                     // 1781\n                                                                                                                       //\n                                                                                                                       //\nallConnections = [];                                                                                                   // 1782\n                                                                                                                       //\nDDP._allSubscriptionsReady = function () {                                                                             // 1783\n  return _.all(allConnections, function (conn) {                                                                       // 1784\n    return _.all(conn._subscriptions, function (sub) {                                                                 // 1785\n      return sub.ready;                                                                                                // 1786\n    });                                                                                                                // 1787\n  });                                                                                                                  // 1788\n};                                                                                                                     // 1789\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"namespace.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/namespace.js                                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.export({                                                                                                        // 1\n  DDP: function () {                                                                                                   // 1\n    return DDP;                                                                                                        // 1\n  },                                                                                                                   // 1\n  LivedataTest: function () {                                                                                          // 1\n    return LivedataTest;                                                                                               // 1\n  }                                                                                                                    // 1\n});                                                                                                                    // 1\nvar DDP = {};                                                                                                          // 5\nvar LivedataTest = {};                                                                                                 // 6\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"id_map.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/ddp-client/id_map.js                                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");                                                //\n                                                                                                                       //\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);                                                       //\n                                                                                                                       //\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");                          //\n                                                                                                                       //\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);                                 //\n                                                                                                                       //\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");                                                            //\n                                                                                                                       //\nvar _inherits3 = _interopRequireDefault(_inherits2);                                                                   //\n                                                                                                                       //\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }                      //\n                                                                                                                       //\nmodule.export({                                                                                                        // 1\n  MongoIDMap: function () {                                                                                            // 1\n    return MongoIDMap;                                                                                                 // 1\n  }                                                                                                                    // 1\n});                                                                                                                    // 1\n                                                                                                                       //\nvar MongoIDMap = function (_IdMap) {                                                                                   //\n  (0, _inherits3.default)(MongoIDMap, _IdMap);                                                                         //\n                                                                                                                       //\n  function MongoIDMap() {                                                                                              // 2\n    (0, _classCallCheck3.default)(this, MongoIDMap);                                                                   // 2\n    return (0, _possibleConstructorReturn3.default)(this, _IdMap.call(this, MongoID.idStringify, MongoID.idParse));    // 2\n  }                                                                                                                    // 7\n                                                                                                                       //\n  return MongoIDMap;                                                                                                   //\n}(IdMap);                                                                                                              //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nrequire(\"./node_modules/meteor/ddp-client/stream_client_nodejs.js\");\nrequire(\"./node_modules/meteor/ddp-client/stream_client_common.js\");\nrequire(\"./node_modules/meteor/ddp-client/livedata_common.js\");\nrequire(\"./node_modules/meteor/ddp-client/random_stream.js\");\nrequire(\"./node_modules/meteor/ddp-client/livedata_connection.js\");\nvar exports = require(\"./node_modules/meteor/ddp-client/namespace.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-client'] = exports, {\n  DDP: DDP\n});\n\n})();\n","servePath":"/packages/ddp-client.js","sourceMap":{"version":3,"sources":["packages/ddp-client/stream_client_nodejs.js","packages/ddp-client/stream_client_common.js","packages/ddp-client/livedata_common.js","packages/ddp-client/random_stream.js","packages/ddp-client/livedata_connection.js","packages/ddp-client/namespace.js","packages/ddp-client/id_map.js"],"names":["module1","module","DDP","LivedataTest","watch","require","v","ClientStream","endpoint","options","self","Object","assign","retry","client","headers","npmFayeOptions","_initCommon","_launchConnection","send","data","currentStatus","connected","_changeUrl","url","_onConnect","Error","_forcedToDisconnect","close","_clearConnectionTimer","status","retryCount","statusChanged","_","each","eventCallbacks","reset","callback","_cleanup","maybeError","disconnect","connectionTimer","clearTimeout","_getProxyUrl","targetUrl","proxy","process","env","HTTP_PROXY","http_proxy","match","HTTPS_PROXY","https_proxy","FayeWebSocket","Npm","deflate","toWebsocketUrl","fayeOptions","extensions","extend","proxyUrl","origin","subprotocols","Client","Meteor","setTimeout","_lostConnection","ConnectionError","CONNECT_TIMEOUT","on","bindEnvironment","clientOnIfCurrent","event","description","f","apply","arguments","error","_dontPrintErrors","_debug","message","startsWith","str","starts","length","substring","endsWith","ends","translateUrl","newSchemeBase","subPath","ddpUrlMatch","httpUrlMatch","newScheme","urlAfterDDP","substr","slashPos","indexOf","host","rest","replace","Math","floor","Random","fraction","urlAfterHttp","_relativeToSiteRootUrl","toSockjsUrl","ret","prototype","name","push","connectTimeoutMs","statusListeners","Tracker","Dependency","changed","_retry","Retry","reconnect","_sockjsOptions","_force","ForcedReconnectError","clear","_retryNow","_permanent","_error","reason","_retryLater","_online","timeout","errorType","retryLater","bind","retryTime","Date","getTime","depend","makeErrorType","SUPPORTED_DDP_VERSIONS","DDPCommon","_CurrentMethodInvocation","EnvironmentVariable","_CurrentPublicationInvocation","_CurrentInvocation","randomStream","scope","get","RandomStream","MongoIDMap","isServer","Fiber","Future","Connection","onConnected","onDDPVersionNegotiationFailure","heartbeatInterval","heartbeatTimeout","reloadWithOutstanding","supportedDDPVersions","respondToPings","bufferedWritesInterval","bufferedWritesMaxAge","onReconnect","_stream","_lastSessionId","_versionSuggestion","_version","_stores","_methodHandlers","_nextMethodId","_supportedDDPVersions","_heartbeatInterval","_heartbeatTimeout","_methodInvokers","_outstandingMethodBlocks","_documentsWrittenByStub","_serverDocuments","_afterUpdateCallbacks","_messagesBufferedUntilQuiescence","_methodsBlockingQuiescence","_subsBeingRevived","_resetStores","_updatesForUnknownStores","_retryMigrate","__flushBufferedWrites","_flushBufferedWrites","_bufferedWrites","_bufferedWritesFlushAt","_bufferedWritesFlushHandle","_bufferedWritesInterval","_bufferedWritesMaxAge","_subscriptions","_userId","_userIdDeps","isClient","Package","reload","Reload","_onMigrate","_readyToMigrate","onMessage","raw_msg","msg","parseDDP","e","_heartbeat","messageReceived","server_id","_livedata_connected","contains","version","_send","id","include","_livedata_data","_livedata_nosub","_livedata_result","_livedata_error","onReset","session","support","currentMethodBlock","methods","filter","methodInvoker","sentMessage","noRetry","receiveResult","isEmpty","shift","m","_callOnReconnectAndSendAppropriateOutstandingMethods","sub","params","onDisconnect","stop","MethodInvoker","methodId","_callback","_connection","connection","_message","_onResultReceived","onResultReceived","_wait","wait","_methodResult","_dataVisible","sendMessage","gotResult","_maybeInvokeCallback","_outstandingMethodFinished","err","result","dataVisible","registerStore","wrappedStore","store","method","undefined","queued","beginUpdate","update","endUpdate","subscribe","Array","slice","call","callbacks","lastParam","isFunction","onReady","pop","any","onError","onStop","existing","find","inactive","EJSON","equals","ready","readyCallback","errorCallback","stopCallback","clone","readyDeps","remove","handle","has","record","subscriptionId","active","onInvalidate","c","afterFlush","_subscribeAndWait","args","onLateError","concat","func","enclosing","alreadyInSimulation","isSimulation","randomSeed","randomSeedGenerator","makeRpcSeed","stub","setUserId","userId","invocation","MethodInvocation","_saveOriginals","stubReturnValue","withValue","_noYieldsAllowed","exception","_retrieveAndStoreOriginals","throwStubExceptions","expected","stack","future","resolver","last","returnStubValue","_waitingForQuiescence","s","saveOriginals","docsWritten","collection","originals","retrieveOriginals","forEach","doc","serverDoc","setDefault","writtenByStubs","document","flushCallbacks","_unsubscribeAll","obj","stringifyDDP","_anyMethodsAreOutstanding","pluck","Heartbeat","onTimeout","sendPing","start","reconnectedToPreviousSession","invoker","_runAfterUpdateCallbacks","_processOneDataMessage","updates","subs","subId","bufferedMsg","standardWrite","valueOf","writes","_performWrites","storeName","updateMessages","updateMessage","_pushUpdate","_getServerDoc","serverDocsForCollection","_process_added","MongoID","idParse","isExisting","fields","_id","currentDoc","getDoc","_process_changed","DiffSequence","applyChanges","_process_removed","_process_updated","written","JSON","stringify","idStringify","callbackInvoker","_runWhenAllServerDocsAreFlushed","_process_ready","subRecord","runFAfterUpdates","unflushedServerDocCount","onServerDocFlush","collectionDocs","writtenByStubForAMethodWithSentMessage","dummy","meteorErrorFromMsg","msgArg","details","_process_nosub","i","splice","firstBlock","_sendOutstandingMethods","_maybeMigrate","offendingMessage","oldOutstandingMethodBlocks","_reconnectHook","block","connect","allConnections","Hook","register","_allSubscriptionsReady","all","conn","export","IdMap"],"mappings":"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","file":"/packages/ddp-client.js","sourcesContent":["import { DDP, LivedataTest } from \"./namespace.js\";\n\n// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = class ClientStream {\n  constructor(endpoint, options) {\n    const self = this;\n    options = options || {};\n\n    self.options = Object.assign({\n      retry: true\n    }, options);\n\n    self.client = null;  // created in _launchConnection\n    self.endpoint = endpoint;\n\n    self.headers = self.options.headers || {};\n    self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n    self._initCommon(self.options);\n\n    //// Kickoff!\n    self._launchConnection();\n  }\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send(data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.client.send(data);\n    }\n  }\n\n  // Changes where this connection points\n  _changeUrl(url) {\n    var self = this;\n    self.endpoint = url;\n  }\n\n  _onConnect(client) {\n    var self = this;\n\n    if (client !== self.client) {\n      // This connection is not from the last call to _launchConnection.\n      // But _launchConnection calls _cleanup which closes previous connections.\n      // It's our belief that this stifles future 'open' events, but maybe\n      // we are wrong?\n      throw new Error(\"Got open from inactive client \" + !!self.client);\n    }\n\n    if (self._forcedToDisconnect) {\n      // We were asked to disconnect between trying to open the connection and\n      // actually opening it. Let's just pretend this never happened.\n      self.client.close();\n      self.client = null;\n      return;\n    }\n\n    if (self.currentStatus.connected) {\n      // We already have a connection. It must have been the case that we\n      // started two parallel connection attempts (because we wanted to\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\n      // connection attempt.) But this shouldn't happen (similarly to the client\n      // !== self.client check above).\n      throw new Error(\"Two parallel connections?\");\n    }\n\n    self._clearConnectionTimer();\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n  }\n\n  _cleanup(maybeError) {\n    var self = this;\n\n    self._clearConnectionTimer();\n    if (self.client) {\n      var client = self.client;\n      self.client = null;\n      client.close();\n\n      _.each(self.eventCallbacks.disconnect, function (callback) {\n        callback(maybeError);\n      });\n    }\n  }\n\n  _clearConnectionTimer() {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n  }\n\n  _getProxyUrl(targetUrl) {\n    var self = this;\n    // Similar to code in tools/http-helpers.js.\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\n    // if we're going to a secure url, try the https_proxy env variable first.\n    if (targetUrl.match(/^wss:/)) {\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n    }\n    return proxy;\n  }\n\n  _launchConnection() {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    // Since server-to-server DDP is still an experimental feature, we only\n    // require the module if we actually create a server-to-server\n    // connection.\n    var FayeWebSocket = Npm.require('faye-websocket');\n    var deflate = Npm.require('permessage-deflate');\n\n    var targetUrl = toWebsocketUrl(self.endpoint);\n    var fayeOptions = {\n      headers: self.headers,\n      extensions: [deflate]\n    };\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n    var proxyUrl = self._getProxyUrl(targetUrl);\n    if (proxyUrl) {\n      fayeOptions.proxy = { origin: proxyUrl };\n    };\n\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\n    // used to use as a client would fail the handshake if we ask for a\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\n    var subprotocols = [];\n\n    var client = self.client = new FayeWebSocket.Client(\n      targetUrl, subprotocols, fayeOptions);\n\n    self._clearConnectionTimer();\n    self.connectionTimer = Meteor.setTimeout(\n      function () {\n        self._lostConnection(\n          new DDP.ConnectionError(\"DDP connection timed out\"));\n      },\n      self.CONNECT_TIMEOUT);\n\n    self.client.on('open', Meteor.bindEnvironment(function () {\n      return self._onConnect(client);\n    }, \"stream connect callback\"));\n\n    var clientOnIfCurrent = function (event, description, f) {\n      self.client.on(event, Meteor.bindEnvironment(function () {\n        // Ignore events from any connection we've already cleaned up.\n        if (client !== self.client)\n          return;\n        f.apply(this, arguments);\n      }, description));\n    };\n\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\n      if (!self.options._dontPrintErrors)\n        Meteor._debug(\"stream error\", error.message);\n\n      // Faye's 'error' object is not a JS error (and among other things,\n      // doesn't stringify well). Convert it to one.\n      self._lostConnection(new DDP.ConnectionError(error.message));\n    });\n\n\n    clientOnIfCurrent('close', 'stream close callback', function () {\n      self._lostConnection();\n    });\n\n\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\n      // Ignore binary frames, where message.data is a Buffer\n      if (typeof message.data !== \"string\")\n        return;\n\n      _.each(self.eventCallbacks.message, function (callback) {\n        callback(message.data);\n      });\n    });\n  }\n};\n","import { DDP, LivedataTest } from \"./namespace.js\";\n\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\nvar endsWith = function(str, ends) {\n  return str.length >= ends.length &&\n    str.substring(str.length - ends.length) === ends;\n};\n\n// @param url {String} URL to Meteor app, eg:\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\n// for scheme \"http\" and subPath \"sockjs\"\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"\nvar translateUrl =  function(url, newSchemeBase, subPath) {\n  if (! newSchemeBase) {\n    newSchemeBase = \"http\";\n  }\n\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);\n  var newScheme;\n  if (ddpUrlMatch) {\n    // Remove scheme and split off the host.\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";\n    var slashPos = urlAfterDDP.indexOf('/');\n    var host =\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\n\n    // In the host (ONLY!), change '*' characters into random digits. This\n    // allows different stream connections to connect to different hostnames\n    // and avoid browser per-hostname connection limits.\n    host = host.replace(/\\*/g, function () {\n      return Math.floor(Random.fraction()*10);\n    });\n\n    return newScheme + '://' + host + rest;\n  } else if (httpUrlMatch) {\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\n    url = newScheme + \"://\" + urlAfterHttp;\n  }\n\n  // Prefix FQDNs but not relative URLs\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {\n    url = newSchemeBase + \"://\" + url;\n  }\n\n  // XXX This is not what we should be doing: if I have a site\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\n  // to connect to \"/foo/bar\").\n  //\n  // We should make this properly honor absolute paths rather than\n  // forcing the path to be relative to the site root. Simultaneously,\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\n  url = Meteor._relativeToSiteRootUrl(url);\n\n  if (endsWith(url, \"/\"))\n    return url + subPath;\n  else\n    return url + \"/\" + subPath;\n};\n\ntoSockjsUrl = function (url) {\n  return translateUrl(url, \"http\", \"sockjs\");\n};\n\ntoWebsocketUrl = function (url) {\n  var ret = translateUrl(url, \"ws\", \"websocket\");\n  return ret;\n};\n\nLivedataTest.toSockjsUrl = toSockjsUrl;\n\n \n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // Register for callbacks.\n  on: function (name, callback) {\n    var self = this;\n\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\n      throw new Error(\"unknown event type: \" + name);\n\n    if (!self.eventCallbacks[name])\n      self.eventCallbacks[name] = [];\n    self.eventCallbacks[name].push(callback);\n  },\n\n\n  _initCommon: function (options) {\n    var self = this;\n    options = options || {};\n\n    //// Constants\n\n    // how long to wait until we declare the connection attempt\n    // failed.\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\n\n    self.eventCallbacks = {}; // name -> [callback]\n\n    self._forcedToDisconnect = false;\n\n    //// Reactive status\n    self.currentStatus = {\n      status: \"connecting\",\n      connected: false,\n      retryCount: 0\n    };\n\n\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;\n    self.statusChanged = function () {\n      if (self.statusListeners)\n        self.statusListeners.changed();\n    };\n\n    //// Retry logic\n    self._retry = new Retry;\n    self.connectionTimer = null;\n\n  },\n\n  // Trigger a reconnect.\n  reconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    if (options.url) {\n      self._changeUrl(options.url);\n    }\n\n    if (options._sockjsOptions) {\n      self.options._sockjsOptions = options._sockjsOptions;\n    }\n\n    if (self.currentStatus.connected) {\n      if (options._force || options.url) {\n        // force reconnect.\n        self._lostConnection(new DDP.ForcedReconnectError);\n      } // else, noop.\n      return;\n    }\n\n    // if we're mid-connection, stop it.\n    if (self.currentStatus.status === \"connecting\") {\n      // Pretend it's a clean close.\n      self._lostConnection();\n    }\n\n    self._retry.clear();\n    self.currentStatus.retryCount -= 1; // don't count manual retries\n    self._retryNow();\n  },\n\n  disconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    // Failed is permanent. If we're failed, don't let people go back\n    // online by calling 'disconnect' then 'reconnect'.\n    if (self._forcedToDisconnect)\n      return;\n\n    // If _permanent is set, permanently disconnect a stream. Once a stream\n    // is forced to disconnect, it can never reconnect. This is for\n    // error cases such as ddp version mismatch, where trying again\n    // won't fix the problem.\n    if (options._permanent) {\n      self._forcedToDisconnect = true;\n    }\n\n    self._cleanup();\n    self._retry.clear();\n\n    self.currentStatus = {\n      status: (options._permanent ? \"failed\" : \"offline\"),\n      connected: false,\n      retryCount: 0\n    };\n\n    if (options._permanent && options._error)\n      self.currentStatus.reason = options._error;\n\n    self.statusChanged();\n  },\n\n  // maybeError is set unless it's a clean protocol-level close.\n  _lostConnection: function (maybeError) {\n    var self = this;\n\n    self._cleanup(maybeError);\n    self._retryLater(maybeError); // sets status. no need to do it here.\n  },\n\n  // fired when we detect that we've gone online. try to reconnect\n  // immediately.\n  _online: function () {\n    // if we've requested to be offline by disconnecting, don't reconnect.\n    if (this.currentStatus.status != \"offline\")\n      this.reconnect();\n  },\n\n  _retryLater: function (maybeError) {\n    var self = this;\n\n    var timeout = 0;\n    if (self.options.retry ||\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {\n      timeout = self._retry.retryLater(\n        self.currentStatus.retryCount,\n        _.bind(self._retryNow, self)\n      );\n      self.currentStatus.status = \"waiting\";\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;\n    } else {\n      self.currentStatus.status = \"failed\";\n      delete self.currentStatus.retryTime;\n    }\n\n    self.currentStatus.connected = false;\n    self.statusChanged();\n  },\n\n  _retryNow: function () {\n    var self = this;\n\n    if (self._forcedToDisconnect)\n      return;\n\n    self.currentStatus.retryCount += 1;\n    self.currentStatus.status = \"connecting\";\n    self.currentStatus.connected = false;\n    delete self.currentStatus.retryTime;\n    self.statusChanged();\n\n    self._launchConnection();\n  },\n\n\n  // Get current status. Reactive.\n  status: function () {\n    var self = this;\n    if (self.statusListeners)\n      self.statusListeners.depend();\n    return self.currentStatus;\n  }\n});\n\nDDP.ConnectionError = Meteor.makeErrorType(\n  \"DDP.ConnectionError\", function (message) {\n    var self = this;\n    self.message = message;\n});\n\nDDP.ForcedReconnectError = Meteor.makeErrorType(\n  \"DDP.ForcedReconnectError\", function () {});\n","import { DDP, LivedataTest } from \"./namespace.js\";\n\nLivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;\n\n// This is private but it's used in a few places. accounts-base uses\n// it to get the current user. Meteor.setTimeout and friends clear\n// it. We can probably find a better way to factor this.\nDDP._CurrentMethodInvocation = new Meteor.EnvironmentVariable;\nDDP._CurrentPublicationInvocation = new Meteor.EnvironmentVariable;\n\n// XXX: Keep DDP._CurrentInvocation for backwards-compatibility.\nDDP._CurrentInvocation = DDP._CurrentMethodInvocation;\n","import { DDP } from \"./namespace.js\";\n\n// Returns the named sequence of pseudo-random values.\n// The scope will be DDP._CurrentMethodInvocation.get(), so the stream will produce\n// consistent values for method calls on the client and server.\nDDP.randomStream = function (name) {\n  var scope = DDP._CurrentMethodInvocation.get();\n  return DDPCommon.RandomStream.get(scope, name);\n};\n\n\n","import { DDP, LivedataTest } from \"./namespace.js\";\nimport { MongoIDMap } from \"./id_map.js\";\n\nif (Meteor.isServer) {\n  var Fiber = Npm.require('fibers');\n  var Future = Npm.require('fibers/future');\n}\n\n// @param url {String|Object} URL to Meteor app,\n//   or an object as a test hook (see code)\n// Options:\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n//   headers: extra headers to send on the websockets connection, for\n//     server-to-server DDP only\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n//\n// XXX There should be a way to destroy a DDP connection, causing all\n// outstanding method calls to fail.\n//\n// XXX Our current way of handling failure and reconnection is great\n// for an app (where we want to tolerate being disconnected as an\n// expect state, and keep trying forever to reconnect) but cumbersome\n// for something like a command line tool that wants to make a\n// connection, call a method, and print an error if connection\n// fails. We should have better usability in the latter case (while\n// still transparently reconnecting if it's just a transient failure\n// or the server migrating us).\nvar Connection = function (url, options) {\n  var self = this;\n  options = _.extend({\n    onConnected: function () {},\n    onDDPVersionNegotiationFailure: function (description) {\n      Meteor._debug(description);\n    },\n    heartbeatInterval: 17500,\n    heartbeatTimeout: 15000,\n    npmFayeOptions: {},\n    // These options are only for testing.\n    reloadWithOutstanding: false,\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n    retry: true,\n    respondToPings: true,\n    // When updates are coming within this ms interval, batch them together.\n    bufferedWritesInterval: 5,\n    // Flush buffers immediately if writes are happening continuously for more than this many ms.\n    bufferedWritesMaxAge: 500\n  }, options);\n\n  // If set, called when we reconnect, queuing method calls _before_ the\n  // existing outstanding ones.\n  // NOTE: This feature has been preserved for backwards compatibility. The\n  // preferred method of setting a callback on reconnect is to use\n  // DDP.onReconnect.\n  self.onReconnect = null;\n\n  // as a test hook, allow passing a stream instead of a url.\n  if (typeof url === \"object\") {\n    self._stream = url;\n  } else {\n    self._stream = new LivedataTest.ClientStream(url, {\n      retry: options.retry,\n      headers: options.headers,\n      _sockjsOptions: options._sockjsOptions,\n      // Used to keep some tests quiet, or for other cases in which\n      // the right thing to do with connection errors is to silently\n      // fail (e.g. sending package usage stats). At some point we\n      // should have a real API for handling client-stream-level\n      // errors.\n      _dontPrintErrors: options._dontPrintErrors,\n      connectTimeoutMs: options.connectTimeoutMs,\n      npmFayeOptions: options.npmFayeOptions\n    });\n  }\n\n  self._lastSessionId = null;\n  self._versionSuggestion = null;  // The last proposed DDP version.\n  self._version = null;   // The DDP version agreed on by client and server.\n  self._stores = {}; // name -> object with methods\n  self._methodHandlers = {}; // name -> func\n  self._nextMethodId = 1;\n  self._supportedDDPVersions = options.supportedDDPVersions;\n\n  self._heartbeatInterval = options.heartbeatInterval;\n  self._heartbeatTimeout = options.heartbeatTimeout;\n\n  // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all\n  // of their writes to be written to the local cache). Map from method ID to\n  // MethodInvoker object.\n  self._methodInvokers = {};\n\n  // Tracks methods which the user has called but whose result messages have not\n  // arrived yet.\n  //\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n  // represents a set of methods that can run at the same time. The first block\n  // represents the methods which are currently in flight; subsequent blocks\n  // must wait for previous blocks to be fully finished before they can be sent\n  // to the server.\n  //\n  // Each block is an object with the following fields:\n  // - methods: a list of MethodInvoker objects\n  // - wait: a boolean; if true, this block had a single method invoked with\n  //         the \"wait\" option\n  //\n  // There will never be adjacent blocks with wait=false, because the only thing\n  // that makes methods need to be serialized is a wait method.\n  //\n  // Methods are removed from the first block when their \"result\" is\n  // received. The entire first block is only removed when all of the in-flight\n  // methods have received their results (so the \"methods\" list is empty) *AND*\n  // all of the data written by those methods are visible in the local cache. So\n  // it is possible for the first block's methods list to be empty, if we are\n  // still waiting for some objects to quiesce.\n  //\n  // Example:\n  //  _outstandingMethodBlocks = [\n  //    {wait: false, methods: []},\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n  //                            <MethodInvoker for 'bar'>]}]\n  // This means that there were some methods which were sent to the server and\n  // which have returned their results, but some of the data written by\n  // the methods may not be visible in the local cache. Once all that data is\n  // visible, we will send a 'login' method. Once the login method has returned\n  // and all the data is visible (including re-running subs if userId changes),\n  // we will send the 'foo' and 'bar' methods in parallel.\n  self._outstandingMethodBlocks = [];\n\n  // method ID -> array of objects with keys 'collection' and 'id', listing\n  // documents written by a given method's stub. keys are associated with\n  // methods whose stub wrote at least one document, and whose data-done message\n  // has not yet been received.\n  self._documentsWrittenByStub = {};\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:\n  // - \"document\": the version of the document according the\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n  //   received from the server)\n  //   It is undefined if we think the document does not exist\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n  //   whose \"data done\" messages have not yet been processed\n  self._serverDocuments = {};\n\n  // Array of callbacks to be called after the next update of the local\n  // cache. Used for:\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n  //    the relevant data is flushed.\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n  //    quiescence. Specifically, methods whose result was received over the old\n  //    connection (so we don't re-send it) but whose data had not been made\n  //    visible.\n  self._afterUpdateCallbacks = [];\n\n  // In two contexts, we buffer all incoming data messages and then process them\n  // all at once in a single update:\n  //   - During reconnect, we buffer all data messages until all subs that had\n  //     been ready before reconnect are ready again, and all methods that are\n  //     active have returned their \"data done message\"; then\n  //   - During the execution of a \"wait\" method, we buffer all data messages\n  //     until the wait method gets its \"data done\" message. (If the wait method\n  //     occurs during reconnect, it doesn't get any special handling.)\n  // all data messages are processed in one update.\n  //\n  // The following fields are used for this \"quiescence\" process.\n\n  // This buffers the messages that aren't being processed yet.\n  self._messagesBufferedUntilQuiescence = [];\n  // Map from method ID -> true. Methods are removed from this when their\n  // \"data done\" message is received, and we will not quiesce until it is\n  // empty.\n  self._methodsBlockingQuiescence = {};\n  // map from sub ID -> true for subs that were ready (ie, called the sub\n  // ready callback) before reconnect but haven't become ready again yet\n  self._subsBeingRevived = {}; // map from sub._id -> true\n  // if true, the next data update should reset all stores. (set during\n  // reconnect.)\n  self._resetStores = false;\n\n  // name -> array of updates for (yet to be created) collections\n  self._updatesForUnknownStores = {};\n  // if we're blocking a migration, the retry func\n  self._retryMigrate = null;\n\n  self.__flushBufferedWrites = Meteor.bindEnvironment(\n    self._flushBufferedWrites, \"flushing DDP buffered writes\", self);\n  // Collection name -> array of messages.\n  self._bufferedWrites = {};\n  // When current buffer of updates must be flushed at, in ms timestamp.\n  self._bufferedWritesFlushAt = null;\n  // Timeout handle for the next processing of all pending writes\n  self._bufferedWritesFlushHandle = null;\n\n  self._bufferedWritesInterval = options.bufferedWritesInterval;\n  self._bufferedWritesMaxAge = options.bufferedWritesMaxAge;\n\n  // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id\n  //   - name\n  //   - params\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\n  //   - ready (has the 'ready' message been received?)\n  //   - readyCallback (an optional callback to call when ready)\n  //   - errorCallback (an optional callback to call if the sub terminates with\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\n  //   - stopCallback (an optional callback to call when the sub terminates\n  //     for any reason, with an error argument if an error triggered the stop)\n  self._subscriptions = {};\n\n  // Reactive userId.\n  self._userId = null;\n  self._userIdDeps = new Tracker.Dependency;\n\n  // Block auto-reload while we're waiting for method responses.\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n    Package.reload.Reload._onMigrate(function (retry) {\n      if (!self._readyToMigrate()) {\n        if (self._retryMigrate)\n          throw new Error(\"Two migrations in progress?\");\n        self._retryMigrate = retry;\n        return false;\n      } else {\n        return [true];\n      }\n    });\n  }\n\n  var onMessage = function (raw_msg) {\n    try {\n      var msg = DDPCommon.parseDDP(raw_msg);\n    } catch (e) {\n      Meteor._debug(\"Exception while parsing DDP\", e);\n      return;\n    }\n\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the server is still alive.\n    if (self._heartbeat) {\n      self._heartbeat.messageReceived();\n    }\n\n    if (msg === null || !msg.msg) {\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n      // compat.  Remove this 'if' once the server stops sending welcome\n      // messages (stream_server.js).\n      if (! (msg && msg.server_id))\n        Meteor._debug(\"discarding invalid livedata message\", msg);\n      return;\n    }\n\n    if (msg.msg === 'connected') {\n      self._version = self._versionSuggestion;\n      self._livedata_connected(msg);\n      options.onConnected();\n    }\n    else if (msg.msg === 'failed') {\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\n        self._versionSuggestion = msg.version;\n        self._stream.reconnect({_force: true});\n      } else {\n        var description =\n              \"DDP version negotiation failed; server requested version \" + msg.version;\n        self._stream.disconnect({_permanent: true, _error: description});\n        options.onDDPVersionNegotiationFailure(description);\n      }\n    }\n    else if (msg.msg === 'ping' && options.respondToPings) {\n      self._send({msg: \"pong\", id: msg.id});\n    }\n    else if (msg.msg === 'pong') {\n      // noop, as we assume everything's a pong\n    }\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\n      self._livedata_data(msg);\n    else if (msg.msg === 'nosub')\n      self._livedata_nosub(msg);\n    else if (msg.msg === 'result')\n      self._livedata_result(msg);\n    else if (msg.msg === 'error')\n      self._livedata_error(msg);\n    else\n      Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };\n\n  var onReset = function () {\n    // Send a connect message at the beginning of the stream.\n    // NOTE: reset is called even on the first connection, so this is\n    // the only place we send this message.\n    var msg = {msg: 'connect'};\n    if (self._lastSessionId)\n      msg.session = self._lastSessionId;\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n    self._versionSuggestion = msg.version;\n    msg.support = self._supportedDDPVersions;\n    self._send(msg);\n\n    // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n    // current block is pretty important to making sure that quiescence is properly calculated, as\n    // well as possibly moving on to another useful block.\n\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n    // we are connecting for the first time.\n    if (self._outstandingMethodBlocks.length > 0) {\n      // If there is an outstanding method block, we only care about the first one as that is the\n      // one that could have already sent messages with no response, that are not allowed to retry.\n      const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n      self._outstandingMethodBlocks[0].methods = currentMethodBlock.filter((methodInvoker) => {\n\n        // Methods with 'noRetry' option set are not allowed to re-send after\n        // recovering dropped connection.\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n          // Make sure that the method is told that it failed.\n          methodInvoker.receiveResult(new Meteor.Error('invocation-failed',\n            'Method invocation might have failed due to dropped connection. ' +\n            'Failing because `noRetry` option was passed to Meteor.apply.'));\n        }\n\n        // Only keep a method if it wasn't sent or it's allowed to retry.\n        // This may leave the block empty, but we don't move on to the next\n        // block until the callback has been delivered, in _outstandingMethodFinished.\n        return !(methodInvoker.sentMessage && methodInvoker.noRetry);\n      });\n    }\n\n    // Now, to minimize setup latency, go ahead and blast out all of\n    // our pending methods ands subscriptions before we've even taken\n    // the necessary RTT to know if we successfully reconnected. (1)\n    // They're supposed to be idempotent, and where they are not,\n    // they can block retry in apply; (2) even if we did reconnect,\n    // we're not sure what messages might have gotten lost\n    // (in either direction) since we were disconnected (TCP being\n    // sloppy about that.)\n\n    // If the current block of methods all got their results (but didn't all get\n    // their data visible), discard the empty block now.\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n      self._outstandingMethodBlocks.shift();\n    }\n\n    // Mark all messages as unsent, they have not yet been sent on this\n    // connection.\n    _.each(self._methodInvokers, function (m) {\n      m.sentMessage = false;\n    });\n\n    // If an `onReconnect` handler is set, call it first. Go through\n    // some hoops to ensure that methods that are called from within\n    // `onReconnect` get executed _before_ ones that were originally\n    // outstanding (since `onReconnect` is used to re-establish auth\n    // certificates)\n    self._callOnReconnectAndSendAppropriateOutstandingMethods();\n\n    // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.\n    _.each(self._subscriptions, function (sub, id) {\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: sub.name,\n        params: sub.params\n      });\n    });\n  };\n\n  var onDisconnect = function () {\n    if (self._heartbeat) {\n      self._heartbeat.stop();\n      self._heartbeat = null;\n    }\n  };\n\n  if (Meteor.isServer) {\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n  } else {\n    self._stream.on('message', onMessage);\n    self._stream.on('reset', onReset);\n    self._stream.on('disconnect', onDisconnect);\n  }\n};\n\n// A MethodInvoker manages sending a method to the server and calling the user's\n// callbacks. On construction, it registers itself in the connection's\n// _methodInvokers map; it removes itself once the method is fully finished and\n// the callback is invoked. This occurs when it has both received a result,\n// and the data written by it is fully visible.\nvar MethodInvoker = function (options) {\n  var self = this;\n\n  // Public (within this file) fields.\n  self.methodId = options.methodId;\n  self.sentMessage = false;\n\n  self._callback = options.callback;\n  self._connection = options.connection;\n  self._message = options.message;\n  self._onResultReceived = options.onResultReceived || function () {};\n  self._wait = options.wait;\n  self.noRetry = options.noRetry;\n  self._methodResult = null;\n  self._dataVisible = false;\n\n  // Register with the connection.\n  self._connection._methodInvokers[self.methodId] = self;\n};\n_.extend(MethodInvoker.prototype, {\n  // Sends the method message to the server. May be called additional times if\n  // we lose the connection and reconnect before receiving a result.\n  sendMessage: function () {\n    var self = this;\n    // This function is called before sending a method (including resending on\n    // reconnect). We should only (re)send methods where we don't already have a\n    // result!\n    if (self.gotResult())\n      throw new Error(\"sendingMethod is called on method with result\");\n\n\n    // If we're re-sending it, it doesn't matter if data was written the first\n    // time.\n    self._dataVisible = false;\n    self.sentMessage = true;\n\n    // If this is a wait method, make all data messages be buffered until it is\n    // done.\n    if (self._wait)\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\n\n    // Actually send the message.\n    self._connection._send(self._message);\n  },\n  // Invoke the callback, if we have both a result and know that all data has\n  // been written to the local cache.\n  _maybeInvokeCallback: function () {\n    var self = this;\n    if (self._methodResult && self._dataVisible) {\n      // Call the callback. (This won't throw: the callback was wrapped with\n      // bindEnvironment.)\n      self._callback(self._methodResult[0], self._methodResult[1]);\n\n      // Forget about this method.\n      delete self._connection._methodInvokers[self.methodId];\n\n      // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.\n      self._connection._outstandingMethodFinished();\n    }\n  },\n  // Call with the result of the method from the server. Only may be called\n  // once; once it is called, you should not call sendMessage again.\n  // If the user provided an onResultReceived callback, call it immediately.\n  // Then invoke the main callback if data is also visible.\n  receiveResult: function (err, result) {\n    var self = this;\n    if (self.gotResult())\n      throw new Error(\"Methods should only receive results once\");\n    self._methodResult = [err, result];\n    self._onResultReceived(err, result);\n    self._maybeInvokeCallback();\n  },\n  // Call this when all data written by the method is visible. This means that\n  // the method has returns its \"data is done\" message *AND* all server\n  // documents that are buffered at that time have been written to the local\n  // cache. Invokes the main callback if the result has been received.\n  dataVisible: function () {\n    var self = this;\n    self._dataVisible = true;\n    self._maybeInvokeCallback();\n  },\n  // True if receiveResult has been called.\n  gotResult: function () {\n    var self = this;\n    return !!self._methodResult;\n  }\n});\n\n_.extend(Connection.prototype, {\n  // 'name' is the name of the data on the wire that should go in the\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n  registerStore: function (name, wrappedStore) {\n    var self = this;\n\n    if (name in self._stores)\n      return false;\n\n    // Wrap the input object in an object which makes any store method not\n    // implemented by 'store' into a no-op.\n    var store = {};\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\n            'retrieveOriginals', 'getDoc',\n\t\t\t'_getCollection'], function (method) {\n              store[method] = function () {\n                return (wrappedStore[method]\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\n                        : undefined);\n              };\n            });\n\n    self._stores[name] = store;\n\n    var queued = self._updatesForUnknownStores[name];\n    if (queued) {\n      store.beginUpdate(queued.length, false);\n      _.each(queued, function (msg) {\n        store.update(msg);\n      });\n      store.endUpdate();\n      delete self._updatesForUnknownStores[name];\n    }\n\n    return true;\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Subscribe to a record set.  Returns a handle that provides\n   * `stop()` and `ready()` methods.\n   * @locus Client\n   * @param {String} name Name of the subscription.  Matches the name of the\n   * server's `publish()` call.\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n   * function on server.\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n   * and `onReady` callbacks. If there is an error, it is passed as an\n   * argument to `onStop`. If a function is passed instead of an object, it\n   * is interpreted as an `onReady` callback.\n   */\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\n    var self = this;\n\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n      if (_.isFunction(lastParam)) {\n        callbacks.onReady = params.pop();\n      } else if (lastParam &&\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n        // onStop with an error callback instead.\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\n          _.isFunction)) {\n        callbacks = params.pop();\n      }\n    }\n\n    // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n    var existing = _.find(self._subscriptions, function (sub) {\n      return sub.inactive && sub.name === name &&\n        EJSON.equals(sub.params, params);\n    });\n\n    var id;\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false; // reactivate\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        // If the sub is already ready, run the ready callback right away.\n        // It seems that users would expect an onReady callback inside an\n        // autorun to trigger once the the sub first becomes ready and also\n        // when re-subs happens.\n        if (existing.ready) {\n          callbacks.onReady();\n        } else {\n          existing.readyCallback = callbacks.onReady;\n        }\n      }\n\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n      // onStop with an optional error argument\n      if (callbacks.onError) {\n        // Replace existing callback if any, so that errors aren't\n        // double-reported.\n        existing.errorCallback = callbacks.onError;\n      }\n\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n    } else {\n      // New sub! Generate an id, save it locally, and send message.\n      id = Random.id();\n      self._subscriptions[id] = {\n        id: id,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Tracker.Dependency,\n        readyCallback: callbacks.onReady,\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        errorCallback: callbacks.onError,\n        stopCallback: callbacks.onStop,\n        connection: self,\n        remove: function() {\n          delete this.connection._subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n        },\n        stop: function() {\n          this.connection._send({msg: 'unsub', id: id});\n          this.remove();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n      self._send({msg: 'sub', id: id, name: name, params: params});\n    }\n\n    // return a handle to the application.\n    var handle = {\n      stop: function () {\n        if (!_.has(self._subscriptions, id))\n          return;\n\n        self._subscriptions[id].stop();\n      },\n      ready: function () {\n        // return false if we've unsubscribed.\n        if (!_.has(self._subscriptions, id))\n          return false;\n        var record = self._subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Tracker.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Tracker.onInvalidate(function (c) {\n        if (_.has(self._subscriptions, id))\n          self._subscriptions[id].inactive = true;\n\n        Tracker.afterFlush(function () {\n          if (_.has(self._subscriptions, id) &&\n              self._subscriptions[id].inactive)\n            handle.stop();\n        });\n      });\n    }\n\n    return handle;\n  },\n\n  // options:\n  // - onLateError {Function(error)} called if an error was received after the ready event.\n  //     (errors received before ready cause an error to be thrown)\n  _subscribeAndWait: function (name, args, options) {\n    var self = this;\n    var f = new Future();\n    var ready = false;\n    var handle;\n    args = args || [];\n    args.push({\n      onReady: function () {\n        ready = true;\n        f['return']();\n      },\n      onError: function (e) {\n        if (!ready)\n          f['throw'](e);\n        else\n          options && options.onLateError && options.onLateError(e);\n      }\n    });\n\n    handle = self.subscribe.apply(self, [name].concat(args));\n    f.wait();\n    return handle;\n  },\n\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self._methodHandlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self._methodHandlers[name] = func;\n    });\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invokes a method passing any number of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */\n  call: function (name /* .. [arguments] .. callback */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  //   wait: Boolean - Should we wait to call this until all current methods\n  //                   are fully finished, and block subsequent method calls\n  //                   until this method is fully finished?\n  //                   (does not affect methods called from within this method)\n  //   onResultReceived: Function - a callback to call as soon as the method\n  //                                result is received. the data written by\n  //                                the method may not yet be in the cache!\n  //   returnStubValue: Boolean - If true then in cases where we would have\n  //                              otherwise discarded the stub's return value\n  //                              and returned undefined, instead we go ahead\n  //                              and return it.  Specifically, this is any\n  //                              time other than when (a) we are already\n  //                              inside a stub or (b) we are in Node and no\n  //                              callback was provided.  Currently we require\n  //                              this flag to be explicitly passed to reduce\n  //                              the likelihood that stub return values will\n  //                              be confused with server return values; we\n  //                              may improve this in future.\n  // @param callback {Optional Function}\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invoke a method passing an array of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable[]} args Method arguments\n   * @param {Object} [options]\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Boolean} options.throwStubExceptions (Client only) If true, exceptions thrown by method stubs will be thrown instead of logged, and the method will not be invoked on the server.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n   */\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback) {\n      // XXX would it be better form to do the binding in stream.on,\n      // or caller, instead of here?\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n    }\n\n    // Keep our args safe from mutation (eg if we don't send the message for a\n    // while because of a wait method).\n    args = EJSON.clone(args);\n\n    // Lazily allocate method ID once we know that it'll be needed.\n    var methodId = (function () {\n      var id;\n      return function () {\n        if (id === undefined)\n          id = '' + (self._nextMethodId++);\n        return id;\n      };\n    })();\n\n    var enclosing = DDP._CurrentMethodInvocation.get();\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\n\n    // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client\n    // and the server; if the client doesn't generate any 'random' values\n    // then we don't expect the server to generate any either.\n    // Less commonly, the server may perform different actions from the client,\n    // and may in fact generate values where the client did not, but we don't\n    // have any client-side values to match, so even here we may as well just\n    // use a random seed on the server.  In that case, we don't pass the\n    // randomSeed to save bandwidth, and we don't even generate it to save a\n    // bit of CPU and to avoid consuming entropy.\n    var randomSeed = null;\n    var randomSeedGenerator = function () {\n      if (randomSeed === null) {\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n      }\n      return randomSeed;\n    };\n\n    // Run the stub, if we have one. The stub is supposed to make some\n    // temporary writes to the database to give the user a smooth experience\n    // until the actual result of executing the method comes back from the\n    // server (whereupon the temporary writes to the database will be reversed\n    // during the beginUpdate/endUpdate process.)\n    //\n    // Normally, we ignore the return value of the stub (even if it is an\n    // exception), in favor of the real return value from the server. The\n    // exception is if the *caller* is a stub. In that case, we're not going\n    // to do a RPC, so we use the return value of the stub as our return\n    // value.\n\n    var stub = self._methodHandlers[name];\n    if (stub) {\n      var setUserId = function(userId) {\n        self.setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: true,\n        userId: self.userId(),\n        setUserId: setUserId,\n        randomSeed: function () { return randomSeedGenerator(); }\n      });\n\n      if (!alreadyInSimulation)\n        self._saveOriginals();\n\n      try {\n        // Note that unlike in the corresponding server code, we never audit\n        // that stubs check() their arguments.\n        var stubReturnValue = DDP._CurrentMethodInvocation.withValue(invocation, function () {\n          if (Meteor.isServer) {\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\n            // don't allow stubs to yield.\n            return Meteor._noYieldsAllowed(function () {\n              // re-clone, so that the stub can't affect our caller's values\n              return stub.apply(invocation, EJSON.clone(args));\n            });\n          } else {\n            return stub.apply(invocation, EJSON.clone(args));\n          }\n        });\n      }\n      catch (e) {\n        var exception = e;\n      }\n\n      if (!alreadyInSimulation)\n        self._retrieveAndStoreOriginals(methodId());\n    }\n\n    // If we're in a simulation, stop and return the result we have,\n    // rather than going on to do an RPC. If there was no stub,\n    // we'll end up returning undefined.\n    if (alreadyInSimulation) {\n      if (callback) {\n        callback(exception, stubReturnValue);\n        return undefined;\n      }\n      if (exception)\n        throw exception;\n      return stubReturnValue;\n    }\n\n    // If an exception occurred in a stub, and we're ignoring it\n    // because we're doing an RPC and want to use what the server\n    // returns instead, log it so the developer knows\n    // (unless they explicitly ask to see the error).\n    //\n    // Tests can set the 'expected' flag on an exception so it won't\n    // go to log.\n    if (exception) {\n      if (options.throwStubExceptions) {\n        throw exception;\n      } else if (!exception.expected) {\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +\n          name + \"'\", exception, exception.stack);\n      }\n    }\n\n\n    // At this point we're definitely doing an RPC, and we're going to\n    // return the value of the RPC to the caller.\n\n    // If the caller didn't give a callback, decide what to do.\n    if (!callback) {\n      if (Meteor.isClient) {\n        // On the client, we don't have fibers, so we can't block. The\n        // only thing we can do is to return undefined and discard the\n        // result of the RPC. If an error occurred then print the error\n        // to the console.\n        callback = function (err) {\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",\n                               err.message);\n        };\n      } else {\n        // On the server, make the function synchronous. Throw on\n        // errors, return on success.\n        var future = new Future;\n        callback = future.resolver();\n      }\n    }\n    // Send the RPC. Note that on the client, it is important that the\n    // stub have finished before we send the RPC, so that we know we have\n    // a complete list of which local documents the stub wrote.\n    var message = {\n      msg: 'method',\n      method: name,\n      params: args,\n      id: methodId()\n    };\n\n    // Send the randomSeed only if we used it\n    if (randomSeed !== null) {\n      message.randomSeed = randomSeed;\n    }\n\n    var methodInvoker = new MethodInvoker({\n      methodId: methodId(),\n      callback: callback,\n      connection: self,\n      onResultReceived: options.onResultReceived,\n      wait: !!options.wait,\n      message: message,\n      noRetry: !!options.noRetry\n    });\n\n    if (options.wait) {\n      // It's a wait method! Wait methods go in their own block.\n      self._outstandingMethodBlocks.push(\n        {wait: true, methods: [methodInvoker]});\n    } else {\n      // Not a wait method. Start a new block if the previous block was a wait\n      // block, and add it to the last block of methods.\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\n          _.last(self._outstandingMethodBlocks).wait)\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n    }\n\n    // If we added it to the first block, send it out now.\n    if (self._outstandingMethodBlocks.length === 1)\n      methodInvoker.sendMessage();\n\n    // If we're using the default callback on the server,\n    // block waiting for the result.\n    if (future) {\n      return future.wait();\n    }\n    return options.returnStubValue ? stubReturnValue : undefined;\n  },\n\n  // Before calling a method stub, prepare all stores to track changes and allow\n  // _retrieveAndStoreOriginals to get the original versions of changed\n  // documents.\n  _saveOriginals: function () {\n    var self = this;\n    if (!self._waitingForQuiescence())\n      self._flushBufferedWrites();\n    _.each(self._stores, function (s) {\n      s.saveOriginals();\n    });\n  },\n  // Retrieves the original versions of all documents modified by the stub for\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n  // by document) and _documentsWrittenByStub (keyed by method ID).\n  _retrieveAndStoreOriginals: function (methodId) {\n    var self = this;\n    if (self._documentsWrittenByStub[methodId])\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n\n    var docsWritten = [];\n    _.each(self._stores, function (s, collection) {\n      var originals = s.retrieveOriginals();\n      // not all stores define retrieveOriginals\n      if (!originals)\n        return;\n      originals.forEach(function (doc, id) {\n        docsWritten.push({collection: collection, id: id});\n        if (!_.has(self._serverDocuments, collection))\n          self._serverDocuments[collection] = new MongoIDMap;\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n        if (serverDoc.writtenByStubs) {\n          // We're not the first stub to write this doc. Just add our method ID\n          // to the record.\n          serverDoc.writtenByStubs[methodId] = true;\n        } else {\n          // First stub! Save the original value and our method ID.\n          serverDoc.document = doc;\n          serverDoc.flushCallbacks = [];\n          serverDoc.writtenByStubs = {};\n          serverDoc.writtenByStubs[methodId] = true;\n        }\n      });\n    });\n    if (!_.isEmpty(docsWritten)) {\n      self._documentsWrittenByStub[methodId] = docsWritten;\n    }\n  },\n\n  // This is very much a private function we use to make the tests\n  // take up fewer server resources after they complete.\n  _unsubscribeAll: function () {\n    var self = this;\n    _.each(_.clone(self._subscriptions), function (sub, id) {\n      // Avoid killing the autoupdate subscription so that developers\n      // still get hot code pushes when writing tests.\n      //\n      // XXX it's a hack to encode knowledge about autoupdate here,\n      // but it doesn't seem worth it yet to have a special API for\n      // subscriptions to preserve after unit tests.\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n        self._subscriptions[id].stop();\n      }\n    });\n  },\n\n  // Sends the DDP stringification of the given message object\n  _send: function (obj) {\n    var self = this;\n    self._stream.send(DDPCommon.stringifyDDP(obj));\n  },\n\n  // We detected via DDP-level heartbeats that we've lost the\n  // connection.  Unlike `disconnect` or `close`, a lost connection\n  // will be automatically retried.\n  _lostConnection: function (error) {\n    var self = this;\n    self._stream._lostConnection(error);\n  },\n\n  /**\n   * @summary Get the current connection status. A reactive data source.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  status: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.status.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n\n  This method does nothing if the client is already connected.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  reconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.reconnect.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Disconnect the client from the server.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  disconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.disconnect.apply(self._stream, arguments);\n  },\n\n  close: function () {\n    var self = this;\n    return self._stream.disconnect({_permanent: true});\n  },\n\n  ///\n  /// Reactive user system\n  ///\n  userId: function () {\n    var self = this;\n    if (self._userIdDeps)\n      self._userIdDeps.depend();\n    return self._userId;\n  },\n\n  setUserId: function (userId) {\n    var self = this;\n    // Avoid invalidating dependents if setUserId is called with current value.\n    if (self._userId === userId)\n      return;\n    self._userId = userId;\n    if (self._userIdDeps)\n      self._userIdDeps.changed();\n  },\n\n  // Returns true if we are in a state after reconnect of waiting for subs to be\n  // revived or early methods to finish their data, or we are waiting for a\n  // \"wait\" method to finish.\n  _waitingForQuiescence: function () {\n    var self = this;\n    return (! _.isEmpty(self._subsBeingRevived) ||\n            ! _.isEmpty(self._methodsBlockingQuiescence));\n  },\n\n  // Returns true if any method whose message has been sent to the server has\n  // not yet invoked its user callback.\n  _anyMethodsAreOutstanding: function () {\n    var self = this;\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n  },\n\n  _livedata_connected: function (msg) {\n    var self = this;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout: function () {\n          self._lostConnection(\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n        },\n        sendPing: function () {\n          self._send({msg: 'ping'});\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId)\n      self._resetStores = true;\n\n    if (typeof (msg.session) === \"string\") {\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.  Note that right\n      // now, this never happens: the server never connects us to a previous\n      // session, because DDP doesn't provide enough data for the server to know\n      // what messages the client has processed. We need to improve DDP to make\n      // this possible, at which point we'll probably need more code here.\n      return;\n    }\n\n    // Server doesn't have our data any more. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = {};\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = {};\n      self._serverDocuments = {};\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready (ie, we already called the\n    // ready callback) as needing to be revived.\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\n    self._subsBeingRevived = {};\n    _.each(self._subscriptions, function (sub, id) {\n      if (sub.ready)\n        self._subsBeingRevived[id] = true;\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = {};\n    if (self._resetStores) {\n      _.each(self._methodInvokers, function (invoker) {\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        _.each(self._stores, function (s) {\n          s.beginUpdate(0, true);\n          s.endUpdate();\n        });\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  },\n\n\n  _processOneDataMessage: function (msg, updates) {\n    var self = this;\n    // Using underscore here so as not to need to capitalize.\n    self['_process_' + msg.msg](msg, updates);\n  },\n\n\n  _livedata_data: function (msg) {\n    var self = this;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === \"nosub\")\n        delete self._subsBeingRevived[msg.id];\n\n      _.each(msg.subs || [], function (subId) {\n        delete self._subsBeingRevived[subId];\n      });\n      _.each(msg.methods || [], function (methodId) {\n        delete self._methodsBlockingQuiescence[methodId];\n      });\n\n      if (self._waitingForQuiescence())\n        return;\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n        self._processOneDataMessage(bufferedMsg, self._bufferedWrites);\n      });\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      self._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    var standardWrite = _.include(['added', 'changed', 'removed'], msg.msg);\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n    }\n    else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites,\n                                                      self._bufferedWritesInterval);\n  },\n\n  _flushBufferedWrites: function () {\n    var self = this;\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n      self._bufferedWritesFlushHandle = null;\n    }\n\n    self._bufferedWritesFlushAt = null;\n    // We need to clear the buffer before passing it to\n    //  performWrites. As there's no guarantee that it\n    //  will exit cleanly.\n    var writes = self._bufferedWrites;\n    self._bufferedWrites = {};\n    self._performWrites(writes);\n  },\n\n  _performWrites: function(updates){\n    var self = this;\n\n    if (self._resetStores || !_.isEmpty(updates)) {\n      // Begin a transactional update of each store.\n      _.each(self._stores, function (s, storeName) {\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\n                      self._resetStores);\n      });\n      self._resetStores = false;\n\n      _.each(updates, function (updateMessages, storeName) {\n        var store = self._stores[storeName];\n        if (store) {\n          _.each(updateMessages, function (updateMessage) {\n            store.update(updateMessage);\n          });\n        } else {\n          // Nobody's listening for this data. Queue it up until\n          // someone wants it.\n          // XXX memory use will grow without bound if you forget to\n          // create a collection or just don't care about it... going\n          // to have to do something about that.\n          if (!_.has(self._updatesForUnknownStores, storeName))\n            self._updatesForUnknownStores[storeName] = [];\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\n                                     updateMessages);\n        }\n      });\n\n      // End update transaction.\n      _.each(self._stores, function (s) { s.endUpdate(); });\n    }\n\n    self._runAfterUpdateCallbacks();\n  },\n\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n  // relevant docs have been flushed, as well as dataVisible callbacks at\n  // reconnect-quiescence time.\n  _runAfterUpdateCallbacks: function () {\n    var self = this;\n    var callbacks = self._afterUpdateCallbacks;\n    self._afterUpdateCallbacks = [];\n    _.each(callbacks, function (c) {\n      c();\n    });\n  },\n\n  _pushUpdate: function (updates, collection, msg) {\n    var self = this;\n    if (!_.has(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  },\n\n  _getServerDoc: function (collection, id) {\n    var self = this;\n    if (!_.has(self._serverDocuments, collection))\n      return null;\n    var serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  },\n\n  _process_added: function (msg, updates) {\n    var self = this;\n    var id = MongoID.idParse(msg.id);\n    var serverDoc = self._getServerDoc(msg.collection, id);\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      var isExisting = (serverDoc.document !== undefined);\n\n      serverDoc.document = msg.fields || {};\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined)\n          msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_changed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_removed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  },\n\n  _process_updated: function (msg, updates) {\n    var self = this;\n    // Process \"method done\" messages.\n    _.each(msg.methods, function (methodId) {\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\n        var serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc)\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n        if (!serverDoc.writtenByStubs[methodId])\n          throw new Error(\"Doc \" + JSON.stringify(written) +\n                          \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          _.each(serverDoc.flushCallbacks, function (c) {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      var callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker)\n        throw new Error(\"No callback invoker for method \" + methodId);\n      self._runWhenAllServerDocsAreFlushed(\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\n    });\n  },\n\n  _process_ready: function (msg, updates) {\n    var self = this;\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    _.each(msg.subs, function (subId) {\n      self._runWhenAllServerDocsAreFlushed(function () {\n        var subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord)\n          return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready)\n          return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  },\n\n  // Ensures that \"f\" will be called after all documents currently in\n  // _serverDocuments have been written to the local cache. f will not be called\n  // if the connection is lost before then!\n  _runWhenAllServerDocsAreFlushed: function (f) {\n    var self = this;\n    var runFAfterUpdates = function () {\n      self._afterUpdateCallbacks.push(f);\n    };\n    var unflushedServerDocCount = 0;\n    var onServerDocFlush = function () {\n      --unflushedServerDocCount;\n      if (unflushedServerDocCount === 0) {\n        // This was the last doc to flush! Arrange to run f after the updates\n        // have been applied.\n        runFAfterUpdates();\n      }\n    };\n    _.each(self._serverDocuments, function (collectionDocs) {\n      collectionDocs.forEach(function (serverDoc) {\n        var writtenByStubForAMethodWithSentMessage = _.any(\n          serverDoc.writtenByStubs, function (dummy, methodId) {\n            var invoker = self._methodInvokers[methodId];\n            return invoker && invoker.sentMessage;\n          });\n        if (writtenByStubForAMethodWithSentMessage) {\n          ++unflushedServerDocCount;\n          serverDoc.flushCallbacks.push(onServerDocFlush);\n        }\n      });\n    });\n    if (unflushedServerDocCount === 0) {\n      // There aren't any buffered docs --- we can call f as soon as the current\n      // round of updates is applied!\n      runFAfterUpdates();\n    }\n  },\n\n  _livedata_nosub: function (msg) {\n    var self = this;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    self._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!_.has(self._subscriptions, msg.id))\n      return;\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    var meteorErrorFromMsg = function (msgArg) {\n      return msgArg && msgArg.error && new Meteor.Error(\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  },\n\n  _process_nosub: function () {\n    // This is called as part of the \"buffer until quiescence\" process, but\n    // nosub's effect is always immediate. It only goes in the buffer at all\n    // because it's possible for a nosub to be the thing that triggers\n    // quiescence, if we were waiting for a sub to be revived and it dies\n    // instead.\n  },\n\n  _livedata_result: function (msg) {\n    // id, result or error. error has error (code), reason, details\n\n    var self = this;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!_.isEmpty(self._bufferedWrites)) {\n      self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug(\"Received method result but no methods outstanding\");\n      return;\n    }\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    var m;\n    for (var i = 0; i < currentMethodBlock.length; i++) {\n      m = currentMethodBlock[i];\n      if (m.methodId === msg.id)\n        break;\n    }\n\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (_.has(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(\n        msg.error.error, msg.error.reason,\n        msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a\n      // value\n      m.receiveResult(undefined, msg.result);\n    }\n  },\n\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\n  // the last outstanding method in the current block, runs the next block. If\n  // there are no more methods, consider accepting a hot code push.\n  _outstandingMethodFinished: function () {\n    var self = this;\n    if (self._anyMethodsAreOutstanding())\n      return;\n\n    // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that\n    // half-finished before disconnect/reconnect.)\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\n      var firstBlock = self._outstandingMethodBlocks.shift();\n      if (! _.isEmpty(firstBlock.methods))\n        throw new Error(\"No methods outstanding but nonempty block: \" +\n                        JSON.stringify(firstBlock));\n\n      // Send the outstanding methods now in the first block.\n      if (!_.isEmpty(self._outstandingMethodBlocks))\n        self._sendOutstandingMethods();\n    }\n\n    // Maybe accept a hot code push.\n    self._maybeMigrate();\n  },\n\n  // Sends messages for all the methods in the first block in\n  // _outstandingMethodBlocks.\n  _sendOutstandingMethods: function() {\n    var self = this;\n    if (_.isEmpty(self._outstandingMethodBlocks))\n      return;\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n      m.sendMessage();\n    });\n  },\n\n  _livedata_error: function (msg) {\n    Meteor._debug(\"Received error from server: \", msg.reason);\n    if (msg.offendingMessage)\n      Meteor._debug(\"For: \", msg.offendingMessage);\n  },\n\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\n    var self = this;\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n    self._outstandingMethodBlocks = [];\n\n    self.onReconnect && self.onReconnect();\n    DDP._reconnectHook.each(function (callback) {\n      callback(self);\n      return true;\n    });\n\n    if (_.isEmpty(oldOutstandingMethodBlocks))\n      return;\n\n    // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just\n    // restore all outstanding methods and run the first block.\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n      self._sendOutstandingMethods();\n      return;\n    }\n\n    // OK, there are blocks on both sides. Special case: merge the last block of\n    // the reconnect methods with the first block of the original methods, if\n    // neither of them are \"wait\" blocks.\n    if (!_.last(self._outstandingMethodBlocks).wait &&\n        !oldOutstandingMethodBlocks[0].wait) {\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n        _.last(self._outstandingMethodBlocks).methods.push(m);\n\n        // If this \"last block\" is also the first block, send the message.\n        if (self._outstandingMethodBlocks.length === 1)\n          m.sendMessage();\n      });\n\n      oldOutstandingMethodBlocks.shift();\n    }\n\n    // Now add the rest of the original blocks on.\n    _.each(oldOutstandingMethodBlocks, function (block) {\n      self._outstandingMethodBlocks.push(block);\n    });\n  },\n\n  // We can accept a hot code push if there are no methods in flight.\n  _readyToMigrate: function() {\n    var self = this;\n    return _.isEmpty(self._methodInvokers);\n  },\n\n  // If we were blocking a migration, see if it's now possible to continue.\n  // Call whenever the set of outstanding/blocked methods shrinks.\n  _maybeMigrate: function () {\n    var self = this;\n    if (self._retryMigrate && self._readyToMigrate()) {\n      self._retryMigrate();\n      self._retryMigrate = null;\n    }\n  }\n});\n\nLivedataTest.Connection = Connection;\n\n// @param url {String} URL to Meteor app,\n//     e.g.:\n//     \"subdomain.meteor.com\",\n//     \"http://subdomain.meteor.com\",\n//     \"/\",\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n/**\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere\n * @param {String} url The URL of another Meteor application.\n */\nDDP.connect = function (url, options) {\n  var ret = new Connection(url, options);\n  allConnections.push(ret); // hack. see below.\n  return ret;\n};\n\nDDP._reconnectHook = new Hook({ bindEnvironment: false });\n\n/**\n * @summary Register a function to call as the first step of\n * reconnecting. This function can call methods which will be executed before\n * any other outstanding methods. For example, this can be used to re-establish\n * the appropriate authentication context on the connection.\n * @locus Anywhere\n * @param {Function} callback The function to call. It will be called with a\n * single argument, the [connection object](#ddp_connect) that is reconnecting.\n */\nDDP.onReconnect = function (callback) {\n  return DDP._reconnectHook.register(callback);\n};\n\n// Hack for `spiderable` package: a way to see if the page is done\n// loading all the data it needs.\n//\nallConnections = [];\nDDP._allSubscriptionsReady = function () {\n  return _.all(allConnections, function (conn) {\n    return _.all(conn._subscriptions, function (sub) {\n      return sub.ready;\n    });\n  });\n};\n","/**\n * @namespace DDP\n * @summary Namespace for DDP-related methods/classes.\n */\nexport const DDP = {};\nexport const LivedataTest = {};\n","export class MongoIDMap extends IdMap {\n  constructor() {\n    super(\n      MongoID.idStringify,\n      MongoID.idParse,\n    );\n  }\n}\n"]}}]