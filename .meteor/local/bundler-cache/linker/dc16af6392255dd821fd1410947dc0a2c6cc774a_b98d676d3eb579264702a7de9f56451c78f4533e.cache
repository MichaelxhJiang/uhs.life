[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar FS = Package['cfs:base-package'].FS;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\n\n/* Package-scope variables */\nvar _chunkPath, _fileReference;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////\n//                                                                   //\n// packages/cfs_tempstore/packages/cfs_tempstore.js                  //\n//                                                                   //\n///////////////////////////////////////////////////////////////////////\n                                                                     //\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/cfs:tempstore/tempStore.js                                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// ##Temporary Storage                                                                                                 // 1\n//                                                                                                                     // 2\n// Temporary storage is used for chunked uploads until all chunks are received                                         // 3\n// and all copies have been made or given up. In some cases, the original file                                         // 4\n// is stored only in temporary storage (for example, if all copies do some                                             // 5\n// manipulation in beforeSave). This is why we use the temporary file as the                                           // 6\n// basis for each saved copy, and then remove it after all copies are saved.                                           // 7\n//                                                                                                                     // 8\n// Every chunk is saved as an individual temporary file. This is safer than                                            // 9\n// attempting to write multiple incoming chunks to different positions in a                                            // 10\n// single temporary file, which can lead to write conflicts.                                                           // 11\n//                                                                                                                     // 12\n// Using temp files also allows us to easily resume uploads, even if the server                                        // 13\n// restarts, and to keep the working memory clear.                                                                     // 14\n                                                                                                                       // 15\n// The FS.TempStore emits events that others are able to listen to                                                     // 16\nvar EventEmitter = Npm.require('events').EventEmitter;                                                                 // 17\n                                                                                                                       // 18\n// We have a special stream concating all chunk files into one readable stream                                         // 19\nvar CombinedStream = Npm.require('combined-stream');                                                                   // 20\n                                                                                                                       // 21\n/** @namespace FS.TempStore                                                                                            // 22\n * @property FS.TempStore                                                                                              // 23\n * @type {object}                                                                                                      // 24\n * @public                                                                                                             // 25\n * *it's an event emitter*                                                                                             // 26\n */                                                                                                                    // 27\nFS.TempStore = new EventEmitter();                                                                                     // 28\n                                                                                                                       // 29\n// Create a tracker collection for keeping track of all chunks for any files that are currently in the temp store      // 30\nvar tracker = FS.TempStore.Tracker = new Mongo.Collection('cfs._tempstore.chunks');                                    // 31\n                                                                                                                       // 32\n/**                                                                                                                    // 33\n * @property FS.TempStore.Storage                                                                                      // 34\n * @type {StorageAdapter}                                                                                              // 35\n * @namespace FS.TempStore                                                                                             // 36\n * @private                                                                                                            // 37\n * This property is set to either `FS.Store.FileSystem` or `FS.Store.GridFS`                                           // 38\n *                                                                                                                     // 39\n * __When and why:__                                                                                                   // 40\n * We normally default to `cfs-filesystem` unless its not installed. *(we default to gridfs if installed)*             // 41\n * But if `cfs-gridfs` and `cfs-worker` is installed we default to `cfs-gridfs`                                        // 42\n *                                                                                                                     // 43\n * If `cfs-gridfs` and `cfs-filesystem` is not installed we log a warning.                                             // 44\n * the user can set `FS.TempStore.Storage` them selfs eg.:                                                             // 45\n * ```js                                                                                                               // 46\n *   // Its important to set `internal: true` this lets the SA know that we                                            // 47\n *   // are using this internally and it will give us direct SA api                                                    // 48\n *   FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });                                     // 49\n * ```                                                                                                                 // 50\n *                                                                                                                     // 51\n * > Note: This is considered as `advanced` use, its not a common pattern.                                             // 52\n */                                                                                                                    // 53\nFS.TempStore.Storage = null;                                                                                           // 54\n                                                                                                                       // 55\n// We will not mount a storage adapter until needed. This allows us to check for the                                   // 56\n// existance of FS.FileWorker, which is loaded after this package because it                                           // 57\n// depends on this package.                                                                                            // 58\nfunction mountStorage() {                                                                                              // 59\n                                                                                                                       // 60\n  if (FS.TempStore.Storage) return;                                                                                    // 61\n                                                                                                                       // 62\n  // XXX: We could replace this test, testing the FS scope for grifFS etc.                                             // 63\n  // This is on the todo later when we get \"stable\"                                                                    // 64\n  if (Package[\"cfs:gridfs\"] && (Package[\"cfs:worker\"] || !Package[\"cfs:filesystem\"])) {                                // 65\n    // If the file worker is installed we would prefer to use the gridfs sa                                            // 66\n    // for scalability. We also default to gridfs if filesystem is not found                                           // 67\n                                                                                                                       // 68\n    // Use the gridfs                                                                                                  // 69\n    FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });                                      // 70\n  } else if (Package[\"cfs:filesystem\"]) {                                                                              // 71\n                                                                                                                       // 72\n    // use the Filesystem                                                                                              // 73\n    FS.TempStore.Storage = new FS.Store.FileSystem('_tempstore', { internal: true });                                  // 74\n  } else {                                                                                                             // 75\n    throw new Error('FS.TempStore.Storage is not set: Install cfs:filesystem or cfs:gridfs or set it manually');       // 76\n  }                                                                                                                    // 77\n                                                                                                                       // 78\n  FS.debug && console.log('TempStore is mounted on', FS.TempStore.Storage.typeName);                                   // 79\n}                                                                                                                      // 80\n                                                                                                                       // 81\nfunction mountFile(fileObj, name) {                                                                                    // 82\n  if (!fileObj.isMounted()) {                                                                                          // 83\n    throw new Error(name + ' cannot work with unmounted file');                                                        // 84\n  }                                                                                                                    // 85\n}                                                                                                                      // 86\n                                                                                                                       // 87\n// We update the fileObj on progress                                                                                   // 88\nFS.TempStore.on('progress', function(fileObj, chunkNum, count, total, result) {                                        // 89\n  FS.debug && console.log('TempStore progress: Received ' + count + ' of ' + total + ' chunks for ' + fileObj.name()); // 90\n});                                                                                                                    // 91\n                                                                                                                       // 92\n// XXX: TODO                                                                                                           // 93\n// FS.TempStore.on('stored', function(fileObj, chunkCount, result) {                                                   // 94\n//   // This should work if we pass on result from the SA on stored event...                                           // 95\n//   fileObj.update({ $set: { chunkSum: 1, chunkCount: chunkCount, size: result.size } });                             // 96\n// });                                                                                                                 // 97\n                                                                                                                       // 98\n// Stream implementation                                                                                               // 99\n                                                                                                                       // 100\n/**                                                                                                                    // 101\n * @method _chunkPath                                                                                                  // 102\n * @private                                                                                                            // 103\n * @param {Number} [n] Chunk number                                                                                    // 104\n * @returns {String} Chunk naming convention                                                                           // 105\n */                                                                                                                    // 106\n_chunkPath = function(n) {                                                                                             // 107\n  return (n || 0) + '.chunk';                                                                                          // 108\n};                                                                                                                     // 109\n                                                                                                                       // 110\n/**                                                                                                                    // 111\n * @method _fileReference                                                                                              // 112\n * @param {FS.File} fileObj                                                                                            // 113\n * @param {Number} chunk                                                                                               // 114\n * @private                                                                                                            // 115\n * @returns {String} Generated SA specific fileKey for the chunk                                                       // 116\n *                                                                                                                     // 117\n * Note: Calling function should call mountStorage() first, and                                                        // 118\n * make sure that fileObj is mounted.                                                                                  // 119\n */                                                                                                                    // 120\n_fileReference = function(fileObj, chunk, existing) {                                                                  // 121\n  // Maybe it's a chunk we've already saved                                                                            // 122\n  existing = existing || tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});               // 123\n                                                                                                                       // 124\n  // Make a temporary fileObj just for fileKey generation                                                              // 125\n  var tempFileObj = new FS.File({                                                                                      // 126\n    collectionName: fileObj.collectionName,                                                                            // 127\n    _id: fileObj._id,                                                                                                  // 128\n    original: {                                                                                                        // 129\n      name: _chunkPath(chunk)                                                                                          // 130\n    },                                                                                                                 // 131\n    copies: {                                                                                                          // 132\n      _tempstore: {                                                                                                    // 133\n        key: existing && existing.keys[chunk]                                                                          // 134\n      }                                                                                                                // 135\n    }                                                                                                                  // 136\n  });                                                                                                                  // 137\n                                                                                                                       // 138\n  // Return a fitting fileKey SA specific                                                                              // 139\n  return FS.TempStore.Storage.adapter.fileKey(tempFileObj);                                                            // 140\n};                                                                                                                     // 141\n                                                                                                                       // 142\n/**                                                                                                                    // 143\n * @method FS.TempStore.exists                                                                                         // 144\n * @param {FS.File} File object                                                                                        // 145\n * @returns {Boolean} Is this file, or parts of it, currently stored in the TempStore                                  // 146\n */                                                                                                                    // 147\nFS.TempStore.exists = function(fileObj) {                                                                              // 148\n  var existing = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});                       // 149\n  return !!existing;                                                                                                   // 150\n};                                                                                                                     // 151\n                                                                                                                       // 152\n/**                                                                                                                    // 153\n * @method FS.TempStore.listParts                                                                                      // 154\n * @param {FS.File} fileObj                                                                                            // 155\n * @returns {Object} of parts already stored                                                                           // 156\n * @todo This is not yet implemented, milestone 1.1.0                                                                  // 157\n */                                                                                                                    // 158\nFS.TempStore.listParts = function fsTempStoreListParts(fileObj) {                                                      // 159\n  var self = this;                                                                                                     // 160\n  console.warn('This function is not correctly implemented using SA in TempStore');                                    // 161\n  //XXX This function might be necessary for resume. Not currently supported.                                          // 162\n};                                                                                                                     // 163\n                                                                                                                       // 164\n/**                                                                                                                    // 165\n * @method FS.TempStore.removeFile                                                                                     // 166\n * @public                                                                                                             // 167\n * @param {FS.File} fileObj                                                                                            // 168\n * This function removes the file from tempstorage - it cares not if file is                                           // 169\n * already removed or not found, goal is reached anyway.                                                               // 170\n */                                                                                                                    // 171\nFS.TempStore.removeFile = function fsTempStoreRemoveFile(fileObj) {                                                    // 172\n  var self = this;                                                                                                     // 173\n                                                                                                                       // 174\n  // Ensure that we have a storage adapter mounted; if not, throw an error.                                            // 175\n  mountStorage();                                                                                                      // 176\n                                                                                                                       // 177\n  // If fileObj is not mounted or can't be, throw an error                                                             // 178\n  mountFile(fileObj, 'FS.TempStore.removeFile');                                                                       // 179\n                                                                                                                       // 180\n  // Emit event                                                                                                        // 181\n  self.emit('remove', fileObj);                                                                                        // 182\n                                                                                                                       // 183\n  var chunkInfo = tracker.findOne({                                                                                    // 184\n    fileId: fileObj._id,                                                                                               // 185\n    collectionName: fileObj.collectionName                                                                             // 186\n  });                                                                                                                  // 187\n                                                                                                                       // 188\n  if (chunkInfo) {                                                                                                     // 189\n                                                                                                                       // 190\n    // Unlink each file                                                                                                // 191\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {                                                      // 192\n      var fileKey = _fileReference(fileObj, chunk, chunkInfo);                                                         // 193\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);                                                   // 194\n    });                                                                                                                // 195\n                                                                                                                       // 196\n    // Remove fileObj from tracker collection, too                                                                     // 197\n    tracker.remove({_id: chunkInfo._id});                                                                              // 198\n                                                                                                                       // 199\n  }                                                                                                                    // 200\n};                                                                                                                     // 201\n                                                                                                                       // 202\n/**                                                                                                                    // 203\n * @method FS.TempStore.removeAll                                                                                      // 204\n * @public                                                                                                             // 205\n * This function removes all files from tempstorage - it cares not if file is                                          // 206\n * already removed or not found, goal is reached anyway.                                                               // 207\n */                                                                                                                    // 208\nFS.TempStore.removeAll = function fsTempStoreRemoveAll() {                                                             // 209\n  var self = this;                                                                                                     // 210\n                                                                                                                       // 211\n  // Ensure that we have a storage adapter mounted; if not, throw an error.                                            // 212\n  mountStorage();                                                                                                      // 213\n                                                                                                                       // 214\n  tracker.find().forEach(function (chunkInfo) {                                                                        // 215\n    // Unlink each file                                                                                                // 216\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {                                                      // 217\n      var fileKey = _fileReference({_id: chunkInfo.fileId, collectionName: chunkInfo.collectionName}, chunk, chunkInfo);\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);                                                   // 219\n    });                                                                                                                // 220\n                                                                                                                       // 221\n    // Remove from tracker collection, too                                                                             // 222\n    tracker.remove({_id: chunkInfo._id});                                                                              // 223\n  });                                                                                                                  // 224\n};                                                                                                                     // 225\n                                                                                                                       // 226\n/**                                                                                                                    // 227\n * @method FS.TempStore.createWriteStream                                                                              // 228\n * @public                                                                                                             // 229\n * @param {FS.File} fileObj File to store in temporary storage                                                         // 230\n * @param {Number | String} [options]                                                                                  // 231\n * @returns {Stream} Writeable stream                                                                                  // 232\n *                                                                                                                     // 233\n * `options` of different types mean differnt things:                                                                  // 234\n * * `undefined` We store the file in one part                                                                         // 235\n * *(Normal server-side api usage)*                                                                                    // 236\n * * `Number` the number is the part number total                                                                      // 237\n * *(multipart uploads will use this api)*                                                                             // 238\n * * `String` the string is the name of the `store` that wants to store file data                                      // 239\n * *(stores that want to sync their data to the rest of the files stores will use this)*                               // 240\n *                                                                                                                     // 241\n * > Note: fileObj must be mounted on a `FS.Collection`, it makes no sense to store otherwise                          // 242\n */                                                                                                                    // 243\nFS.TempStore.createWriteStream = function(fileObj, options) {                                                          // 244\n  var self = this;                                                                                                     // 245\n                                                                                                                       // 246\n  // Ensure that we have a storage adapter mounted; if not, throw an error.                                            // 247\n  mountStorage();                                                                                                      // 248\n                                                                                                                       // 249\n  // If fileObj is not mounted or can't be, throw an error                                                             // 250\n  mountFile(fileObj, 'FS.TempStore.createWriteStream');                                                                // 251\n                                                                                                                       // 252\n  // Cache the selector for use multiple times below                                                                   // 253\n  var selector = {fileId: fileObj._id, collectionName: fileObj.collectionName};                                        // 254\n                                                                                                                       // 255\n  // TODO, should pass in chunkSum so we don't need to use FS.File for it                                              // 256\n  var chunkSum = fileObj.chunkSum || 1;                                                                                // 257\n                                                                                                                       // 258\n  // Add fileObj to tracker collection                                                                                 // 259\n  tracker.upsert(selector, {$setOnInsert: {keys: {}}});                                                                // 260\n                                                                                                                       // 261\n  // Determine how we're using the writeStream                                                                         // 262\n  var isOnePart = false, isMultiPart = false, isStoreSync = false, chunkNum = 0;                                       // 263\n  if (options === +options) {                                                                                          // 264\n    isMultiPart = true;                                                                                                // 265\n    chunkNum = options;                                                                                                // 266\n  } else if (options === ''+options) {                                                                                 // 267\n    isStoreSync = true;                                                                                                // 268\n  } else {                                                                                                             // 269\n    isOnePart = true;                                                                                                  // 270\n  }                                                                                                                    // 271\n                                                                                                                       // 272\n  // XXX: it should be possible for a store to sync by storing data into the                                           // 273\n  // tempstore - this could be done nicely by setting the store name as string                                         // 274\n  // in the chunk variable?                                                                                            // 275\n  // This store name could be passed on the the fileworker via the uploaded                                            // 276\n  // event                                                                                                             // 277\n  // So the uploaded event can return:                                                                                 // 278\n  // undefined - if data is stored into and should sync out to all storage adapters                                    // 279\n  // number - if a chunk has been uploaded                                                                             // 280\n  // string - if a storage adapter wants to sync its data to the other SA's                                            // 281\n                                                                                                                       // 282\n  // Find a nice location for the chunk data                                                                           // 283\n  var fileKey = _fileReference(fileObj, chunkNum);                                                                     // 284\n                                                                                                                       // 285\n  // Create the stream as Meteor safe stream                                                                           // 286\n  var writeStream = FS.TempStore.Storage.adapter.createWriteStream(fileKey);                                           // 287\n                                                                                                                       // 288\n  // When the stream closes we update the chunkCount                                                                   // 289\n  writeStream.safeOn('stored', function(result) {                                                                      // 290\n    // Save key in tracker document                                                                                    // 291\n    var setObj = {};                                                                                                   // 292\n    setObj['keys.' + chunkNum] = result.fileKey;                                                                       // 293\n    tracker.update(selector, {$set: setObj});                                                                          // 294\n                                                                                                                       // 295\n    // Get updated chunkCount                                                                                          // 296\n    var chunkCount = FS.Utility.size(tracker.findOne(selector).keys);                                                  // 297\n                                                                                                                       // 298\n    // Progress                                                                                                        // 299\n    self.emit('progress', fileObj, chunkNum, chunkCount, chunkSum, result);                                            // 300\n                                                                                                                       // 301\n    // If upload is completed                                                                                          // 302\n    if (chunkCount === chunkSum) {                                                                                     // 303\n      // We no longer need the chunk info                                                                              // 304\n      var modifier = { $set: {}, $unset: {chunkCount: 1, chunkSum: 1, chunkSize: 1} };                                 // 305\n                                                                                                                       // 306\n      // Check if the file has been uploaded before                                                                    // 307\n      if (typeof fileObj.uploadedAt === 'undefined') {                                                                 // 308\n        // We set the uploadedAt date                                                                                  // 309\n        modifier.$set.uploadedAt = new Date();                                                                         // 310\n      } else {                                                                                                         // 311\n        // We have been uploaded so an event were file data is updated is                                              // 312\n        // called synchronizing - so this must be a synchronizedAt?                                                    // 313\n        modifier.$set.synchronizedAt = new Date();                                                                     // 314\n      }                                                                                                                // 315\n                                                                                                                       // 316\n      // Update the fileObject                                                                                         // 317\n      fileObj.update(modifier);                                                                                        // 318\n                                                                                                                       // 319\n      // Fire ending events                                                                                            // 320\n      var eventName = isStoreSync ? 'synchronized' : 'stored';                                                         // 321\n      self.emit(eventName, fileObj, result);                                                                           // 322\n                                                                                                                       // 323\n      // XXX is emitting \"ready\" necessary?                                                                            // 324\n      self.emit('ready', fileObj, chunkCount, result);                                                                 // 325\n    } else {                                                                                                           // 326\n      // Update the chunkCount on the fileObject                                                                       // 327\n      fileObj.update({ $set: {chunkCount: chunkCount} });                                                              // 328\n    }                                                                                                                  // 329\n  });                                                                                                                  // 330\n                                                                                                                       // 331\n  // Emit errors                                                                                                       // 332\n  writeStream.on('error', function (error) {                                                                           // 333\n    FS.debug && console.log('TempStore writeStream error:', error);                                                    // 334\n    self.emit('error', error, fileObj);                                                                                // 335\n  });                                                                                                                  // 336\n                                                                                                                       // 337\n  return writeStream;                                                                                                  // 338\n};                                                                                                                     // 339\n                                                                                                                       // 340\n/**                                                                                                                    // 341\n  * @method FS.TempStore.createReadStream                                                                              // 342\n  * @public                                                                                                            // 343\n  * @param {FS.File} fileObj The file to read                                                                          // 344\n  * @return {Stream} Returns readable stream                                                                           // 345\n  *                                                                                                                    // 346\n  */                                                                                                                   // 347\nFS.TempStore.createReadStream = function(fileObj) {                                                                    // 348\n  // Ensure that we have a storage adapter mounted; if not, throw an error.                                            // 349\n  mountStorage();                                                                                                      // 350\n                                                                                                                       // 351\n  // If fileObj is not mounted or can't be, throw an error                                                             // 352\n  mountFile(fileObj, 'FS.TempStore.createReadStream');                                                                 // 353\n                                                                                                                       // 354\n  FS.debug && console.log('FS.TempStore creating read stream for ' + fileObj._id);                                     // 355\n                                                                                                                       // 356\n  // Determine how many total chunks there are from the tracker collection                                             // 357\n  var chunkInfo = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName}) || {};                // 358\n  var totalChunks = FS.Utility.size(chunkInfo.keys);                                                                   // 359\n                                                                                                                       // 360\n  function getNextStreamFunc(chunk) {                                                                                  // 361\n    return Meteor.bindEnvironment(function(next) {                                                                     // 362\n      var fileKey = _fileReference(fileObj, chunk);                                                                    // 363\n      var chunkReadStream = FS.TempStore.Storage.adapter.createReadStream(fileKey);                                    // 364\n      next(chunkReadStream);                                                                                           // 365\n    }, function (error) {                                                                                              // 366\n      throw error;                                                                                                     // 367\n    });                                                                                                                // 368\n  }                                                                                                                    // 369\n                                                                                                                       // 370\n  // Make a combined stream                                                                                            // 371\n  var combinedStream = CombinedStream.create();                                                                        // 372\n                                                                                                                       // 373\n  // Add each chunk stream to the combined stream when the previous chunk stream ends                                  // 374\n  var currentChunk = 0;                                                                                                // 375\n  for (var chunk = 0; chunk < totalChunks; chunk++) {                                                                  // 376\n    combinedStream.append(getNextStreamFunc(chunk));                                                                   // 377\n  }                                                                                                                    // 378\n                                                                                                                       // 379\n  // Return the combined stream                                                                                        // 380\n  return combinedStream;                                                                                               // 381\n};                                                                                                                     // 382\n                                                                                                                       // 383\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n///////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['cfs:tempstore'] = {};\n\n})();\n","servePath":"/packages/cfs_tempstore.js"}]