[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\nvar DDP = Package['ddp-client'].DDP;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"dynamic-import\":{\"client.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/client.js                                           //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nvar Module = module.constructor;                                               // 1\nvar cache = require(\"./cache.js\");                                             // 2\n                                                                               // 3\n// Call module.dynamicImport(id) to fetch a module and any/all of its          // 4\n// dependencies that have not already been fetched, and evaluate them as       // 5\n// soon as they arrive. This runtime API makes it very easy to implement       // 6\n// ECMAScript dynamic import(...) syntax.                                      // 7\nModule.prototype.dynamicImport = function (id) {                               // 8\n  var module = this;                                                           // 9\n  return module.prefetch(id).then(function () {                                // 10\n    return getNamespace(module, id);                                           // 11\n  });                                                                          // 12\n};                                                                             // 13\n                                                                               // 14\n// Called by Module.prototype.prefetch if there are any missing dynamic        // 15\n// modules that need to be fetched.                                            // 16\nmeteorInstall.fetch = function (ids) {                                         // 17\n  var tree = Object.create(null);                                              // 18\n  var versions = Object.create(null);                                          // 19\n  var dynamicVersions = require(\"./dynamic-versions.js\");                      // 20\n  var missing;                                                                 // 21\n                                                                               // 22\n  Object.keys(ids).forEach(function (id) {                                     // 23\n    var version = dynamicVersions.get(id);                                     // 24\n    if (version) {                                                             // 25\n      versions[id] = version;                                                  // 26\n    } else {                                                                   // 27\n      addToTree(missing = missing || Object.create(null), id, 1);              // 28\n    }                                                                          // 29\n  });                                                                          // 30\n                                                                               // 31\n  return cache.checkMany(versions).then(function (sources) {                   // 32\n    Object.keys(sources).forEach(function (id) {                               // 33\n      var source = sources[id];                                                // 34\n      if (source) {                                                            // 35\n        var info = ids[id];                                                    // 36\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));     // 37\n      } else {                                                                 // 38\n        addToTree(missing = missing || Object.create(null), id, 1);            // 39\n      }                                                                        // 40\n    });                                                                        // 41\n                                                                               // 42\n    return missing && fetchMissing(missing).then(function (results) {          // 43\n      var versionsAndSourcesById = Object.create(null);                        // 44\n      var flatResults = flattenModuleTree(results);                            // 45\n                                                                               // 46\n      Object.keys(flatResults).forEach(function (id) {                         // 47\n        var source = flatResults[id];                                          // 48\n        var info = ids[id];                                                    // 49\n                                                                               // 50\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));     // 51\n                                                                               // 52\n        var version = dynamicVersions.get(id);                                 // 53\n        if (version) {                                                         // 54\n          versionsAndSourcesById[id] = {                                       // 55\n            version: version,                                                  // 56\n            source: source                                                     // 57\n          };                                                                   // 58\n        }                                                                      // 59\n      });                                                                      // 60\n                                                                               // 61\n      cache.setMany(versionsAndSourcesById);                                   // 62\n    });                                                                        // 63\n                                                                               // 64\n  }).then(function () {                                                        // 65\n    return tree;                                                               // 66\n  });                                                                          // 67\n};                                                                             // 68\n                                                                               // 69\nfunction flattenModuleTree(tree) {                                             // 70\n  var parts = [\"\"];                                                            // 71\n  var result = Object.create(null);                                            // 72\n                                                                               // 73\n  function walk(t) {                                                           // 74\n    if (t && typeof t === \"object\") {                                          // 75\n      Object.keys(t).forEach(function (key) {                                  // 76\n        parts.push(key);                                                       // 77\n        walk(t[key]);                                                          // 78\n        parts.pop();                                                           // 79\n      });                                                                      // 80\n    } else if (typeof t === \"string\") {                                        // 81\n      result[parts.join(\"/\")] = t;                                             // 82\n    }                                                                          // 83\n  }                                                                            // 84\n                                                                               // 85\n  walk(tree);                                                                  // 86\n                                                                               // 87\n  return result;                                                               // 88\n}                                                                              // 89\n                                                                               // 90\nfunction makeModuleFunction(id, source, options) {                             // 91\n  // By calling (options && options.eval || eval) in a wrapper function,       // 92\n  // we delay the cost of parsing and evaluating the module code until the     // 93\n  // module is first imported.                                                 // 94\n  return function () {                                                         // 95\n    // If an options.eval function was provided in the second argument to      // 96\n    // meteorInstall when this bundle was first installed, use that            // 97\n    // function to parse and evaluate the dynamic module code in the scope     // 98\n    // of the package. Otherwise fall back to indirect (global) eval.          // 99\n    return (options && options.eval || eval)(                                  // 100\n      // Wrap the function(require,exports,module){...} expression in          // 101\n      // parentheses to force it to be parsed as an expression.                // 102\n      \"(\" + source + \")\\n//# sourceURL=\" + id                                  // 103\n    ).apply(this, arguments);                                                  // 104\n  };                                                                           // 105\n}                                                                              // 106\n                                                                               // 107\nfunction fetchMissing(missingTree) {                                           // 108\n  // Update lastFetchMissingPromise immediately, without waiting for           // 109\n  // the results to be delivered.                                              // 110\n  return new Promise(function (resolve, reject) {                              // 111\n    Meteor.call(                                                               // 112\n      \"__dynamicImport\",                                                       // 113\n      missingTree,                                                             // 114\n      function (error, resultsTree) {                                          // 115\n        error ? reject(error) : resolve(resultsTree);                          // 116\n      }                                                                        // 117\n    );                                                                         // 118\n  });                                                                          // 119\n}                                                                              // 120\n                                                                               // 121\nfunction addToTree(tree, id, value) {                                          // 122\n  var parts = id.split(\"/\");                                                   // 123\n  var lastIndex = parts.length - 1;                                            // 124\n  parts.forEach(function (part, i) {                                           // 125\n    if (part) {                                                                // 126\n      tree = tree[part] = tree[part] ||                                        // 127\n        (i < lastIndex ? Object.create(null) : value);                         // 128\n    }                                                                          // 129\n  });                                                                          // 130\n}                                                                              // 131\n                                                                               // 132\nfunction getNamespace(module, id) {                                            // 133\n  var namespace;                                                               // 134\n                                                                               // 135\n  module.watch(module.require(id), {                                           // 136\n    \"*\": function (ns) {                                                       // 137\n      namespace = ns;                                                          // 138\n    }                                                                          // 139\n  });                                                                          // 140\n                                                                               // 141\n  // This helps with Babel interop, since we're not just returning the         // 142\n  // module.exports object.                                                    // 143\n  Object.defineProperty(namespace, \"__esModule\", {                             // 144\n    value: true,                                                               // 145\n    enumerable: false                                                          // 146\n  });                                                                          // 147\n                                                                               // 148\n  return namespace;                                                            // 149\n}                                                                              // 150\n                                                                               // 151\n/////////////////////////////////////////////////////////////////////////////////\n\n},\"cache.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/cache.js                                            //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nvar hasOwn = Object.prototype.hasOwnProperty;                                  // 1\nvar dbPromise;                                                                 // 2\n                                                                               // 3\nvar canUseCache =                                                              // 4\n  // The server doesn't benefit from dynamic module fetching, and almost       // 5\n  // certainly doesn't support IndexedDB.                                      // 6\n  Meteor.isClient &&                                                           // 7\n  // Cordova bundles all modules into the monolithic initial bundle, so        // 8\n  // the dynamic module cache won't be necessary.                              // 9\n  ! Meteor.isCordova &&                                                        // 10\n  // Caching can be confusing in development, and is designed to be a          // 11\n  // transparent optimization for production performance.                      // 12\n  Meteor.isProduction;                                                         // 13\n                                                                               // 14\nfunction getIDB() {                                                            // 15\n  if (typeof indexedDB !== \"undefined\") return indexedDB;                      // 16\n  if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;          // 17\n  if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;                // 18\n  if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;                    // 19\n  if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;                  // 20\n}                                                                              // 21\n                                                                               // 22\nfunction withDB(callback) {                                                    // 23\n  dbPromise = dbPromise || new Promise(function (resolve, reject) {            // 24\n    var idb = getIDB();                                                        // 25\n    if (! idb) {                                                               // 26\n      throw new Error(\"IndexedDB not available\");                              // 27\n    }                                                                          // 28\n                                                                               // 29\n    // Incrementing the version number causes all existing object stores       // 30\n    // to be deleted and recreates those specified by objectStoreMap.          // 31\n    var request = idb.open(\"MeteorDynamicImportCache\", 2);                     // 32\n                                                                               // 33\n    request.onupgradeneeded = function (event) {                               // 34\n      var db = event.target.result;                                            // 35\n                                                                               // 36\n      // It's fine to delete existing object stores since onupgradeneeded      // 37\n      // is only called when we change the DB version number, and the data     // 38\n      // we're storing is disposable/reconstructible.                          // 39\n      Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);       // 40\n                                                                               // 41\n      Object.keys(objectStoreMap).forEach(function (name) {                    // 42\n        db.createObjectStore(name, objectStoreMap[name]);                      // 43\n      });                                                                      // 44\n    };                                                                         // 45\n                                                                               // 46\n    request.onerror = makeOnError(reject, \"indexedDB.open\");                   // 47\n    request.onsuccess = function (event) {                                     // 48\n      resolve(event.target.result);                                            // 49\n    };                                                                         // 50\n  });                                                                          // 51\n                                                                               // 52\n  return dbPromise.then(callback, function (error) {                           // 53\n    return callback(null);                                                     // 54\n  });                                                                          // 55\n}                                                                              // 56\n                                                                               // 57\nvar objectStoreMap = {                                                         // 58\n  sourcesByVersion: { keyPath: \"version\" }                                     // 59\n};                                                                             // 60\n                                                                               // 61\nfunction makeOnError(reject, source) {                                         // 62\n  return function (event) {                                                    // 63\n    reject(new Error(                                                          // 64\n      \"IndexedDB failure in \" + source + \" \" +                                 // 65\n        JSON.stringify(event.target)                                           // 66\n    ));                                                                        // 67\n                                                                               // 68\n    // Returning true from an onerror callback function prevents an            // 69\n    // InvalidStateError in Firefox during Private Browsing. Silencing         // 70\n    // that error is safe because we handle the error more gracefully by       // 71\n    // passing it to the Promise reject function above.                        // 72\n    // https://github.com/meteor/meteor/issues/8697                            // 73\n    return true;                                                               // 74\n  };                                                                           // 75\n}                                                                              // 76\n                                                                               // 77\nvar checkCount = 0;                                                            // 78\n                                                                               // 79\nexports.checkMany = function (versions) {                                      // 80\n  var ids = Object.keys(versions);                                             // 81\n  var sourcesById = Object.create(null);                                       // 82\n                                                                               // 83\n  // Initialize sourcesById with null values to indicate all sources are       // 84\n  // missing (unless replaced with actual sources below).                      // 85\n  ids.forEach(function (id) {                                                  // 86\n    sourcesById[id] = null;                                                    // 87\n  });                                                                          // 88\n                                                                               // 89\n  if (! canUseCache) {                                                         // 90\n    return Promise.resolve(sourcesById);                                       // 91\n  }                                                                            // 92\n                                                                               // 93\n  return withDB(function (db) {                                                // 94\n    if (! db) {                                                                // 95\n      // We thought we could used IndexedDB, but something went wrong          // 96\n      // while opening the database, so err on the side of safety.             // 97\n      return sourcesById;                                                      // 98\n    }                                                                          // 99\n                                                                               // 100\n    var txn = db.transaction([                                                 // 101\n      \"sourcesByVersion\"                                                       // 102\n    ], \"readonly\");                                                            // 103\n                                                                               // 104\n    var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");                // 105\n                                                                               // 106\n    ++checkCount;                                                              // 107\n                                                                               // 108\n    function finish() {                                                        // 109\n      --checkCount;                                                            // 110\n      return sourcesById;                                                      // 111\n    }                                                                          // 112\n                                                                               // 113\n    return Promise.all(ids.map(function (id) {                                 // 114\n      return new Promise(function (resolve, reject) {                          // 115\n        var version = versions[id];                                            // 116\n        if (version) {                                                         // 117\n          var sourceRequest = sourcesByVersion.get(version);                   // 118\n          sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");\n          sourceRequest.onsuccess = function (event) {                         // 120\n            var result = event.target.result;                                  // 121\n            if (result) {                                                      // 122\n              sourcesById[id] = result.source;                                 // 123\n            }                                                                  // 124\n            resolve();                                                         // 125\n          };                                                                   // 126\n        } else resolve();                                                      // 127\n      });                                                                      // 128\n    })).then(finish, finish);                                                  // 129\n  });                                                                          // 130\n};                                                                             // 131\n                                                                               // 132\nvar pendingVersionsAndSourcesById = Object.create(null);                       // 133\n                                                                               // 134\nexports.setMany = function (versionsAndSourcesById) {                          // 135\n  if (canUseCache) {                                                           // 136\n    Object.assign(                                                             // 137\n      pendingVersionsAndSourcesById,                                           // 138\n      versionsAndSourcesById                                                   // 139\n    );                                                                         // 140\n                                                                               // 141\n    // Delay the call to flushSetMany so that it doesn't contribute to the     // 142\n    // amount of time it takes to call module.dynamicImport.                   // 143\n    if (! flushSetMany.timer) {                                                // 144\n      flushSetMany.timer = setTimeout(flushSetMany, 100);                      // 145\n    }                                                                          // 146\n  }                                                                            // 147\n};                                                                             // 148\n                                                                               // 149\nfunction flushSetMany() {                                                      // 150\n  if (checkCount > 0) {                                                        // 151\n    // If checkMany is currently underway, postpone the flush until later,     // 152\n    // since updating the cache is less important than reading from it.        // 153\n    return flushSetMany.timer = setTimeout(flushSetMany, 100);                 // 154\n  }                                                                            // 155\n                                                                               // 156\n  flushSetMany.timer = null;                                                   // 157\n                                                                               // 158\n  var versionsAndSourcesById = pendingVersionsAndSourcesById;                  // 159\n  pendingVersionsAndSourcesById = Object.create(null);                         // 160\n                                                                               // 161\n  return withDB(function (db) {                                                // 162\n    if (! db) {                                                                // 163\n      // We thought we could used IndexedDB, but something went wrong          // 164\n      // while opening the database, so err on the side of safety.             // 165\n      return;                                                                  // 166\n    }                                                                          // 167\n                                                                               // 168\n    var setTxn = db.transaction([                                              // 169\n      \"sourcesByVersion\"                                                       // 170\n    ], \"readwrite\");                                                           // 171\n                                                                               // 172\n    var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");             // 173\n                                                                               // 174\n    return Promise.all(                                                        // 175\n      Object.keys(versionsAndSourcesById).map(function (id) {                  // 176\n        var info = versionsAndSourcesById[id];                                 // 177\n        return new Promise(function (resolve, reject) {                        // 178\n          var request = sourcesByVersion.put({                                 // 179\n            version: info.version,                                             // 180\n            source: info.source                                                // 181\n          });                                                                  // 182\n          request.onerror = makeOnError(reject, \"sourcesByVersion.put\");       // 183\n          request.onsuccess = resolve;                                         // 184\n        });                                                                    // 185\n      })                                                                       // 186\n    );                                                                         // 187\n  });                                                                          // 188\n}                                                                              // 189\n                                                                               // 190\n/////////////////////////////////////////////////////////////////////////////////\n\n},\"dynamic-versions.js\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/dynamic-versions.js                                 //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\n// This magic double-underscored identifier gets replaced in                   // 1\n// tools/isobuild/bundler.js with a tree of hashes of all dynamic              // 2\n// modules, for use in client.js and cache.js.                                 // 3\nvar versions = __DYNAMIC_VERSIONS__;                                           // 4\n                                                                               // 5\nexports.get = function (id) {                                                  // 6\n  var tree = versions;                                                         // 7\n  var version = null;                                                          // 8\n                                                                               // 9\n  id.split(\"/\").some(function (part) {                                         // 10\n    if (part) {                                                                // 11\n      // If the tree contains identifiers for Meteor packages with colons      // 12\n      // in their names, the colons should not have been replaced by           // 13\n      // underscores, but there's a bug that results in that behavior, so      // 14\n      // for now it seems safest to be tolerant of underscores here.           // 15\n      // https://github.com/meteor/meteor/pull/9103                            // 16\n      tree = tree[part] || tree[part.replace(\":\", \"_\")];                       // 17\n    }                                                                          // 18\n                                                                               // 19\n    if (! tree) {                                                              // 20\n      // Terminate the search without reassigning version.                     // 21\n      return true;                                                             // 22\n    }                                                                          // 23\n                                                                               // 24\n    if (typeof tree === \"string\") {                                            // 25\n      version = tree;                                                          // 26\n      return true;                                                             // 27\n    }                                                                          // 28\n  });                                                                          // 29\n                                                                               // 30\n  return version;                                                              // 31\n};                                                                             // 32\n                                                                               // 33\n/////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"./node_modules/meteor/dynamic-import/client.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['dynamic-import'] = exports;\n\n})();\n","servePath":"/packages/dynamic-import.js"}]