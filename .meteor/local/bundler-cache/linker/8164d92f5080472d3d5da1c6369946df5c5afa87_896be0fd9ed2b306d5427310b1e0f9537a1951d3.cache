[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar HTTP, _methodHTTP, Fiber, runServerMethod;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/cfs_http-methods/http.methods.server.api.js                                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n/*\n\nGET /note\nGET /note/:id\nPOST /note\nPUT /note/:id\nDELETE /note/:id\n\n*/\nHTTP = Package.http && Package.http.HTTP || {};\n\n// Primary local test scope\n_methodHTTP = {};\n\n\n_methodHTTP.methodHandlers = {};\n_methodHTTP.methodTree = {};\n\n// This could be changed eg. could allow larger data chunks than 1.000.000\n// 5mb = 5 * 1024 * 1024 = 5242880;\nHTTP.methodsMaxDataLength = 5242880; //1e6;\n\n_methodHTTP.nameFollowsConventions = function(name) {\n  // Check that name is string, not a falsy or empty\n  return name && name === '' + name && name !== '';\n};\n\n\n_methodHTTP.getNameList = function(name) {\n  // Remove leading and trailing slashes and make command array\n  name = name && name.replace(/^\\//g, '') || ''; // /^\\/|\\/$/g\n  // TODO: Get the format from the url - eg.: \"/list/45.json\" format should be\n  // set in this function by splitting the last list item by . and have format\n  // as the last item. How should we toggle:\n  // \"/list/45/item.name.json\" and \"/list/45/item.name\"?\n  // We would either have to check all known formats or allways determin the \".\"\n  // as an extension. Resolving in \"json\" and \"name\" as handed format - the user\n  // Could simply just add the format as a parametre? or be explicit about\n  // naming\n  return name && name.split('/') || [];\n};\n\n// Merge two arrays one containing keys and one values\n_methodHTTP.createObject = function(keys, values) {\n  var result = {};\n  if (keys && values) {\n    for (var i = 0; i < keys.length; i++) {\n      result[keys[i]] = values[i] && decodeURIComponent(values[i]) || '';\n    }\n  }\n  return result;\n};\n\n_methodHTTP.addToMethodTree = function(methodName) {\n  var list = _methodHTTP.getNameList(methodName);\n  var name = '/';\n  // Contains the list of params names\n  var params = [];\n  var currentMethodTree = _methodHTTP.methodTree;\n\n  for (var i = 0; i < list.length; i++) {\n\n    // get the key name\n    var key = list[i];\n    // Check if it expects a value\n    if (key[0] === ':') {\n      // This is a value\n      params.push(key.slice(1));\n      key = ':value';\n    }\n    name += key + '/';\n\n    // Set the key into the method tree\n    if (typeof currentMethodTree[key] === 'undefined') {\n      currentMethodTree[key] = {};\n    }\n\n    // Dig deeper\n    currentMethodTree = currentMethodTree[key];\n\n  }\n\n  if (_.isEmpty(currentMethodTree[':ref'])) {\n    currentMethodTree[':ref'] = {\n      name: name,\n      params: params\n    };\n  }\n\n  return currentMethodTree[':ref'];\n};\n\n// This method should be optimized for speed since its called on allmost every\n// http call to the server so we return null as soon as we know its not a method\n_methodHTTP.getMethod = function(name) {\n  // Check if the\n  if (!_methodHTTP.nameFollowsConventions(name)) {\n    return null;\n  }\n  var list = _methodHTTP.getNameList(name);\n  // Check if we got a correct list\n  if (!list || !list.length) {\n    return null;\n  }\n  // Set current refernce in the _methodHTTP.methodTree\n  var currentMethodTree = _methodHTTP.methodTree;\n  // Buffer for values to hand on later\n  var values = [];\n  // Iterate over the method name and check if its found in the method tree\n  for (var i = 0; i < list.length; i++) {\n    // get the key name\n    var key = list[i];\n    // We expect to find the key or :value if not we break\n    if (typeof currentMethodTree[key] !== 'undefined' ||\n            typeof currentMethodTree[':value'] !== 'undefined') {\n      // We got a result now check if its a value\n      if (typeof currentMethodTree[key] === 'undefined') {\n        // Push the value\n        values.push(key);\n        // Set the key to :value to dig deeper\n        key = ':value';\n      }\n\n    } else {\n      // Break - method call not found\n      return null;\n    }\n\n    // Dig deeper\n    currentMethodTree = currentMethodTree[key];\n  }\n\n  // Extract reference pointer\n  var reference = currentMethodTree && currentMethodTree[':ref'];\n  if (typeof reference !== 'undefined') {\n    return {\n      name: reference.name,\n      params: _methodHTTP.createObject(reference.params, values),\n      handle: _methodHTTP.methodHandlers[reference.name]\n    };\n  } else {\n    // Did not get any reference to the method\n    return null;\n  }\n};\n\n// This method retrieves the userId from the token and makes sure that the token\n// is valid and not expired\n_methodHTTP.getUserId = function() {\n  var self = this;\n\n  // // Get ip, x-forwarded-for can be comma seperated ips where the first is the\n  // // client ip\n  // var ip = self.req.headers['x-forwarded-for'] &&\n  //         // Return the first item in ip list\n  //         self.req.headers['x-forwarded-for'].split(',')[0] ||\n  //         // or return the remoteAddress\n  //         self.req.connection.remoteAddress;\n\n  // Check authentication\n  var userToken = self.query.token;\n\n  // Check if we are handed strings\n  try {\n    userToken && check(userToken, String);\n  } catch(err) {\n    throw new Meteor.Error(404, 'Error user token and id not of type strings, Error: ' + (err.stack || err.message));\n  }\n\n  // Set the this.userId\n  if (userToken) {\n    // Look up user to check if user exists and is loggedin via token\n    var user = Meteor.users.findOne({\n        $or: [\n          {'services.resume.loginTokens.hashedToken': Accounts._hashLoginToken(userToken)},\n          {'services.resume.loginTokens.token': userToken}\n        ]\n      });\n    // TODO: check 'services.resume.loginTokens.when' to have the token expire\n\n    // Set the userId in the scope\n    return user && user._id;\n  }\n\n  return null;\n};\n\n// Expose the default auth for calling from custom authentication handlers.\nHTTP.defaultAuth = _methodHTTP.getUserId;\n\n/*\n\nAdd default support for options\n\n*/\n_methodHTTP.defaultOptionsHandler = function(methodObject) {\n  // List of supported methods\n  var allowMethods = [];\n  // The final result object\n  var result = {};\n\n  // Iterate over the methods\n  // XXX: We should have a way to extend this - We should have some schema model\n  // for our methods...\n  _.each(methodObject, function(f, methodName) {\n    // Skip the stream and auth functions - they are not public / accessible\n    if (methodName !== 'stream' && methodName !== 'auth') {\n\n      // Create an empty description\n      result[methodName] = { description: '', parameters: {} };\n      // Add method name to headers\n      allowMethods.push(methodName);\n\n    }\n  });\n\n  // Lets play nice\n  this.setStatusCode(200);\n\n  // We have to set some allow headers here\n  this.addHeader('Allow', allowMethods.join(','));\n\n  // Return json result - Pretty print\n  return JSON.stringify(result, null, '\\t');\n};\n\n// Public interface for adding server-side http methods - if setting a method to\n// 'false' it would actually remove the method (can be used to unpublish a method)\nHTTP.methods = function(newMethods) {\n  _.each(newMethods, function(func, name) {\n    if (_methodHTTP.nameFollowsConventions(name)) {\n      // Check if we got a function\n      //if (typeof func === 'function') {\n        var method = _methodHTTP.addToMethodTree(name);\n        // The func is good\n        if (typeof _methodHTTP.methodHandlers[method.name] !== 'undefined') {\n          if (func === false) {\n            // If the method is set to false then unpublish\n            delete _methodHTTP.methodHandlers[method.name];\n            // Delete the reference in the _methodHTTP.methodTree\n            delete method.name;\n            delete method.params;\n          } else {\n            // We should not allow overwriting - following Meteor.methods\n            throw new Error('HTTP method \"' + name + '\" is already registered');\n          }\n        } else {\n          // We could have a function or a object\n          // The object could have:\n          // '/test/': {\n          //   auth: function() ... returning the userId using over default\n          //\n          //   method: function() ...\n          //   or\n          //   post: function() ...\n          //   put:\n          //   get:\n          //   delete:\n          //   head:\n          // }\n\n          /*\n          We conform to the object format:\n          {\n            auth:\n            post:\n            put:\n            get:\n            delete:\n            head:\n          }\n          This way we have a uniform reference\n          */\n\n          var uniObj = {};\n          if (typeof func === 'function') {\n            uniObj = {\n              'auth': _methodHTTP.getUserId,\n              'stream': false,\n              'POST': func,\n              'PUT': func,\n              'GET': func,\n              'DELETE': func,\n              'HEAD': func,\n              'OPTIONS': _methodHTTP.defaultOptionsHandler\n            };\n          } else {\n            uniObj = {\n              'stream': func.stream || false,\n              'auth': func.auth || _methodHTTP.getUserId,\n              'POST': func.post || func.method,\n              'PUT': func.put || func.method,\n              'GET': func.get || func.method,\n              'DELETE': func.delete || func.method,\n              'HEAD': func.head || func.get || func.method,\n              'OPTIONS': func.options || _methodHTTP.defaultOptionsHandler\n            };\n          }\n\n          // Registre the method\n          _methodHTTP.methodHandlers[method.name] = uniObj; // func;\n\n        }\n      // } else {\n      //   // We do require a function as a function to execute later\n      //   throw new Error('HTTP.methods failed: ' + name + ' is not a function');\n      // }\n    } else {\n      // We have to follow the naming spec defined in nameFollowsConventions\n      throw new Error('HTTP.method \"' + name + '\" invalid naming of method');\n    }\n  });\n};\n\nvar sendError = function(res, code, message) {\n  if (code) {\n    res.writeHead(code);\n  } else {\n    res.writeHead(500);\n  }\n  res.end(message);\n};\n\n// This handler collects the header data into either an object (if json) or the\n// raw data. The data is passed to the callback\nvar requestHandler = function(req, res, callback) {\n  if (typeof callback !== 'function') {\n    return null;\n  }\n\n  // Container for buffers and a sum of the length\n  var bufferData = [], dataLen = 0;\n\n  // Extract the body\n  req.on('data', function(data) {\n    bufferData.push(data);\n    dataLen += data.length;\n\n    // We have to check the data length in order to spare the server\n    if (dataLen > HTTP.methodsMaxDataLength) {\n      dataLen = 0;\n      bufferData = [];\n      // Flood attack or faulty client\n      sendError(res, 413, 'Flood attack or faulty client');\n      req.connection.destroy();\n    }\n  });\n\n  // When message is ready to be passed on\n  req.on('end', function() {\n    if (res.finished) {\n      return;\n    }\n\n    // Allow the result to be undefined if so\n    var result;\n\n    // If data found the work it - either buffer or json\n    if (dataLen > 0) {\n      result = new Buffer(dataLen);\n      // Merge the chunks into one buffer\n      for (var i = 0, ln = bufferData.length, pos = 0; i < ln; i++) {\n        bufferData[i].copy(result, pos);\n        pos += bufferData[i].length;\n        delete bufferData[i];\n      }\n      // Check if we could be dealing with json\n      if (result[0] == 0x7b && result[1] === 0x22) {\n        try {\n          // Convert the body into json and extract the data object\n          result = EJSON.parse(result.toString());\n        } catch(err) {\n          // Could not parse so we return the raw data\n        }\n      }\n    } // Else result will be undefined\n\n    try {\n      callback(result);\n    } catch(err) {\n      sendError(res, 500, 'Error in requestHandler callback, Error: ' + (err.stack || err.message) );\n    }\n  });\n\n};\n\n// This is the simplest handler - it simply passes req stream as data to the\n// method\nvar streamHandler = function(req, res, callback) {\n  try {\n    callback();\n  } catch(err) {\n    sendError(res, 500, 'Error in requestHandler callback, Error: ' + (err.stack || err.message) );\n  }\n};\n\n/*\n  Allow file uploads in cordova cfs\n*/\nvar setCordovaHeaders = function(request, response) {\n  var origin = request.headers.origin;\n  // Match http://localhost:<port> for Cordova clients in Meteor 1.3\n  // and http://meteor.local for earlier versions\n  if (origin && (origin === 'http://meteor.local' || /^http:\\/\\/localhost/.test(origin))) {\n    // We need to echo the origin provided in the request\n    response.setHeader(\"Access-Control-Allow-Origin\", origin);\n\n    response.setHeader(\"Access-Control-Allow-Methods\", \"PUT\");\n    response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type\");\n  }\n};\n\n// Handle the actual connection\nWebApp.connectHandlers.use(function(req, res, next) {\n\n  // Check to se if this is a http method call\n  var method = _methodHTTP.getMethod(req._parsedUrl.pathname);\n\n  // If method is null then it wasn't and we pass the request along\n  if (method === null) {\n    return next();\n  }\n\n  var dataHandle = (method.handle && method.handle.stream)?streamHandler:requestHandler;\n\n  dataHandle(req, res, function(data) {\n    // If methodsHandler not found or somehow the methodshandler is not a\n    // function then return a 404\n    if (typeof method.handle === 'undefined') {\n      sendError(res, 404, 'Error HTTP method handler \"' + method.name + '\" is not found');\n      return;\n    }\n\n    // Set CORS headers for Meteor Cordova clients\n    setCordovaHeaders(req, res);\n\n    // Set fiber scope\n    var fiberScope = {\n      // Pointers to Request / Response\n      req: req,\n      res: res,\n      // Request / Response helpers\n      statusCode: 200,\n      method: req.method,\n      // Headers for response\n      headers: {\n        'Content-Type': 'text/html'  // Set default type\n      },\n      // Arguments\n      data: data,\n      query: req.query,\n      params: method.params,\n      // Method reference\n      reference: method.name,\n      methodObject: method.handle,\n      _streamsWaiting: 0\n    };\n\n    // Helper functions this scope\n    Fiber = Npm.require('fibers');\n    runServerMethod = Fiber(function(self) {\n      var result, resultBuffer;\n\n      // We fetch methods data from methodsHandler, the handler uses the this.addItem()\n      // function to populate the methods, this way we have better check control and\n      // better error handling + messages\n\n      // The scope for the user methodObject callbacks\n      var thisScope = {\n        // The user whos id and token was used to run this method, if set/found\n        userId: null,\n        // The id of the data\n        _id: null,\n        // Set the query params ?token=1&id=2 -> { token: 1, id: 2 }\n        query: self.query,\n        // Set params /foo/:name/test/:id -> { name: '', id: '' }\n        params: self.params,\n        // Method GET, PUT, POST, DELETE, HEAD\n        method: self.method,\n        // User agent\n        userAgent: req.headers['user-agent'],\n        // All request headers\n        requestHeaders: req.headers,\n        // Add the request object it self\n        request: req,\n        // Set the userId\n        setUserId: function(id) {\n          this.userId = id;\n        },\n        // We dont simulate / run this on the client at the moment\n        isSimulation: false,\n        // Run the next method in a new fiber - This is default at the moment\n        unblock: function() {},\n        // Set the content type in header, defaults to text/html?\n        setContentType: function(type) {\n          self.headers['Content-Type'] = type;\n        },\n        setStatusCode: function(code) {\n          self.statusCode = code;\n        },\n        addHeader: function(key, value) {\n          self.headers[key] = value;\n        },\n        createReadStream: function() {\n          self._streamsWaiting++;\n          return req;\n        },\n        createWriteStream: function() {\n          self._streamsWaiting++;\n          return res;\n        },\n        Error: function(err) {\n\n          if (err instanceof Meteor.Error) {\n            // Return controlled error\n            sendError(res, err.error, err.message);\n          } else if (err instanceof Error) {\n            // Return error trace - this is not intented\n            sendError(res, 503, 'Error in method \"' + self.reference + '\", Error: ' + (err.stack || err.message) );\n          } else {\n            sendError(res, 503, 'Error in method \"' + self.reference + '\"' );\n          }\n\n        },\n        // getData: function() {\n        //   // XXX: TODO if we could run the request handler stuff eg.\n        //   // in here in a fiber sync it could be cool - and the user did\n        //   // not have to specify the stream=true flag?\n        // }\n      };\n\n      // This function sends the final response. Depending on the\n      // timing of the streaming, we might have to wait for all\n      // streaming to end, or we might have to wait for this function\n      // to finish after streaming ends. The checks in this function\n      // and the fact that we call it twice ensure that we will always\n      // send the response if we haven't sent an error response, but\n      // we will not send it too early.\n      function sendResponseIfDone() {\n        res.statusCode = self.statusCode;\n        // If no streams are waiting\n        if (self._streamsWaiting === 0 &&\n            (self.statusCode === 200 || self.statusCode === 206) &&\n            self.done &&\n            !self._responseSent &&\n            !res.finished) {\n          self._responseSent = true;\n          res.end(resultBuffer);\n        }\n      }\n\n      var methodCall = self.methodObject[self.method];\n\n      // If the method call is set for the POST/PUT/GET or DELETE then run the\n      // respective methodCall if its a function\n      if (typeof methodCall === 'function') {\n\n        // Get the userId - This is either set as a method specific handler and\n        // will allways default back to the builtin getUserId handler\n        try {\n          // Try to set the userId\n          thisScope.userId = self.methodObject.auth.apply(self);\n        } catch(err) {\n          sendError(res, err.error, (err.message || err.stack));\n          return;\n        }\n\n        // This must be attached before there's any chance of `createReadStream`\n        // or `createWriteStream` being called, which means before we do\n        // `methodCall.apply` below.\n        req.on('end', function() {\n          self._streamsWaiting--;\n          sendResponseIfDone();\n        });\n\n        // Get the result of the methodCall\n        try {\n          if (self.method === 'OPTIONS') {\n            result = methodCall.apply(thisScope, [self.methodObject]) || '';\n          } else {\n            result = methodCall.apply(thisScope, [self.data]) || '';\n          }\n        } catch(err) {\n          if (err instanceof Meteor.Error) {\n            // Return controlled error\n            sendError(res, err.error, err.message);\n          } else {\n            // Return error trace - this is not intented\n            sendError(res, 503, 'Error in method \"' + self.reference + '\", Error: ' + (err.stack || err.message) );\n          }\n          return;\n        }\n\n        // Set headers\n        _.each(self.headers, function(value, key) {\n          // If value is defined then set the header, this allows for unsetting\n          // the default content-type\n          if (typeof value !== 'undefined')\n            res.setHeader(key, value);\n        });\n\n        // If OK / 200 then Return the result\n        if (self.statusCode === 200 || self.statusCode === 206) {\n\n          if (self.method !== \"HEAD\") {\n            // Return result\n            if (typeof result === 'string') {\n              resultBuffer = new Buffer(result);\n            } else {\n              resultBuffer = new Buffer(JSON.stringify(result));\n            }\n\n            // Check if user wants to overwrite content length for some reason?\n            if (typeof self.headers['Content-Length'] === 'undefined') {\n              self.headers['Content-Length'] = resultBuffer.length;\n            }\n\n          }\n\n          self.done = true;\n          sendResponseIfDone();\n\n        } else {\n          // Allow user to alter the status code and send a message\n          sendError(res, self.statusCode, result);\n        }\n\n      } else {\n        sendError(res, 404, 'Service not found');\n      }\n\n\n    });\n    // Run http methods handler\n    try {\n      runServerMethod.run(fiberScope);\n    } catch(err) {\n      sendError(res, 500, 'Error running the server http method handler, Error: ' + (err.stack || err.message));\n    }\n\n  }); // EO Request handler\n\n\n});\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['cfs:http-methods'] = {}, {\n  HTTP: HTTP,\n  _methodHTTP: _methodHTTP\n});\n\n})();\n","servePath":"/packages/cfs_http-methods.js"}]