[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar MongoID = Package['mongo-id'].MongoID;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar ObserveSequence, seqChangedToEmpty, seqChangedToArray, seqChangedToCursor;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/observe-sequence/observe_sequence.js                                 //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nvar warn = function () {                                                         // 1\n  if (ObserveSequence._suppressWarnings) {                                       // 2\n    ObserveSequence._suppressWarnings--;                                         // 3\n  } else {                                                                       // 4\n    if (typeof console !== 'undefined' && console.warn)                          // 5\n      console.warn.apply(console, arguments);                                    // 6\n                                                                                 // 7\n    ObserveSequence._loggedWarnings++;                                           // 8\n  }                                                                              // 9\n};                                                                               // 10\n                                                                                 // 11\n// isArray returns true for arrays of these types:                               // 12\n// standard arrays: instanceof Array === true, _.isArray(arr) === true           // 13\n// vm generated arrays: instanceOf Array === false, _.isArray(arr) === true      // 14\n// subclassed arrays: instanceof Array === true, _.isArray(arr) === false        // 15\n// see specific tests                                                            // 16\nfunction isArray(arr) {                                                          // 17\n  return arr instanceof Array || _.isArray(arr);                                 // 18\n}                                                                                // 19\n                                                                                 // 20\nvar idStringify = MongoID.idStringify;                                           // 21\nvar idParse = MongoID.idParse;                                                   // 22\n                                                                                 // 23\nObserveSequence = {                                                              // 24\n  _suppressWarnings: 0,                                                          // 25\n  _loggedWarnings: 0,                                                            // 26\n                                                                                 // 27\n  // A mechanism similar to cursor.observe which receives a reactive             // 28\n  // function returning a sequence type and firing appropriate callbacks         // 29\n  // when the value changes.                                                     // 30\n  //                                                                             // 31\n  // @param sequenceFunc {Function} a reactive function returning a              // 32\n  //     sequence type. The currently supported sequence types are:              // 33\n  //     Array, Cursor, and null.                                                // 34\n  //                                                                             // 35\n  // @param callbacks {Object} similar to a specific subset of                   // 36\n  //     callbacks passed to `cursor.observe`                                    // 37\n  //     (http://docs.meteor.com/#observe), with minor variations to             // 38\n  //     support the fact that not all sequences contain objects with            // 39\n  //     _id fields.  Specifically:                                              // 40\n  //                                                                             // 41\n  //     * addedAt(id, item, atIndex, beforeId)                                  // 42\n  //     * changedAt(id, newItem, oldItem, atIndex)                              // 43\n  //     * removedAt(id, oldItem, atIndex)                                       // 44\n  //     * movedTo(id, item, fromIndex, toIndex, beforeId)                       // 45\n  //                                                                             // 46\n  // @returns {Object(stop: Function)} call 'stop' on the return value           // 47\n  //     to stop observing this sequence function.                               // 48\n  //                                                                             // 49\n  // We don't make any assumptions about our ability to compare sequence         // 50\n  // elements (ie, we don't assume EJSON.equals works; maybe there is extra      // 51\n  // state/random methods on the objects) so unlike cursor.observe, we may       // 52\n  // sometimes call changedAt() when nothing actually changed.                   // 53\n  // XXX consider if we *can* make the stronger assumption and avoid             // 54\n  //     no-op changedAt calls (in some cases?)                                  // 55\n  //                                                                             // 56\n  // XXX currently only supports the callbacks used by our                       // 57\n  // implementation of {{#each}}, but this can be expanded.                      // 58\n  //                                                                             // 59\n  // XXX #each doesn't use the indices (though we'll eventually need             // 60\n  // a way to get them when we support `@index`), but calling                    // 61\n  // `cursor.observe` causes the index to be calculated on every                 // 62\n  // callback using a linear scan (unless you turn it off by passing             // 63\n  // `_no_indices`).  Any way to avoid calculating indices on a pure             // 64\n  // cursor observe like we used to?                                             // 65\n  observe: function (sequenceFunc, callbacks) {                                  // 66\n    var lastSeq = null;                                                          // 67\n    var activeObserveHandle = null;                                              // 68\n                                                                                 // 69\n    // 'lastSeqArray' contains the previous value of the sequence                // 70\n    // we're observing. It is an array of objects with '_id' and                 // 71\n    // 'item' fields.  'item' is the element in the array, or the                // 72\n    // document in the cursor.                                                   // 73\n    //                                                                           // 74\n    // '_id' is whichever of the following is relevant, unless it has            // 75\n    // already appeared -- in which case it's randomly generated.                // 76\n    //                                                                           // 77\n    // * if 'item' is an object:                                                 // 78\n    //   * an '_id' field, if present                                            // 79\n    //   * otherwise, the index in the array                                     // 80\n    //                                                                           // 81\n    // * if 'item' is a number or string, use that value                         // 82\n    //                                                                           // 83\n    // XXX this can be generalized by allowing {{#each}} to accept a             // 84\n    // general 'key' argument which could be a function, a dotted                // 85\n    // field name, or the special @index value.                                  // 86\n    var lastSeqArray = []; // elements are objects of form {_id, item}           // 87\n    var computation = Tracker.autorun(function () {                              // 88\n      var seq = sequenceFunc();                                                  // 89\n                                                                                 // 90\n      Tracker.nonreactive(function () {                                          // 91\n        var seqArray; // same structure as `lastSeqArray` above.                 // 92\n                                                                                 // 93\n        if (activeObserveHandle) {                                               // 94\n          // If we were previously observing a cursor, replace lastSeqArray with\n          // more up-to-date information.  Then stop the old observe.            // 96\n          lastSeqArray = _.map(lastSeq.fetch(), function (doc) {                 // 97\n            return {_id: doc._id, item: doc};                                    // 98\n          });                                                                    // 99\n          activeObserveHandle.stop();                                            // 100\n          activeObserveHandle = null;                                            // 101\n        }                                                                        // 102\n                                                                                 // 103\n        if (!seq) {                                                              // 104\n          seqArray = seqChangedToEmpty(lastSeqArray, callbacks);                 // 105\n        } else if (isArray(seq)) {                                               // 106\n          seqArray = seqChangedToArray(lastSeqArray, seq, callbacks);            // 107\n        } else if (isStoreCursor(seq)) {                                         // 108\n          var result /* [seqArray, activeObserveHandle] */ =                     // 109\n                seqChangedToCursor(lastSeqArray, seq, callbacks);                // 110\n          seqArray = result[0];                                                  // 111\n          activeObserveHandle = result[1];                                       // 112\n        } else {                                                                 // 113\n          throw badSequenceError();                                              // 114\n        }                                                                        // 115\n                                                                                 // 116\n        diffArray(lastSeqArray, seqArray, callbacks);                            // 117\n        lastSeq = seq;                                                           // 118\n        lastSeqArray = seqArray;                                                 // 119\n      });                                                                        // 120\n    });                                                                          // 121\n                                                                                 // 122\n    return {                                                                     // 123\n      stop: function () {                                                        // 124\n        computation.stop();                                                      // 125\n        if (activeObserveHandle)                                                 // 126\n          activeObserveHandle.stop();                                            // 127\n      }                                                                          // 128\n    };                                                                           // 129\n  },                                                                             // 130\n                                                                                 // 131\n  // Fetch the items of `seq` into an array, where `seq` is of one of the        // 132\n  // sequence types accepted by `observe`.  If `seq` is a cursor, a              // 133\n  // dependency is established.                                                  // 134\n  fetch: function (seq) {                                                        // 135\n    if (!seq) {                                                                  // 136\n      return [];                                                                 // 137\n    } else if (isArray(seq)) {                                                   // 138\n      return seq;                                                                // 139\n    } else if (isStoreCursor(seq)) {                                             // 140\n      return seq.fetch();                                                        // 141\n    } else {                                                                     // 142\n      throw badSequenceError();                                                  // 143\n    }                                                                            // 144\n  }                                                                              // 145\n};                                                                               // 146\n                                                                                 // 147\nvar badSequenceError = function () {                                             // 148\n  return new Error(\"{{#each}} currently only accepts \" +                         // 149\n                   \"arrays, cursors or falsey values.\");                         // 150\n};                                                                               // 151\n                                                                                 // 152\nvar isStoreCursor = function (cursor) {                                          // 153\n  return cursor && _.isObject(cursor) &&                                         // 154\n    _.isFunction(cursor.observe) && _.isFunction(cursor.fetch);                  // 155\n};                                                                               // 156\n                                                                                 // 157\n// Calculates the differences between `lastSeqArray` and                         // 158\n// `seqArray` and calls appropriate functions from `callbacks`.                  // 159\n// Reuses Minimongo's diff algorithm implementation.                             // 160\nvar diffArray = function (lastSeqArray, seqArray, callbacks) {                   // 161\n  var diffFn = Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;    // 162\n  var oldIdObjects = [];                                                         // 163\n  var newIdObjects = [];                                                         // 164\n  var posOld = {}; // maps from idStringify'd ids                                // 165\n  var posNew = {}; // ditto                                                      // 166\n  var posCur = {};                                                               // 167\n  var lengthCur = lastSeqArray.length;                                           // 168\n                                                                                 // 169\n  _.each(seqArray, function (doc, i) {                                           // 170\n    newIdObjects.push({_id: doc._id});                                           // 171\n    posNew[idStringify(doc._id)] = i;                                            // 172\n  });                                                                            // 173\n  _.each(lastSeqArray, function (doc, i) {                                       // 174\n    oldIdObjects.push({_id: doc._id});                                           // 175\n    posOld[idStringify(doc._id)] = i;                                            // 176\n    posCur[idStringify(doc._id)] = i;                                            // 177\n  });                                                                            // 178\n                                                                                 // 179\n  // Arrays can contain arbitrary objects. We don't diff the                     // 180\n  // objects. Instead we always fire 'changedAt' callback on every               // 181\n  // object. The consumer of `observe-sequence` should deal with                 // 182\n  // it appropriately.                                                           // 183\n  diffFn(oldIdObjects, newIdObjects, {                                           // 184\n    addedBefore: function (id, doc, before) {                                    // 185\n      var position = before ? posCur[idStringify(before)] : lengthCur;           // 186\n                                                                                 // 187\n      if (before) {                                                              // 188\n        // If not adding at the end, we need to update indexes.                  // 189\n        // XXX this can still be improved greatly!                               // 190\n        _.each(posCur, function (pos, id) {                                      // 191\n          if (pos >= position)                                                   // 192\n            posCur[id]++;                                                        // 193\n        });                                                                      // 194\n      }                                                                          // 195\n                                                                                 // 196\n      lengthCur++;                                                               // 197\n      posCur[idStringify(id)] = position;                                        // 198\n                                                                                 // 199\n      callbacks.addedAt(                                                         // 200\n        id,                                                                      // 201\n        seqArray[posNew[idStringify(id)]].item,                                  // 202\n        position,                                                                // 203\n        before);                                                                 // 204\n    },                                                                           // 205\n    movedBefore: function (id, before) {                                         // 206\n      if (id === before)                                                         // 207\n        return;                                                                  // 208\n                                                                                 // 209\n      var oldPosition = posCur[idStringify(id)];                                 // 210\n      var newPosition = before ? posCur[idStringify(before)] : lengthCur;        // 211\n                                                                                 // 212\n      // Moving the item forward. The new element is losing one position as it   // 213\n      // was removed from the old position before being inserted at the new      // 214\n      // position.                                                               // 215\n      // Ex.:   0  *1*  2   3   4                                                // 216\n      //        0   2   3  *1*  4                                                // 217\n      // The original issued callback is \"1\" before \"4\".                         // 218\n      // The position of \"1\" is 1, the position of \"4\" is 4.                     // 219\n      // The generated move is (1) -> (3)                                        // 220\n      if (newPosition > oldPosition) {                                           // 221\n        newPosition--;                                                           // 222\n      }                                                                          // 223\n                                                                                 // 224\n      // Fix up the positions of elements between the old and the new positions  // 225\n      // of the moved element.                                                   // 226\n      //                                                                         // 227\n      // There are two cases:                                                    // 228\n      //   1. The element is moved forward. Then all the positions in between    // 229\n      //   are moved back.                                                       // 230\n      //   2. The element is moved back. Then the positions in between *and* the\n      //   element that is currently standing on the moved element's future      // 232\n      //   position are moved forward.                                           // 233\n      _.each(posCur, function (elCurPosition, id) {                              // 234\n        if (oldPosition < elCurPosition && elCurPosition < newPosition)          // 235\n          posCur[id]--;                                                          // 236\n        else if (newPosition <= elCurPosition && elCurPosition < oldPosition)    // 237\n          posCur[id]++;                                                          // 238\n      });                                                                        // 239\n                                                                                 // 240\n      // Finally, update the position of the moved element.                      // 241\n      posCur[idStringify(id)] = newPosition;                                     // 242\n                                                                                 // 243\n      callbacks.movedTo(                                                         // 244\n        id,                                                                      // 245\n        seqArray[posNew[idStringify(id)]].item,                                  // 246\n        oldPosition,                                                             // 247\n        newPosition,                                                             // 248\n        before);                                                                 // 249\n    },                                                                           // 250\n    removed: function (id) {                                                     // 251\n      var prevPosition = posCur[idStringify(id)];                                // 252\n                                                                                 // 253\n      _.each(posCur, function (pos, id) {                                        // 254\n        if (pos >= prevPosition)                                                 // 255\n          posCur[id]--;                                                          // 256\n      });                                                                        // 257\n                                                                                 // 258\n      delete posCur[idStringify(id)];                                            // 259\n      lengthCur--;                                                               // 260\n                                                                                 // 261\n      callbacks.removedAt(                                                       // 262\n        id,                                                                      // 263\n        lastSeqArray[posOld[idStringify(id)]].item,                              // 264\n        prevPosition);                                                           // 265\n    }                                                                            // 266\n  });                                                                            // 267\n                                                                                 // 268\n  _.each(posNew, function (pos, idString) {                                      // 269\n    var id = idParse(idString);                                                  // 270\n    if (_.has(posOld, idString)) {                                               // 271\n      // specifically for primitive types, compare equality before               // 272\n      // firing the 'changedAt' callback. otherwise, always fire it              // 273\n      // because doing a deep EJSON comparison is not guaranteed to              // 274\n      // work (an array can contain arbitrary objects, and 'transform'           // 275\n      // can be used on cursors). also, deep diffing is not                      // 276\n      // necessarily the most efficient (if only a specific subfield             // 277\n      // of the object is later accessed).                                       // 278\n      var newItem = seqArray[pos].item;                                          // 279\n      var oldItem = lastSeqArray[posOld[idString]].item;                         // 280\n                                                                                 // 281\n      if (typeof newItem === 'object' || newItem !== oldItem)                    // 282\n          callbacks.changedAt(id, newItem, oldItem, pos);                        // 283\n      }                                                                          // 284\n  });                                                                            // 285\n};                                                                               // 286\n                                                                                 // 287\nseqChangedToEmpty = function (lastSeqArray, callbacks) {                         // 288\n  return [];                                                                     // 289\n};                                                                               // 290\n                                                                                 // 291\nseqChangedToArray = function (lastSeqArray, array, callbacks) {                  // 292\n  var idsUsed = {};                                                              // 293\n  var seqArray = _.map(array, function (item, index) {                           // 294\n    var id;                                                                      // 295\n    if (typeof item === 'string') {                                              // 296\n      // ensure not empty, since other layers (eg DomRange) assume this as well  // 297\n      id = \"-\" + item;                                                           // 298\n    } else if (typeof item === 'number' ||                                       // 299\n               typeof item === 'boolean' ||                                      // 300\n               item === undefined ||                                             // 301\n               item === null) {                                                  // 302\n      id = item;                                                                 // 303\n    } else if (typeof item === 'object') {                                       // 304\n      id = (item && ('_id' in item)) ? item._id : index;                         // 305\n    } else {                                                                     // 306\n      throw new Error(\"{{#each}} doesn't support arrays with \" +                 // 307\n                      \"elements of type \" + typeof item);                        // 308\n    }                                                                            // 309\n                                                                                 // 310\n    var idString = idStringify(id);                                              // 311\n    if (idsUsed[idString]) {                                                     // 312\n      if (item && typeof item === 'object' && '_id' in item)                     // 313\n        warn(\"duplicate id \" + id + \" in\", array);                               // 314\n      id = Random.id();                                                          // 315\n    } else {                                                                     // 316\n      idsUsed[idString] = true;                                                  // 317\n    }                                                                            // 318\n                                                                                 // 319\n    return { _id: id, item: item };                                              // 320\n  });                                                                            // 321\n                                                                                 // 322\n  return seqArray;                                                               // 323\n};                                                                               // 324\n                                                                                 // 325\nseqChangedToCursor = function (lastSeqArray, cursor, callbacks) {                // 326\n  var initial = true; // are we observing initial data from cursor?              // 327\n  var seqArray = [];                                                             // 328\n                                                                                 // 329\n  var observeHandle = cursor.observe({                                           // 330\n    addedAt: function (document, atIndex, before) {                              // 331\n      if (initial) {                                                             // 332\n        // keep track of initial data so that we can diff once                   // 333\n        // we exit `observe`.                                                    // 334\n        if (before !== null)                                                     // 335\n          throw new Error(\"Expected initial data from observe in order\");        // 336\n        seqArray.push({ _id: document._id, item: document });                    // 337\n      } else {                                                                   // 338\n        callbacks.addedAt(document._id, document, atIndex, before);              // 339\n      }                                                                          // 340\n    },                                                                           // 341\n    changedAt: function (newDocument, oldDocument, atIndex) {                    // 342\n      callbacks.changedAt(newDocument._id, newDocument, oldDocument,             // 343\n                          atIndex);                                              // 344\n    },                                                                           // 345\n    removedAt: function (oldDocument, atIndex) {                                 // 346\n      callbacks.removedAt(oldDocument._id, oldDocument, atIndex);                // 347\n    },                                                                           // 348\n    movedTo: function (document, fromIndex, toIndex, before) {                   // 349\n      callbacks.movedTo(                                                         // 350\n        document._id, document, fromIndex, toIndex, before);                     // 351\n    }                                                                            // 352\n  });                                                                            // 353\n  initial = false;                                                               // 354\n                                                                                 // 355\n  return [seqArray, observeHandle];                                              // 356\n};                                                                               // 357\n                                                                                 // 358\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['observe-sequence'] = {}, {\n  ObserveSequence: ObserveSequence\n});\n\n})();\n","servePath":"/packages/observe-sequence.js"}]