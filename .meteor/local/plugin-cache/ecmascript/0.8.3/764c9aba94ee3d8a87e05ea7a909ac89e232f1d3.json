{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./namespace.js","imported":["DDP","LivedataTest"],"specifiers":[{"kind":"named","imported":"DDP","local":"DDP"},{"kind":"named","imported":"LivedataTest","local":"LivedataTest"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/ddp-client/stream_client_nodejs.js","filenameRelative":"packages/ddp-client/stream_client_nodejs.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ddp-client/stream_client_nodejs.js.map","sourceFileName":"packages/ddp-client/stream_client_nodejs.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"stream_client_nodejs"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar module1 = module;\nvar DDP = void 0,\n    LivedataTest = void 0;\nmodule1.watch(require(\"./namespace.js\"), {\n  DDP: function (v) {\n    DDP = v;\n  },\n  LivedataTest: function (v) {\n    LivedataTest = v;\n  }\n}, 0);\n\n// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = function () {\n  function ClientStream(endpoint, options) {\n    (0, _classCallCheck3.default)(this, ClientStream);\n    var self = this;\n    options = options || {};\n    self.options = Object.assign({\n      retry: true\n    }, options);\n    self.client = null; // created in _launchConnection\n\n    self.endpoint = endpoint;\n    self.headers = self.options.headers || {};\n    self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n    self._initCommon(self.options); //// Kickoff!\n\n\n    self._launchConnection();\n  } // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n\n\n  ClientStream.prototype.send = function () {\n    function send(data) {\n      var self = this;\n\n      if (self.currentStatus.connected) {\n        self.client.send(data);\n      }\n    }\n\n    return send;\n  }(); // Changes where this connection points\n\n\n  ClientStream.prototype._changeUrl = function () {\n    function _changeUrl(url) {\n      var self = this;\n      self.endpoint = url;\n    }\n\n    return _changeUrl;\n  }();\n\n  ClientStream.prototype._onConnect = function () {\n    function _onConnect(client) {\n      var self = this;\n\n      if (client !== self.client) {\n        // This connection is not from the last call to _launchConnection.\n        // But _launchConnection calls _cleanup which closes previous connections.\n        // It's our belief that this stifles future 'open' events, but maybe\n        // we are wrong?\n        throw new Error(\"Got open from inactive client \" + !!self.client);\n      }\n\n      if (self._forcedToDisconnect) {\n        // We were asked to disconnect between trying to open the connection and\n        // actually opening it. Let's just pretend this never happened.\n        self.client.close();\n        self.client = null;\n        return;\n      }\n\n      if (self.currentStatus.connected) {\n        // We already have a connection. It must have been the case that we\n        // started two parallel connection attempts (because we wanted to\n        // 'reconnect now' on a hanging connection and we had no way to cancel the\n        // connection attempt.) But this shouldn't happen (similarly to the client\n        // !== self.client check above).\n        throw new Error(\"Two parallel connections?\");\n      }\n\n      self._clearConnectionTimer(); // update status\n\n\n      self.currentStatus.status = \"connected\";\n      self.currentStatus.connected = true;\n      self.currentStatus.retryCount = 0;\n      self.statusChanged(); // fire resets. This must come after status change so that clients\n      // can call send from within a reset callback.\n\n      _.each(self.eventCallbacks.reset, function (callback) {\n        callback();\n      });\n    }\n\n    return _onConnect;\n  }();\n\n  ClientStream.prototype._cleanup = function () {\n    function _cleanup(maybeError) {\n      var self = this;\n\n      self._clearConnectionTimer();\n\n      if (self.client) {\n        var client = self.client;\n        self.client = null;\n        client.close();\n\n        _.each(self.eventCallbacks.disconnect, function (callback) {\n          callback(maybeError);\n        });\n      }\n    }\n\n    return _cleanup;\n  }();\n\n  ClientStream.prototype._clearConnectionTimer = function () {\n    function _clearConnectionTimer() {\n      var self = this;\n\n      if (self.connectionTimer) {\n        clearTimeout(self.connectionTimer);\n        self.connectionTimer = null;\n      }\n    }\n\n    return _clearConnectionTimer;\n  }();\n\n  ClientStream.prototype._getProxyUrl = function () {\n    function _getProxyUrl(targetUrl) {\n      var self = this; // Similar to code in tools/http-helpers.js.\n\n      var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null; // if we're going to a secure url, try the https_proxy env variable first.\n\n      if (targetUrl.match(/^wss:/)) {\n        proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n      }\n\n      return proxy;\n    }\n\n    return _getProxyUrl;\n  }();\n\n  ClientStream.prototype._launchConnection = function () {\n    function _launchConnection() {\n      var self = this;\n\n      self._cleanup(); // cleanup the old socket, if there was one.\n      // Since server-to-server DDP is still an experimental feature, we only\n      // require the module if we actually create a server-to-server\n      // connection.\n\n\n      var FayeWebSocket = Npm.require('faye-websocket');\n\n      var deflate = Npm.require('permessage-deflate');\n\n      var targetUrl = toWebsocketUrl(self.endpoint);\n      var fayeOptions = {\n        headers: self.headers,\n        extensions: [deflate]\n      };\n      fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n\n      var proxyUrl = self._getProxyUrl(targetUrl);\n\n      if (proxyUrl) {\n        fayeOptions.proxy = {\n          origin: proxyUrl\n        };\n      }\n\n      ; // We would like to specify 'ddp' as the subprotocol here. The npm module we\n      // used to use as a client would fail the handshake if we ask for a\n      // subprotocol and the server doesn't send one back (and sockjs doesn't).\n      // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n      // Faye is erroneous or not.  So for now, we don't specify protocols.\n\n      var subprotocols = [];\n      var client = self.client = new FayeWebSocket.Client(targetUrl, subprotocols, fayeOptions);\n\n      self._clearConnectionTimer();\n\n      self.connectionTimer = Meteor.setTimeout(function () {\n        self._lostConnection(new DDP.ConnectionError(\"DDP connection timed out\"));\n      }, self.CONNECT_TIMEOUT);\n      self.client.on('open', Meteor.bindEnvironment(function () {\n        return self._onConnect(client);\n      }, \"stream connect callback\"));\n\n      var clientOnIfCurrent = function (event, description, f) {\n        self.client.on(event, Meteor.bindEnvironment(function () {\n          // Ignore events from any connection we've already cleaned up.\n          if (client !== self.client) return;\n          f.apply(this, arguments);\n        }, description));\n      };\n\n      clientOnIfCurrent('error', 'stream error callback', function (error) {\n        if (!self.options._dontPrintErrors) Meteor._debug(\"stream error\", error.message); // Faye's 'error' object is not a JS error (and among other things,\n        // doesn't stringify well). Convert it to one.\n\n        self._lostConnection(new DDP.ConnectionError(error.message));\n      });\n      clientOnIfCurrent('close', 'stream close callback', function () {\n        self._lostConnection();\n      });\n      clientOnIfCurrent('message', 'stream message callback', function (message) {\n        // Ignore binary frames, where message.data is a Buffer\n        if (typeof message.data !== \"string\") return;\n\n        _.each(self.eventCallbacks.message, function (callback) {\n          callback(message.data);\n        });\n      });\n    }\n\n    return _launchConnection;\n  }();\n\n  return ClientStream;\n}();","map":{"version":3,"sources":["packages/ddp-client/stream_client_nodejs.js"],"names":["module1","module","DDP","LivedataTest","watch","require","v","ClientStream","endpoint","options","self","Object","assign","retry","client","headers","npmFayeOptions","_initCommon","_launchConnection","send","data","currentStatus","connected","_changeUrl","url","_onConnect","Error","_forcedToDisconnect","close","_clearConnectionTimer","status","retryCount","statusChanged","_","each","eventCallbacks","reset","callback","_cleanup","maybeError","disconnect","connectionTimer","clearTimeout","_getProxyUrl","targetUrl","proxy","process","env","HTTP_PROXY","http_proxy","match","HTTPS_PROXY","https_proxy","FayeWebSocket","Npm","deflate","toWebsocketUrl","fayeOptions","extensions","extend","proxyUrl","origin","subprotocols","Client","Meteor","setTimeout","_lostConnection","ConnectionError","CONNECT_TIMEOUT","on","bindEnvironment","clientOnIfCurrent","event","description","f","apply","arguments","error","_dontPrintErrors","_debug","message"],"mappings":"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","file":"packages/ddp-client/stream_client_nodejs.js.map","sourcesContent":["import { DDP, LivedataTest } from \"./namespace.js\";\n\n// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = class ClientStream {\n  constructor(endpoint, options) {\n    const self = this;\n    options = options || {};\n\n    self.options = Object.assign({\n      retry: true\n    }, options);\n\n    self.client = null;  // created in _launchConnection\n    self.endpoint = endpoint;\n\n    self.headers = self.options.headers || {};\n    self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n    self._initCommon(self.options);\n\n    //// Kickoff!\n    self._launchConnection();\n  }\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send(data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.client.send(data);\n    }\n  }\n\n  // Changes where this connection points\n  _changeUrl(url) {\n    var self = this;\n    self.endpoint = url;\n  }\n\n  _onConnect(client) {\n    var self = this;\n\n    if (client !== self.client) {\n      // This connection is not from the last call to _launchConnection.\n      // But _launchConnection calls _cleanup which closes previous connections.\n      // It's our belief that this stifles future 'open' events, but maybe\n      // we are wrong?\n      throw new Error(\"Got open from inactive client \" + !!self.client);\n    }\n\n    if (self._forcedToDisconnect) {\n      // We were asked to disconnect between trying to open the connection and\n      // actually opening it. Let's just pretend this never happened.\n      self.client.close();\n      self.client = null;\n      return;\n    }\n\n    if (self.currentStatus.connected) {\n      // We already have a connection. It must have been the case that we\n      // started two parallel connection attempts (because we wanted to\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\n      // connection attempt.) But this shouldn't happen (similarly to the client\n      // !== self.client check above).\n      throw new Error(\"Two parallel connections?\");\n    }\n\n    self._clearConnectionTimer();\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n  }\n\n  _cleanup(maybeError) {\n    var self = this;\n\n    self._clearConnectionTimer();\n    if (self.client) {\n      var client = self.client;\n      self.client = null;\n      client.close();\n\n      _.each(self.eventCallbacks.disconnect, function (callback) {\n        callback(maybeError);\n      });\n    }\n  }\n\n  _clearConnectionTimer() {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n  }\n\n  _getProxyUrl(targetUrl) {\n    var self = this;\n    // Similar to code in tools/http-helpers.js.\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\n    // if we're going to a secure url, try the https_proxy env variable first.\n    if (targetUrl.match(/^wss:/)) {\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n    }\n    return proxy;\n  }\n\n  _launchConnection() {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    // Since server-to-server DDP is still an experimental feature, we only\n    // require the module if we actually create a server-to-server\n    // connection.\n    var FayeWebSocket = Npm.require('faye-websocket');\n    var deflate = Npm.require('permessage-deflate');\n\n    var targetUrl = toWebsocketUrl(self.endpoint);\n    var fayeOptions = {\n      headers: self.headers,\n      extensions: [deflate]\n    };\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n    var proxyUrl = self._getProxyUrl(targetUrl);\n    if (proxyUrl) {\n      fayeOptions.proxy = { origin: proxyUrl };\n    };\n\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\n    // used to use as a client would fail the handshake if we ask for a\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\n    var subprotocols = [];\n\n    var client = self.client = new FayeWebSocket.Client(\n      targetUrl, subprotocols, fayeOptions);\n\n    self._clearConnectionTimer();\n    self.connectionTimer = Meteor.setTimeout(\n      function () {\n        self._lostConnection(\n          new DDP.ConnectionError(\"DDP connection timed out\"));\n      },\n      self.CONNECT_TIMEOUT);\n\n    self.client.on('open', Meteor.bindEnvironment(function () {\n      return self._onConnect(client);\n    }, \"stream connect callback\"));\n\n    var clientOnIfCurrent = function (event, description, f) {\n      self.client.on(event, Meteor.bindEnvironment(function () {\n        // Ignore events from any connection we've already cleaned up.\n        if (client !== self.client)\n          return;\n        f.apply(this, arguments);\n      }, description));\n    };\n\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\n      if (!self.options._dontPrintErrors)\n        Meteor._debug(\"stream error\", error.message);\n\n      // Faye's 'error' object is not a JS error (and among other things,\n      // doesn't stringify well). Convert it to one.\n      self._lostConnection(new DDP.ConnectionError(error.message));\n    });\n\n\n    clientOnIfCurrent('close', 'stream close callback', function () {\n      self._lostConnection();\n    });\n\n\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\n      // Ignore binary frames, where message.data is a Buffer\n      if (typeof message.data !== \"string\")\n        return;\n\n      _.each(self.eventCallbacks.message, function (callback) {\n        callback(message.data);\n      });\n    });\n  }\n};\n"]},"hash":"764c9aba94ee3d8a87e05ea7a909ac89e232f1d3"}
