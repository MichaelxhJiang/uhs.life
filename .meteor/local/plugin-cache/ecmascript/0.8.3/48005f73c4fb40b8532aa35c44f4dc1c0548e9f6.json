{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/dynamic-import/cache.js","filenameRelative":"packages/dynamic-import/cache.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/dynamic-import/cache.js.map","sourceFileName":"packages/dynamic-import/cache.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cache"},"ignored":false,"code":"var hasOwn = Object.prototype.hasOwnProperty;\nvar dbPromise;\nvar canUseCache = // The server doesn't benefit from dynamic module fetching, and almost\n// certainly doesn't support IndexedDB.\nMeteor.isClient && // Cordova bundles all modules into the monolithic initial bundle, so\n// the dynamic module cache won't be necessary.\n!Meteor.isCordova && // Caching can be confusing in development, and is designed to be a\n// transparent optimization for production performance.\nMeteor.isProduction;\n\nfunction getIDB() {\n  if (typeof indexedDB !== \"undefined\") return indexedDB;\n  if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n  if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n  if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n  if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n}\n\nfunction withDB(callback) {\n  dbPromise = dbPromise || new Promise(function (resolve, reject) {\n    var idb = getIDB();\n\n    if (!idb) {\n      throw new Error(\"IndexedDB not available\");\n    } // Incrementing the version number causes all existing object stores\n    // to be deleted and recreates those specified by objectStoreMap.\n\n\n    var request = idb.open(\"MeteorDynamicImportCache\", 2);\n\n    request.onupgradeneeded = function (event) {\n      var db = event.target.result; // It's fine to delete existing object stores since onupgradeneeded\n      // is only called when we change the DB version number, and the data\n      // we're storing is disposable/reconstructible.\n\n      Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);\n      Object.keys(objectStoreMap).forEach(function (name) {\n        db.createObjectStore(name, objectStoreMap[name]);\n      });\n    };\n\n    request.onerror = makeOnError(reject, \"indexedDB.open\");\n\n    request.onsuccess = function (event) {\n      resolve(event.target.result);\n    };\n  });\n  return dbPromise.then(callback, function (error) {\n    return callback(null);\n  });\n}\n\nvar objectStoreMap = {\n  sourcesByVersion: {\n    keyPath: \"version\"\n  }\n};\n\nfunction makeOnError(reject, source) {\n  return function (event) {\n    reject(new Error(\"IndexedDB failure in \" + source + \" \" + JSON.stringify(event.target))); // Returning true from an onerror callback function prevents an\n    // InvalidStateError in Firefox during Private Browsing. Silencing\n    // that error is safe because we handle the error more gracefully by\n    // passing it to the Promise reject function above.\n    // https://github.com/meteor/meteor/issues/8697\n\n    return true;\n  };\n}\n\nvar checkCount = 0;\n\nexports.checkMany = function (versions) {\n  var ids = Object.keys(versions);\n  var sourcesById = Object.create(null); // Initialize sourcesById with null values to indicate all sources are\n  // missing (unless replaced with actual sources below).\n\n  ids.forEach(function (id) {\n    sourcesById[id] = null;\n  });\n\n  if (!canUseCache) {\n    return Promise.resolve(sourcesById);\n  }\n\n  return withDB(function (db) {\n    if (!db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return sourcesById;\n    }\n\n    var txn = db.transaction([\"sourcesByVersion\"], \"readonly\");\n    var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");\n    ++checkCount;\n\n    function finish() {\n      --checkCount;\n      return sourcesById;\n    }\n\n    return Promise.all(ids.map(function (id) {\n      return new Promise(function (resolve, reject) {\n        var version = versions[id];\n\n        if (version) {\n          var sourceRequest = sourcesByVersion.get(version);\n          sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");\n\n          sourceRequest.onsuccess = function (event) {\n            var result = event.target.result;\n\n            if (result) {\n              sourcesById[id] = result.source;\n            }\n\n            resolve();\n          };\n        } else resolve();\n      });\n    })).then(finish, finish);\n  });\n};\n\nvar pendingVersionsAndSourcesById = Object.create(null);\n\nexports.setMany = function (versionsAndSourcesById) {\n  if (canUseCache) {\n    Object.assign(pendingVersionsAndSourcesById, versionsAndSourcesById); // Delay the call to flushSetMany so that it doesn't contribute to the\n    // amount of time it takes to call module.dynamicImport.\n\n    if (!flushSetMany.timer) {\n      flushSetMany.timer = setTimeout(flushSetMany, 100);\n    }\n  }\n};\n\nfunction flushSetMany() {\n  if (checkCount > 0) {\n    // If checkMany is currently underway, postpone the flush until later,\n    // since updating the cache is less important than reading from it.\n    return flushSetMany.timer = setTimeout(flushSetMany, 100);\n  }\n\n  flushSetMany.timer = null;\n  var versionsAndSourcesById = pendingVersionsAndSourcesById;\n  pendingVersionsAndSourcesById = Object.create(null);\n  return withDB(function (db) {\n    if (!db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return;\n    }\n\n    var setTxn = db.transaction([\"sourcesByVersion\"], \"readwrite\");\n    var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");\n    return Promise.all(Object.keys(versionsAndSourcesById).map(function (id) {\n      var info = versionsAndSourcesById[id];\n      return new Promise(function (resolve, reject) {\n        var request = sourcesByVersion.put({\n          version: info.version,\n          source: info.source\n        });\n        request.onerror = makeOnError(reject, \"sourcesByVersion.put\");\n        request.onsuccess = resolve;\n      });\n    }));\n  });\n}","map":{"version":3,"sources":["packages/dynamic-import/cache.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","dbPromise","canUseCache","Meteor","isClient","isCordova","isProduction","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","withDB","callback","Promise","resolve","reject","idb","Error","request","open","onupgradeneeded","event","db","target","result","Array","from","objectStoreNames","forEach","deleteObjectStore","keys","objectStoreMap","name","createObjectStore","onerror","makeOnError","onsuccess","then","error","sourcesByVersion","keyPath","source","JSON","stringify","checkCount","exports","checkMany","versions","ids","sourcesById","create","id","txn","transaction","objectStore","finish","all","map","version","sourceRequest","get","pendingVersionsAndSourcesById","setMany","versionsAndSourcesById","assign","flushSetMany","timer","setTimeout","setTxn","info","put"],"mappings":"AAAA,IAAIA,SAASC,OAAOC,SAAP,CAAiBC,cAA9B;AACA,IAAIC,SAAJ;AAEA,IAAIC,cACF;AACA;AACAC,OAAOC,QAAP,IACA;AACA;AACA,CAAED,OAAOE,SAHT,IAIA;AACA;AACAF,OAAOG,YATT;;AAWA,SAASC,MAAT,GAAkB;AAChB,MAAI,OAAOC,SAAP,KAAqB,WAAzB,EAAsC,OAAOA,SAAP;AACtC,MAAI,OAAOC,eAAP,KAA2B,WAA/B,EAA4C,OAAOA,eAAP;AAC5C,MAAI,OAAOC,YAAP,KAAwB,WAA5B,EAAyC,OAAOA,YAAP;AACzC,MAAI,OAAOC,UAAP,KAAsB,WAA1B,EAAuC,OAAOA,UAAP;AACvC,MAAI,OAAOC,WAAP,KAAuB,WAA3B,EAAwC,OAAOA,WAAP;AACzC;;AAED,SAASC,MAAT,CAAgBC,QAAhB,EAA0B;AACxBb,cAAYA,aAAa,IAAIc,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC9D,QAAIC,MAAMX,QAAV;;AACA,QAAI,CAAEW,GAAN,EAAW;AACT,YAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AACD,KAJ6D,CAM9D;AACA;;;AACA,QAAIC,UAAUF,IAAIG,IAAJ,CAAS,0BAAT,EAAqC,CAArC,CAAd;;AAEAD,YAAQE,eAAR,GAA0B,UAAUC,KAAV,EAAiB;AACzC,UAAIC,KAAKD,MAAME,MAAN,CAAaC,MAAtB,CADyC,CAGzC;AACA;AACA;;AACAC,YAAMC,IAAN,CAAWJ,GAAGK,gBAAd,EAAgCC,OAAhC,CAAwCN,GAAGO,iBAA3C,EAA8DP,EAA9D;AAEA1B,aAAOkC,IAAP,CAAYC,cAAZ,EAA4BH,OAA5B,CAAoC,UAAUI,IAAV,EAAgB;AAClDV,WAAGW,iBAAH,CAAqBD,IAArB,EAA2BD,eAAeC,IAAf,CAA3B;AACD,OAFD;AAGD,KAXD;;AAaAd,YAAQgB,OAAR,GAAkBC,YAAYpB,MAAZ,EAAoB,gBAApB,CAAlB;;AACAG,YAAQkB,SAAR,GAAoB,UAAUf,KAAV,EAAiB;AACnCP,cAAQO,MAAME,MAAN,CAAaC,MAArB;AACD,KAFD;AAGD,GA3BwB,CAAzB;AA6BA,SAAOzB,UAAUsC,IAAV,CAAezB,QAAf,EAAyB,UAAU0B,KAAV,EAAiB;AAC/C,WAAO1B,SAAS,IAAT,CAAP;AACD,GAFM,CAAP;AAGD;;AAED,IAAImB,iBAAiB;AACnBQ,oBAAkB;AAAEC,aAAS;AAAX;AADC,CAArB;;AAIA,SAASL,WAAT,CAAqBpB,MAArB,EAA6B0B,MAA7B,EAAqC;AACnC,SAAO,UAAUpB,KAAV,EAAiB;AACtBN,WAAO,IAAIE,KAAJ,CACL,0BAA0BwB,MAA1B,GAAmC,GAAnC,GACEC,KAAKC,SAAL,CAAetB,MAAME,MAArB,CAFG,CAAP,EADsB,CAMtB;AACA;AACA;AACA;AACA;;AACA,WAAO,IAAP;AACD,GAZD;AAaD;;AAED,IAAIqB,aAAa,CAAjB;;AAEAC,QAAQC,SAAR,GAAoB,UAAUC,QAAV,EAAoB;AACtC,MAAIC,MAAMpD,OAAOkC,IAAP,CAAYiB,QAAZ,CAAV;AACA,MAAIE,cAAcrD,OAAOsD,MAAP,CAAc,IAAd,CAAlB,CAFsC,CAItC;AACA;;AACAF,MAAIpB,OAAJ,CAAY,UAAUuB,EAAV,EAAc;AACxBF,gBAAYE,EAAZ,IAAkB,IAAlB;AACD,GAFD;;AAIA,MAAI,CAAEnD,WAAN,EAAmB;AACjB,WAAOa,QAAQC,OAAR,CAAgBmC,WAAhB,CAAP;AACD;;AAED,SAAOtC,OAAO,UAAUW,EAAV,EAAc;AAC1B,QAAI,CAAEA,EAAN,EAAU;AACR;AACA;AACA,aAAO2B,WAAP;AACD;;AAED,QAAIG,MAAM9B,GAAG+B,WAAH,CAAe,CACvB,kBADuB,CAAf,EAEP,UAFO,CAAV;AAIA,QAAId,mBAAmBa,IAAIE,WAAJ,CAAgB,kBAAhB,CAAvB;AAEA,MAAEV,UAAF;;AAEA,aAASW,MAAT,GAAkB;AAChB,QAAEX,UAAF;AACA,aAAOK,WAAP;AACD;;AAED,WAAOpC,QAAQ2C,GAAR,CAAYR,IAAIS,GAAJ,CAAQ,UAAUN,EAAV,EAAc;AACvC,aAAO,IAAItC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,YAAI2C,UAAUX,SAASI,EAAT,CAAd;;AACA,YAAIO,OAAJ,EAAa;AACX,cAAIC,gBAAgBpB,iBAAiBqB,GAAjB,CAAqBF,OAArB,CAApB;AACAC,wBAAczB,OAAd,GAAwBC,YAAYpB,MAAZ,EAAoB,sBAApB,CAAxB;;AACA4C,wBAAcvB,SAAd,GAA0B,UAAUf,KAAV,EAAiB;AACzC,gBAAIG,SAASH,MAAME,MAAN,CAAaC,MAA1B;;AACA,gBAAIA,MAAJ,EAAY;AACVyB,0BAAYE,EAAZ,IAAkB3B,OAAOiB,MAAzB;AACD;;AACD3B;AACD,WAND;AAOD,SAVD,MAUOA;AACR,OAbM,CAAP;AAcD,KAfkB,CAAZ,EAeHuB,IAfG,CAeEkB,MAfF,EAeUA,MAfV,CAAP;AAgBD,GApCM,CAAP;AAqCD,CAnDD;;AAqDA,IAAIM,gCAAgCjE,OAAOsD,MAAP,CAAc,IAAd,CAApC;;AAEAL,QAAQiB,OAAR,GAAkB,UAAUC,sBAAV,EAAkC;AAClD,MAAI/D,WAAJ,EAAiB;AACfJ,WAAOoE,MAAP,CACEH,6BADF,EAEEE,sBAFF,EADe,CAMf;AACA;;AACA,QAAI,CAAEE,aAAaC,KAAnB,EAA0B;AACxBD,mBAAaC,KAAb,GAAqBC,WAAWF,YAAX,EAAyB,GAAzB,CAArB;AACD;AACF;AACF,CAbD;;AAeA,SAASA,YAAT,GAAwB;AACtB,MAAIrB,aAAa,CAAjB,EAAoB;AAClB;AACA;AACA,WAAOqB,aAAaC,KAAb,GAAqBC,WAAWF,YAAX,EAAyB,GAAzB,CAA5B;AACD;;AAEDA,eAAaC,KAAb,GAAqB,IAArB;AAEA,MAAIH,yBAAyBF,6BAA7B;AACAA,kCAAgCjE,OAAOsD,MAAP,CAAc,IAAd,CAAhC;AAEA,SAAOvC,OAAO,UAAUW,EAAV,EAAc;AAC1B,QAAI,CAAEA,EAAN,EAAU;AACR;AACA;AACA;AACD;;AAED,QAAI8C,SAAS9C,GAAG+B,WAAH,CAAe,CAC1B,kBAD0B,CAAf,EAEV,WAFU,CAAb;AAIA,QAAId,mBAAmB6B,OAAOd,WAAP,CAAmB,kBAAnB,CAAvB;AAEA,WAAOzC,QAAQ2C,GAAR,CACL5D,OAAOkC,IAAP,CAAYiC,sBAAZ,EAAoCN,GAApC,CAAwC,UAAUN,EAAV,EAAc;AACpD,UAAIkB,OAAON,uBAAuBZ,EAAvB,CAAX;AACA,aAAO,IAAItC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,YAAIG,UAAUqB,iBAAiB+B,GAAjB,CAAqB;AACjCZ,mBAASW,KAAKX,OADmB;AAEjCjB,kBAAQ4B,KAAK5B;AAFoB,SAArB,CAAd;AAIAvB,gBAAQgB,OAAR,GAAkBC,YAAYpB,MAAZ,EAAoB,sBAApB,CAAlB;AACAG,gBAAQkB,SAAR,GAAoBtB,OAApB;AACD,OAPM,CAAP;AAQD,KAVD,CADK,CAAP;AAaD,GA1BM,CAAP;AA2BD","file":"packages/dynamic-import/cache.js.map","sourcesContent":["var hasOwn = Object.prototype.hasOwnProperty;\nvar dbPromise;\n\nvar canUseCache =\n  // The server doesn't benefit from dynamic module fetching, and almost\n  // certainly doesn't support IndexedDB.\n  Meteor.isClient &&\n  // Cordova bundles all modules into the monolithic initial bundle, so\n  // the dynamic module cache won't be necessary.\n  ! Meteor.isCordova &&\n  // Caching can be confusing in development, and is designed to be a\n  // transparent optimization for production performance.\n  Meteor.isProduction;\n\nfunction getIDB() {\n  if (typeof indexedDB !== \"undefined\") return indexedDB;\n  if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n  if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n  if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n  if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n}\n\nfunction withDB(callback) {\n  dbPromise = dbPromise || new Promise(function (resolve, reject) {\n    var idb = getIDB();\n    if (! idb) {\n      throw new Error(\"IndexedDB not available\");\n    }\n\n    // Incrementing the version number causes all existing object stores\n    // to be deleted and recreates those specified by objectStoreMap.\n    var request = idb.open(\"MeteorDynamicImportCache\", 2);\n\n    request.onupgradeneeded = function (event) {\n      var db = event.target.result;\n\n      // It's fine to delete existing object stores since onupgradeneeded\n      // is only called when we change the DB version number, and the data\n      // we're storing is disposable/reconstructible.\n      Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);\n\n      Object.keys(objectStoreMap).forEach(function (name) {\n        db.createObjectStore(name, objectStoreMap[name]);\n      });\n    };\n\n    request.onerror = makeOnError(reject, \"indexedDB.open\");\n    request.onsuccess = function (event) {\n      resolve(event.target.result);\n    };\n  });\n\n  return dbPromise.then(callback, function (error) {\n    return callback(null);\n  });\n}\n\nvar objectStoreMap = {\n  sourcesByVersion: { keyPath: \"version\" }\n};\n\nfunction makeOnError(reject, source) {\n  return function (event) {\n    reject(new Error(\n      \"IndexedDB failure in \" + source + \" \" +\n        JSON.stringify(event.target)\n    ));\n\n    // Returning true from an onerror callback function prevents an\n    // InvalidStateError in Firefox during Private Browsing. Silencing\n    // that error is safe because we handle the error more gracefully by\n    // passing it to the Promise reject function above.\n    // https://github.com/meteor/meteor/issues/8697\n    return true;\n  };\n}\n\nvar checkCount = 0;\n\nexports.checkMany = function (versions) {\n  var ids = Object.keys(versions);\n  var sourcesById = Object.create(null);\n\n  // Initialize sourcesById with null values to indicate all sources are\n  // missing (unless replaced with actual sources below).\n  ids.forEach(function (id) {\n    sourcesById[id] = null;\n  });\n\n  if (! canUseCache) {\n    return Promise.resolve(sourcesById);\n  }\n\n  return withDB(function (db) {\n    if (! db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return sourcesById;\n    }\n\n    var txn = db.transaction([\n      \"sourcesByVersion\"\n    ], \"readonly\");\n\n    var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");\n\n    ++checkCount;\n\n    function finish() {\n      --checkCount;\n      return sourcesById;\n    }\n\n    return Promise.all(ids.map(function (id) {\n      return new Promise(function (resolve, reject) {\n        var version = versions[id];\n        if (version) {\n          var sourceRequest = sourcesByVersion.get(version);\n          sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");\n          sourceRequest.onsuccess = function (event) {\n            var result = event.target.result;\n            if (result) {\n              sourcesById[id] = result.source;\n            }\n            resolve();\n          };\n        } else resolve();\n      });\n    })).then(finish, finish);\n  });\n};\n\nvar pendingVersionsAndSourcesById = Object.create(null);\n\nexports.setMany = function (versionsAndSourcesById) {\n  if (canUseCache) {\n    Object.assign(\n      pendingVersionsAndSourcesById,\n      versionsAndSourcesById\n    );\n\n    // Delay the call to flushSetMany so that it doesn't contribute to the\n    // amount of time it takes to call module.dynamicImport.\n    if (! flushSetMany.timer) {\n      flushSetMany.timer = setTimeout(flushSetMany, 100);\n    }\n  }\n};\n\nfunction flushSetMany() {\n  if (checkCount > 0) {\n    // If checkMany is currently underway, postpone the flush until later,\n    // since updating the cache is less important than reading from it.\n    return flushSetMany.timer = setTimeout(flushSetMany, 100);\n  }\n\n  flushSetMany.timer = null;\n\n  var versionsAndSourcesById = pendingVersionsAndSourcesById;\n  pendingVersionsAndSourcesById = Object.create(null);\n\n  return withDB(function (db) {\n    if (! db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return;\n    }\n\n    var setTxn = db.transaction([\n      \"sourcesByVersion\"\n    ], \"readwrite\");\n\n    var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");\n\n    return Promise.all(\n      Object.keys(versionsAndSourcesById).map(function (id) {\n        var info = versionsAndSourcesById[id];\n        return new Promise(function (resolve, reject) {\n          var request = sourcesByVersion.put({\n            version: info.version,\n            source: info.source\n          });\n          request.onerror = makeOnError(reject, \"sourcesByVersion.put\");\n          request.onsuccess = resolve;\n        });\n      })\n    );\n  });\n}\n"]},"hash":"48005f73c4fb40b8532aa35c44f4dc1c0548e9f6"}
