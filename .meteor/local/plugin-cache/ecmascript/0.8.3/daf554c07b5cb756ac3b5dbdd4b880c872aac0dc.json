{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/mongo/mongo_driver.js","filenameRelative":"packages/mongo/mongo_driver.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/mongo/mongo_driver.js.map","sourceFileName":"packages/mongo/mongo_driver.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"mongo_driver"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */var MongoDB = NpmModuleMongodb;\n\nvar Future = Npm.require('fibers/future');\n\nMongoInternals = {};\nMongoTest = {};\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n}; // Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\n\nMongoInternals.NpmModule = MongoDB; // This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\n\nvar replaceNames = function (filter, thing) {\n  if ((typeof thing === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(thing)) === \"object\") {\n    if (_.isArray(thing)) {\n      return _.map(thing, _.bind(replaceNames, null, filter));\n    }\n\n    var ret = {};\n\n    _.each(thing, function (value, key) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n\n    return ret;\n  }\n\n  return thing;\n}; // Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\n\n\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) {\n  return \"EJSON\" + name;\n};\n\nvar unmakeMongoLegal = function (name) {\n  return name.substr(5);\n};\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(new Buffer(document));\n  }\n\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  } // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n\n\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if ((typeof document === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(document)) !== 'object' || document === null) return document;\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;\n  var ret = document;\n\n  _.each(document, function (val, key) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document) ret = _.clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n\n  return ret;\n};\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook();\n  var mongoOptions = Object.assign({\n    // Reconnect on error.\n    autoReconnect: true,\n    // Try to reconnect forever, instead of stopping after 30 tries (the\n    // default), with each attempt separated by 1000ms.\n    reconnectTries: Infinity\n  }, Mongo._connectionOptions); // Disable the native parser by default, unless specifically enabled\n  // in the mongo URL.\n  // - The native driver can cause errors which normally would be\n  //   thrown, caught, and handled into segfaults that take down the\n  //   whole app.\n  // - Binary modules don't yet work when you bundle and move the bundle\n  //   to a different platform (aka deploy)\n  // We should revisit this after binary npm module support lands.\n\n  if (!/[\\?&]native_?[pP]arser=/.test(url)) {\n    mongoOptions.native_parser = false;\n  } // Internally the oplog connections specify their own poolSize\n  // which we don't want to overwrite with any user defined value\n\n\n  if (_.has(options, 'poolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.poolSize = options.poolSize;\n  }\n\n  self.db = null; // We keep track of the ReplSet's primary, so that we can trigger hooks when\n  // it changes.  The Node driver's joined callback seems to fire way too\n  // often, which is why we need to track it ourselves.\n\n  self._primary = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n  var connectFuture = new Future();\n  MongoDB.connect(url, mongoOptions, Meteor.bindEnvironment(function (err, db) {\n    if (err) {\n      throw err;\n    } // First, figure out what the current primary is, if any.\n\n\n    if (db.serverConfig.isMasterDoc) {\n      self._primary = db.serverConfig.isMasterDoc.primary;\n    }\n\n    db.serverConfig.on('joined', Meteor.bindEnvironment(function (kind, doc) {\n      if (kind === 'primary') {\n        if (doc.primary !== self._primary) {\n          self._primary = doc.primary;\n\n          self._onFailoverHook.each(function (callback) {\n            callback();\n            return true;\n          });\n        }\n      } else if (doc.me === self._primary) {\n        // The thing we thought was primary is now something other than\n        // primary.  Forget that we thought it was primary.  (This means\n        // that if a server stops being primary and then starts being\n        // primary again without another server becoming primary in the\n        // middle, we'll correctly count it as a failover.)\n        self._primary = null;\n      }\n    })); // Allow the constructor to return.\n\n    connectFuture['return'](db);\n  }, connectFuture.resolver() // onException\n  )); // Wait for the connection to be successful; throws on failure.\n\n  self.db = connectFuture.wait();\n\n  if (options.oplogUrl && !Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n};\n\nMongoConnection.prototype.close = function () {\n  var self = this;\n  if (!self.db) throw Error(\"close called before Connection created?\"); // XXX probably untested\n\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle) oplogHandle.stop(); // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n\n  Future.wrap(_.bind(self.db.close, self.db))(true).wait();\n}; // Returns the Mongo Collection object; may yield.\n\n\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n  if (!self.db) throw Error(\"rawCollection called before Connection created?\");\n  var future = new Future();\n  self.db.collection(collectionName, future.resolver());\n  return future.wait();\n};\n\nMongoConnection.prototype._createCappedCollection = function (collectionName, byteSize, maxDocuments) {\n  var self = this;\n  if (!self.db) throw Error(\"_createCappedCollection called before Connection created?\");\n  var future = new Future();\n  self.db.createCollection(collectionName, {\n    capped: true,\n    size: byteSize,\n    max: maxDocuments\n  }, future.resolver());\n  future.wait();\n}; // This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\n\n\nMongoConnection.prototype._maybeBeginWrite = function () {\n  var fence = DDPServer._CurrentWriteFence.get();\n\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {\n      committed: function () {}\n    };\n  }\n}; // Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\n\n\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n}; //////////// Public API //////////\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (!err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n\n    write.committed();\n\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype._insert = function (collection_name, document, callback) {\n  var self = this;\n\n  var sendError = function (e) {\n    if (callback) return callback(e);\n    throw e;\n  };\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    sendError(e);\n    return;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n    sendError(new Error(\"Only plain objects may be inserted into MongoDB\"));\n    return;\n  }\n\n  var write = self._maybeBeginWrite();\n\n  var refresh = function () {\n    Meteor.refresh({\n      collection: collection_name,\n      id: document._id\n    });\n  };\n\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.insert(replaceTypes(document, replaceMeteorAtomWithMongo), {\n      safe: true\n    }, callback);\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n}; // Cause queries that may be affected by the selector to poll in this write\n// fence.\n\n\nMongoConnection.prototype._refresh = function (collectionName, selector) {\n  var refreshKey = {\n    collection: collectionName\n  }; // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      Meteor.refresh(_.extend({\n        id: id\n      }, refreshKey));\n    });\n  } else {\n    Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype._remove = function (collection_name, selector, callback) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  var write = self._maybeBeginWrite();\n\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n\n    var wrappedCallback = function (err, driverResult) {\n      callback(err, transformResult(driverResult).numberAffected);\n    };\n\n    collection.remove(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n      safe: true\n    }, wrappedCallback);\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n\n  var refresh = function () {\n    Meteor.refresh({\n      collection: collectionName,\n      id: null,\n      dropCollection: true\n    });\n  };\n\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    var collection = self.rawCollection(collectionName);\n    collection.drop(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n}; // For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\n\n\nMongoConnection.prototype._dropDatabase = function (cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n\n  var refresh = function () {\n    Meteor.refresh({\n      dropDatabase: true\n    });\n  };\n\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    self.db.dropDatabase(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._update = function (collection_name, selector, mod, options, callback) {\n  var self = this;\n\n  if (!callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  } // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n\n\n  if (!mod || (typeof mod === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(mod)) !== 'object') throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n  if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n    throw new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n\n  callback = writeCallback(write, refresh, callback);\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    var mongoOpts = {\n      safe: true\n    }; // explictly enumerate options that minimongo supports\n\n    if (options.upsert) mongoOpts.upsert = true;\n    if (options.multi) mongoOpts.multi = true; // Lets you get a more more full result from MongoDB. Use with caution:\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n    // with simulated upsert.\n\n    if (options.fullResult) mongoOpts.fullResult = true;\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n    var isModify = LocalCollection._isModificationMod(mongoMod);\n\n    if (options._forbidReplace && !isModify) {\n      var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n\n      if (callback) {\n        return callback(err);\n      } else {\n        throw err;\n      }\n    } // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n    // selector and mod.  We assume it doesn't matter, as far as\n    // the behavior of modifiers is concerned, whether `_modify`\n    // is run on EJSON or on mongo-converted EJSON.\n    // Run this code up front so that it fails fast if someone uses\n    // a Mongo update operator we don't support.\n\n\n    var knownId = void 0;\n\n    if (options.upsert) {\n      try {\n        var newDoc = LocalCollection._createUpsertDocument(selector, mod);\n\n        knownId = newDoc._id;\n      } catch (err) {\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    if (options.upsert && !isModify && !knownId && options.insertedId && !(options.insertedId instanceof Mongo.ObjectID && options.generatedId)) {\n      // In case of an upsert with a replacement, where there is no _id defined\n      // in either the query or the replacement doc, mongo will generate an id itself. \n      // Therefore we need this special strategy if we want to control the id ourselves.\n      // We don't need to do this when:\n      // - This is not a replacement, so we can add an _id to $setOnInsert\n      // - The id is defined by query or mod we can just add it to the replacement doc\n      // - The user did not specify any id preference and the id is a Mongo ObjectId, \n      //     then we can just let Mongo generate the id\n      simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options, // This callback does not need to be bindEnvironment'ed because\n      // simulateUpsertWithInsertedId() wraps it and then passes it through\n      // bindEnvironmentForWrite.\n      function (error, result) {\n        // If we got here via a upsert() call, then options._returnObject will\n        // be set and we should return the whole object. Otherwise, we should\n        // just return the number of affected docs to match the mongo API.\n        if (result && !options._returnObject) {\n          callback(error, result.numberAffected);\n        } else {\n          callback(error, result);\n        }\n      });\n    } else {\n      if (options.upsert && !knownId && options.insertedId && isModify) {\n        if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n          mongoMod.$setOnInsert = {};\n        }\n\n        knownId = options.insertedId;\n        Object.assign(mongoMod.$setOnInsert, replaceTypes({\n          _id: options.insertedId\n        }, replaceMeteorAtomWithMongo));\n      }\n\n      collection.update(mongoSelector, mongoMod, mongoOpts, bindEnvironmentForWrite(function (err, result) {\n        if (!err) {\n          var meteorResult = transformResult(result);\n\n          if (meteorResult && options._returnObject) {\n            // If this was an upsert() call, and we ended up\n            // inserting a new doc and we know its id, then\n            // return that id as well.\n            if (options.upsert && meteorResult.insertedId) {\n              if (knownId) {\n                meteorResult.insertedId = knownId;\n              } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n              }\n            }\n\n            callback(err, meteorResult);\n          } else {\n            callback(err, meteorResult.numberAffected);\n          }\n        } else {\n          callback(err);\n        }\n      }));\n    }\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nvar transformResult = function (driverResult) {\n  var meteorResult = {\n    numberAffected: 0\n  };\n\n  if (driverResult) {\n    var mongoResult = driverResult.result; // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n\n    if (mongoResult.upserted) {\n      meteorResult.numberAffected += mongoResult.upserted.length;\n\n      if (mongoResult.upserted.length == 1) {\n        meteorResult.insertedId = mongoResult.upserted[0]._id;\n      }\n    } else {\n      meteorResult.numberAffected = mongoResult.n;\n    }\n  }\n\n  return meteorResult;\n};\n\nvar NUM_OPTIMISTIC_TRIES = 3; // exposed for testing\n\nMongoConnection._isCannotChangeIdError = function (err) {\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err; // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n\n  if (error.indexOf('The _id field cannot be changed') === 0 || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = function (collection, selector, mod, options, callback) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents, \n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n  var insertedId = options.insertedId; // must exist\n\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n  var replacementWithId = Object.assign(replaceTypes({\n    _id: insertedId\n  }, replaceMeteorAtomWithMongo), mod);\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = function () {\n    tries--;\n\n    if (!tries) {\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n    } else {\n      collection.update(selector, mod, mongoOptsForUpdate, bindEnvironmentForWrite(function (err, result) {\n        if (err) {\n          callback(err);\n        } else if (result && result.result.n != 0) {\n          callback(null, {\n            numberAffected: result.result.n\n          });\n        } else {\n          doConditionalInsert();\n        }\n      }));\n    }\n  };\n\n  var doConditionalInsert = function () {\n    collection.update(selector, replacementWithId, mongoOptsForInsert, bindEnvironmentForWrite(function (err, result) {\n      if (err) {\n        // figure out if this is a\n        // \"cannot change _id of document\" error, and\n        // if so, try doUpdate() again, up to 3 times.\n        if (MongoConnection._isCannotChangeIdError(err)) {\n          doUpdate();\n        } else {\n          callback(err);\n        }\n      } else {\n        callback(null, {\n          numberAffected: result.result.upserted.length,\n          insertedId: insertedId\n        });\n      }\n    }));\n  };\n\n  doUpdate();\n};\n\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n  MongoConnection.prototype[method] = function () /* arguments */{\n    var self = this;\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n  };\n}); // XXX MongoConnection.upsert() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\n\n\nMongoConnection.prototype.upsert = function (collectionName, selector, mod, options, callback) {\n  var self = this;\n\n  if (typeof options === \"function\" && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(collectionName, selector, mod, _.extend({}, options, {\n    upsert: true,\n    _returnObject: true\n  }), callback);\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n  if (arguments.length === 1) selector = {};\n  return new Cursor(self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOne = function (collection_name, selector, options) {\n  var self = this;\n  if (arguments.length === 1) selector = {};\n  options = options || {};\n  options.limit = 1;\n  return self.find(collection_name, selector, options).fetch()[0];\n}; // We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\n\n\nMongoConnection.prototype._ensureIndex = function (collectionName, index, options) {\n  var self = this; // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n\n  var collection = self.rawCollection(collectionName);\n  var future = new Future();\n  var indexName = collection.ensureIndex(index, options, future.resolver());\n  future.wait();\n};\n\nMongoConnection.prototype._dropIndex = function (collectionName, index) {\n  var self = this; // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n\n  var collection = self.rawCollection(collectionName);\n  var future = new Future();\n  var indexName = collection.dropIndex(index, future.resolver());\n  future.wait();\n}; // CURSORS\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\n_.each(['forEach', 'map', 'fetch', 'count'], function (method) {\n  Cursor.prototype[method] = function () {\n    var self = this; // You can only observe a tailable cursor.\n\n    if (self._cursorDescription.options.tailable) throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n\n    if (!self._synchronousCursor) {\n      self._synchronousCursor = self._mongo._createSynchronousCursor(self._cursorDescription, {\n        // Make sure that the \"self\" argument to forEach/map callbacks is the\n        // Cursor, not the SynchronousCursor.\n        selfForIteration: self,\n        useTransform: true\n      });\n    }\n\n    return self._synchronousCursor[method].apply(self._synchronousCursor, arguments);\n  };\n}); // Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\n\n\nCursor.prototype.rewind = function () {};\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n}; // When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\n\n\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n}; // Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\n\n\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n};\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeChanges = function (callbacks) {\n  var self = this;\n  var methods = ['addedAt', 'added', 'changedAt', 'changed', 'removedAt', 'removed', 'movedTo'];\n\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks); // XXX: Can we find out if callbacks are from observe?\n\n\n  var exceptionName = ' observe/observeChanges callback';\n  methods.forEach(function (method) {\n    if (callbacks[method] && typeof callbacks[method] == \"function\") {\n      callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n    }\n  });\n  return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function (cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip\n  }; // Do we want a tailable cursor (which only works on capped collections)?\n\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    mongoOptions.tailable = true; // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n\n    mongoOptions.awaitdata = true; // ... and to keep querying the server indefinitely rather than just 5 times\n    // if there's no more data.\n\n    mongoOptions.numberOfRetries = -1; // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n\n    if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n      mongoOptions.oplogReplay = true;\n    }\n  }\n\n  var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), cursorOptions.fields, mongoOptions);\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new SynchronousCursor(dbCursor, cursorDescription, options);\n};\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription; // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n\n  self._selfForIteration = options.selfForIteration || self;\n\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  } // Need to specify that the callback is the first argument to nextObject,\n  // since otherwise when we try to call it with no args the driver will\n  // interpret \"undefined\" first arg as an options hash and crash.\n\n\n  self._synchronousNextObject = Future.wrap(dbCursor.nextObject.bind(dbCursor), 0);\n  self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));\n  self._visitedIds = new LocalCollection._IdMap();\n};\n\n_.extend(SynchronousCursor.prototype, {\n  _nextObject: function () {\n    var self = this;\n\n    while (true) {\n      var doc = self._synchronousNextObject().wait();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform) doc = self._transform(doc);\n      return doc;\n    }\n  },\n  forEach: function (callback, thisArg) {\n    var self = this; // Get back to the beginning.\n\n    self._rewind(); // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n\n\n    var index = 0;\n\n    while (true) {\n      var doc = self._nextObject();\n\n      if (!doc) return;\n      callback.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(callback.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n  _rewind: function () {\n    var self = this; // known to be synchronous\n\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap();\n  },\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n  fetch: function () {\n    var self = this;\n    return self.map(_.identity);\n  },\n  count: function () {\n    var applySkipLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var self = this;\n    return self._synchronousCount(applySkipLimit).wait();\n  },\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap();\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nMongoConnection.prototype.tail = function (cursorDescription, docCallback) {\n  var self = this;\n  if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n\n  var loop = function () {\n    var doc = null;\n\n    while (true) {\n      if (stopped) return;\n\n      try {\n        doc = cursor._nextObject();\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error\n        // from Mongo. Ah well. But either way, we need to retry the cursor\n        // (unless the failure was because the observe got stopped).\n        doc = null;\n      } // Since cursor._nextObject can yield, we need to check again to see if\n      // we've been stopped before calling the callback.\n\n\n      if (stopped) return;\n\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = _.clone(cursorDescription.selector);\n\n        if (lastTS) {\n          newSelector.ts = {\n            $gt: lastTS\n          };\n        }\n\n        cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options)); // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n\n        Meteor.setTimeout(loop, 100);\n        break;\n      }\n    }\n  };\n\n  Meteor.defer(loop);\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nMongoConnection.prototype._observeChanges = function (cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  if (cursorDescription.options.tailable) {\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n  } // You may not filter out _id when observing changes, because the id is a core\n  // part of the observeChanges API.\n\n\n  if (cursorDescription.options.fields && (cursorDescription.options.fields._id === 0 || cursorDescription.options.fields._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n  }\n\n  var observeKey = EJSON.stringify(_.extend({\n    ordered: ordered\n  }, cursorDescription));\n  var multiplexer, observeDriver;\n  var firstHandle = false; // Find a matching ObserveMultiplexer, or create a new one. This next block is\n  // guaranteed to not yield (and it doesn't call anything that can observe a\n  // new query), so no other calls to this function can interleave with it.\n\n  Meteor._noYieldsAllowed(function () {\n    if (_.has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true; // Create a new ObserveMultiplexer.\n\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          observeDriver.stop();\n        }\n      });\n      self._observeMultiplexers[observeKey] = multiplexer;\n    }\n  });\n\n  var observeHandle = new ObserveHandle(multiplexer, callbacks);\n\n  if (firstHandle) {\n    var matcher, sorter;\n\n    var canUseOplog = _.all([function () {\n      // At a bare minimum, using the oplog requires us to have an oplog, to\n      // want unordered callbacks, and to not want a callback on the polls\n      // that won't happen.\n      return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;\n    }, function () {\n      // We need to be able to compile the selector. Fall back to polling for\n      // some newfangled $selector that minimongo doesn't support yet.\n      try {\n        matcher = new Minimongo.Matcher(cursorDescription.selector);\n        return true;\n      } catch (e) {\n        // XXX make all compilation errors MinimongoError or something\n        //     so that this doesn't ignore unrelated exceptions\n        return false;\n      }\n    }, function () {\n      // ... and the selector itself needs to support oplog.\n      return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n    }, function () {\n      // And we need to be able to compile the sort, if any.  eg, can't be\n      // {$natural: 1}.\n      if (!cursorDescription.options.sort) return true;\n\n      try {\n        sorter = new Minimongo.Sorter(cursorDescription.options.sort, {\n          matcher: matcher\n        });\n        return true;\n      } catch (e) {\n        // XXX make all compilation errors MinimongoError or something\n        //     so that this doesn't ignore unrelated exceptions\n        return false;\n      }\n    }], function (f) {\n      return f();\n    }); // invoke each function\n\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher,\n      // ignored by polling\n      sorter: sorter,\n      // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n    }); // This field is only set for use in tests.\n\n    multiplexer._observeDriver = observeDriver;\n  } // Blocks until the initial adds have been sent.\n\n\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);\n  return observeHandle;\n}; // Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\n\nlistenAll = function (cursorDescription, listenCallback) {\n  var listeners = [];\n  forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback));\n  });\n  return {\n    stop: function () {\n      _.each(listeners, function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = function (cursorDescription, triggerCallback) {\n  var key = {\n    collection: cursorDescription.collectionName\n  };\n\n  var specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector);\n\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      triggerCallback(_.extend({\n        id: id\n      }, key));\n    });\n\n    triggerCallback(_.extend({\n      dropCollection: true,\n      id: null\n    }, key));\n  } else {\n    triggerCallback(key);\n  } // Everyone cares about the database being dropped.\n\n\n  triggerCallback({\n    dropDatabase: true\n  });\n}; // observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\n\n\nMongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n  var self = this; // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n\n  if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id; // The ts is an implementation detail. Hide it.\n\n    delete doc.ts;\n\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n}; // XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\n\n\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\nMongoInternals.Connection = MongoConnection;","map":{"version":3,"sources":["packages/mongo/mongo_driver.js"],"names":["MongoDB","NpmModuleMongodb","Future","Npm","require","MongoInternals","MongoTest","NpmModules","mongodb","version","NpmModuleMongodbVersion","module","NpmModule","replaceNames","filter","thing","_","isArray","map","bind","ret","each","value","key","Timestamp","prototype","clone","makeMongoLegal","name","unmakeMongoLegal","substr","replaceMongoAtomWithMeteor","document","Binary","buffer","Uint8Array","ObjectID","Mongo","toHexString","size","EJSON","fromJSONValue","undefined","replaceMeteorAtomWithMongo","isBinary","Buffer","_isCustomType","toJSONValue","replaceTypes","atomTransformer","replacedTopLevelAtom","val","valReplaced","MongoConnection","url","options","self","_observeMultiplexers","_onFailoverHook","Hook","mongoOptions","Object","assign","autoReconnect","reconnectTries","Infinity","_connectionOptions","test","native_parser","has","poolSize","db","_primary","_oplogHandle","_docFetcher","connectFuture","connect","Meteor","bindEnvironment","err","serverConfig","isMasterDoc","primary","on","kind","doc","callback","me","resolver","wait","oplogUrl","Package","OplogHandle","databaseName","DocFetcher","close","Error","oplogHandle","stop","wrap","rawCollection","collectionName","future","collection","_createCappedCollection","byteSize","maxDocuments","createCollection","capped","max","_maybeBeginWrite","fence","DDPServer","_CurrentWriteFence","get","beginWrite","committed","_onFailover","register","writeCallback","write","refresh","result","refreshErr","bindEnvironmentForWrite","_insert","collection_name","sendError","e","expected","LocalCollection","_isPlainObject","id","_id","insert","safe","_refresh","selector","refreshKey","specificIds","_idsMatchedBySelector","extend","_remove","wrappedCallback","driverResult","transformResult","numberAffected","remove","_dropCollection","cb","dropCollection","drop","_dropDatabase","dropDatabase","_update","mod","Function","mongoOpts","upsert","multi","fullResult","mongoSelector","mongoMod","isModify","_isModificationMod","_forbidReplace","knownId","newDoc","_createUpsertDocument","insertedId","generatedId","simulateUpsertWithInsertedId","error","_returnObject","hasOwnProperty","$setOnInsert","update","meteorResult","mongoResult","upserted","length","n","NUM_OPTIMISTIC_TRIES","_isCannotChangeIdError","errmsg","indexOf","mongoOptsForUpdate","mongoOptsForInsert","replacementWithId","tries","doUpdate","doConditionalInsert","method","wrapAsync","apply","arguments","find","Cursor","CursorDescription","findOne","limit","fetch","_ensureIndex","index","indexName","ensureIndex","_dropIndex","dropIndex","Collection","_rewriteSelector","mongo","cursorDescription","_mongo","_cursorDescription","_synchronousCursor","tailable","_createSynchronousCursor","selfForIteration","useTransform","rewind","getTransform","transform","_publishCursor","sub","_getCollectionName","observe","callbacks","_observeFromObserveChanges","observeChanges","methods","ordered","_observeChangesCallbacksAreOrdered","exceptionName","forEach","_observeChanges","pick","cursorOptions","sort","skip","awaitdata","numberOfRetries","OPLOG_COLLECTION","ts","oplogReplay","dbCursor","fields","maxTimeMs","maxTimeMS","hint","SynchronousCursor","_dbCursor","_selfForIteration","_transform","wrapTransform","_synchronousNextObject","nextObject","_synchronousCount","count","_visitedIds","_IdMap","_nextObject","set","thisArg","_rewind","call","res","push","identity","applySkipLimit","getRawObjects","results","tail","docCallback","cursor","stopped","lastTS","loop","newSelector","$gt","setTimeout","defer","_observeChangesTailable","observeKey","stringify","multiplexer","observeDriver","firstHandle","_noYieldsAllowed","ObserveMultiplexer","onStop","observeHandle","ObserveHandle","matcher","sorter","canUseOplog","all","_testOnlyPollCallback","Minimongo","Matcher","OplogObserveDriver","cursorSupported","Sorter","f","driverClass","PollingObserveDriver","mongoHandle","_observeDriver","addHandleAndSendInitialAdds","listenAll","listenCallback","listeners","forEachTrigger","trigger","_InvalidationCrossbar","listen","listener","triggerCallback","addedBefore","added","MongoTimestamp","Connection"],"mappings":"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","file":"packages/mongo/mongo_driver.js.map","sourcesContent":["/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */\n\nvar MongoDB = NpmModuleMongodb;\nvar Future = Npm.require('fibers/future');\n\nMongoInternals = {};\nMongoTest = {};\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = MongoDB;\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\nvar replaceNames = function (filter, thing) {\n  if (typeof thing === \"object\") {\n    if (_.isArray(thing)) {\n      return _.map(thing, _.bind(replaceNames, null, filter));\n    }\n    var ret = {};\n    _.each(thing, function (value, key) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n};\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) { return \"EJSON\" + name; };\nvar unmakeMongoLegal = function (name) { return name.substr(5); };\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(new Buffer(document));\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  _.each(document, function (val, key) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = _.clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  var mongoOptions = Object.assign({\n    // Reconnect on error.\n    autoReconnect: true,\n    // Try to reconnect forever, instead of stopping after 30 tries (the\n    // default), with each attempt separated by 1000ms.\n    reconnectTries: Infinity\n  }, Mongo._connectionOptions);\n\n  // Disable the native parser by default, unless specifically enabled\n  // in the mongo URL.\n  // - The native driver can cause errors which normally would be\n  //   thrown, caught, and handled into segfaults that take down the\n  //   whole app.\n  // - Binary modules don't yet work when you bundle and move the bundle\n  //   to a different platform (aka deploy)\n  // We should revisit this after binary npm module support lands.\n  if (!(/[\\?&]native_?[pP]arser=/.test(url))) {\n    mongoOptions.native_parser = false;\n  }\n\n  // Internally the oplog connections specify their own poolSize\n  // which we don't want to overwrite with any user defined value\n  if (_.has(options, 'poolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.poolSize = options.poolSize;\n  }\n\n  self.db = null;\n  // We keep track of the ReplSet's primary, so that we can trigger hooks when\n  // it changes.  The Node driver's joined callback seems to fire way too\n  // often, which is why we need to track it ourselves.\n  self._primary = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n\n  var connectFuture = new Future;\n  MongoDB.connect(\n    url,\n    mongoOptions,\n    Meteor.bindEnvironment(\n      function (err, db) {\n        if (err) {\n          throw err;\n        }\n\n        // First, figure out what the current primary is, if any.\n        if (db.serverConfig.isMasterDoc) {\n          self._primary = db.serverConfig.isMasterDoc.primary;\n        }\n\n        db.serverConfig.on(\n          'joined', Meteor.bindEnvironment(function (kind, doc) {\n            if (kind === 'primary') {\n              if (doc.primary !== self._primary) {\n                self._primary = doc.primary;\n                self._onFailoverHook.each(function (callback) {\n                  callback();\n                  return true;\n                });\n              }\n            } else if (doc.me === self._primary) {\n              // The thing we thought was primary is now something other than\n              // primary.  Forget that we thought it was primary.  (This means\n              // that if a server stops being primary and then starts being\n              // primary again without another server becoming primary in the\n              // middle, we'll correctly count it as a failover.)\n              self._primary = null;\n            }\n          }));\n\n        // Allow the constructor to return.\n        connectFuture['return'](db);\n      },\n      connectFuture.resolver()  // onException\n    )\n  );\n\n  // Wait for the connection to be successful; throws on failure.\n  self.db = connectFuture.wait();\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n};\n\nMongoConnection.prototype.close = function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  Future.wrap(_.bind(self.db.close, self.db))(true).wait();\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  var future = new Future;\n  self.db.collection(collectionName, future.resolver());\n  return future.wait();\n};\n\nMongoConnection.prototype._createCappedCollection = function (\n    collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"_createCappedCollection called before Connection created?\");\n\n  var future = new Future();\n  self.db.createCollection(\n    collectionName,\n    { capped: true, size: byteSize, max: maxDocuments },\n    future.resolver());\n  future.wait();\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  var fence = DDPServer._CurrentWriteFence.get();\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {committed: function () {}};\n  }\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\n\n//////////// Public API //////////\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype._insert = function (collection_name, document,\n                                              callback) {\n  var self = this;\n\n  var sendError = function (e) {\n    if (callback)\n      return callback(e);\n    throw e;\n  };\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    sendError(e);\n    return;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n        !EJSON._isCustomType(document))) {\n    sendError(new Error(\n      \"Only plain objects may be inserted into MongoDB\"));\n    return;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.insert(replaceTypes(document, replaceMeteorAtomWithMongo),\n                      {safe: true}, callback);\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = function (collectionName, selector) {\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      Meteor.refresh(_.extend({id: id}, refreshKey));\n    });\n  } else {\n    Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype._remove = function (collection_name, selector,\n                                              callback) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    var wrappedCallback = function(err, driverResult) {\n      callback(err, transformResult(driverResult).numberAffected);\n    };\n    collection.remove(replaceTypes(selector, replaceMeteorAtomWithMongo),\n                       {safe: true}, wrappedCallback);\n  } catch (err) {\n    write.committed();\n    throw err;\n  }\n};\n\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collectionName, id: null,\n                    dropCollection: true});\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    var collection = self.rawCollection(collectionName);\n    collection.drop(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype._dropDatabase = function (cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ dropDatabase: true });\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    self.db.dropDatabase(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._update = function (collection_name, selector, mod,\n                                              options, callback) {\n  var self = this;\n\n  if (! callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    if (callback) {\n      return callback(e);\n    } else {\n      throw e;\n    }\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object')\n    throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n  if (!(LocalCollection._isPlainObject(mod) &&\n        !EJSON._isCustomType(mod))) {\n    throw new Error(\n      \"Only plain objects may be used as replacement\" +\n        \" documents in MongoDB\");\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = writeCallback(write, refresh, callback);\n  try {\n    var collection = self.rawCollection(collection_name);\n    var mongoOpts = {safe: true};\n    // explictly enumerate options that minimongo supports\n    if (options.upsert) mongoOpts.upsert = true;\n    if (options.multi) mongoOpts.multi = true;\n    // Lets you get a more more full result from MongoDB. Use with caution:\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n    // with simulated upsert.\n    if (options.fullResult) mongoOpts.fullResult = true;\n\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n    var isModify = LocalCollection._isModificationMod(mongoMod);\n\n    if (options._forbidReplace && !isModify) {\n      var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n      if (callback) {\n        return callback(err);\n      } else {\n        throw err;\n      }\n    }\n\n    // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n    // selector and mod.  We assume it doesn't matter, as far as\n    // the behavior of modifiers is concerned, whether `_modify`\n    // is run on EJSON or on mongo-converted EJSON.\n\n    // Run this code up front so that it fails fast if someone uses\n    // a Mongo update operator we don't support.\n    let knownId;\n    if (options.upsert) {\n      try {\n        let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n        knownId = newDoc._id;\n      } catch (err) {\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    if (options.upsert &&\n        ! isModify &&\n        ! knownId &&\n        options.insertedId &&\n        ! (options.insertedId instanceof Mongo.ObjectID &&\n           options.generatedId)) {\n      // In case of an upsert with a replacement, where there is no _id defined\n      // in either the query or the replacement doc, mongo will generate an id itself. \n      // Therefore we need this special strategy if we want to control the id ourselves.\n\n      // We don't need to do this when:\n      // - This is not a replacement, so we can add an _id to $setOnInsert\n      // - The id is defined by query or mod we can just add it to the replacement doc\n      // - The user did not specify any id preference and the id is a Mongo ObjectId, \n      //     then we can just let Mongo generate the id\n\n      simulateUpsertWithInsertedId(\n        collection, mongoSelector, mongoMod, options,\n        // This callback does not need to be bindEnvironment'ed because\n        // simulateUpsertWithInsertedId() wraps it and then passes it through\n        // bindEnvironmentForWrite.\n        function (error, result) {\n          // If we got here via a upsert() call, then options._returnObject will\n          // be set and we should return the whole object. Otherwise, we should\n          // just return the number of affected docs to match the mongo API.\n          if (result && ! options._returnObject) {\n            callback(error, result.numberAffected);\n          } else {\n            callback(error, result);\n          }\n        }\n      );\n    } else {\n      \n      if (options.upsert && !knownId && options.insertedId && isModify) {\n        if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n          mongoMod.$setOnInsert = {};\n        }\n        knownId = options.insertedId;\n        Object.assign(mongoMod.$setOnInsert, replaceTypes({_id: options.insertedId}, replaceMeteorAtomWithMongo));\n      }\n      \n      collection.update(\n        mongoSelector, mongoMod, mongoOpts,\n        bindEnvironmentForWrite(function (err, result) {\n          if (! err) {\n            var meteorResult = transformResult(result);\n            if (meteorResult && options._returnObject) {\n              // If this was an upsert() call, and we ended up\n              // inserting a new doc and we know its id, then\n              // return that id as well.\n              if (options.upsert && meteorResult.insertedId) {\n                if (knownId) {\n                  meteorResult.insertedId = knownId;\n                } else if (meteorResult.insertedId instanceof MongoDB.ObjectID) {\n                  meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n                }\n              }\n\n              callback(err, meteorResult);\n            } else {\n              callback(err, meteorResult.numberAffected);\n            }\n          } else {\n            callback(err);\n          }\n        }));\n    }\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nvar transformResult = function (driverResult) {\n  var meteorResult = { numberAffected: 0 };\n  if (driverResult) {\n    var mongoResult = driverResult.result;\n\n    // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n    if (mongoResult.upserted) {\n      meteorResult.numberAffected += mongoResult.upserted.length;\n\n      if (mongoResult.upserted.length == 1) {\n        meteorResult.insertedId = mongoResult.upserted[0]._id;\n      }\n    } else {\n      meteorResult.numberAffected = mongoResult.n;\n    }\n  }\n\n  return meteorResult;\n};\n\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err;\n\n  // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (error.indexOf('The _id field cannot be changed') === 0\n    || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = function (collection, selector, mod,\n                                             options, callback) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents, \n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var replacementWithId = Object.assign(\n    replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n    mod);\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = function () {\n    tries--;\n    if (! tries) {\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n    } else {\n      collection.update(selector, mod, mongoOptsForUpdate,\n                        bindEnvironmentForWrite(function (err, result) {\n                          if (err) {\n                            callback(err);\n                          } else if (result && result.result.n != 0) {\n                            callback(null, {\n                              numberAffected: result.result.n\n                            });\n                          } else {\n                            doConditionalInsert();\n                          }\n                        }));\n    }\n  };\n\n  var doConditionalInsert = function () {\n    collection.update(selector, replacementWithId, mongoOptsForInsert,\n                      bindEnvironmentForWrite(function (err, result) {\n                        if (err) {\n                          // figure out if this is a\n                          // \"cannot change _id of document\" error, and\n                          // if so, try doUpdate() again, up to 3 times.\n                          if (MongoConnection._isCannotChangeIdError(err)) {\n                            doUpdate();\n                          } else {\n                            callback(err);\n                          }\n                        } else {\n                          callback(null, {\n                            numberAffected: result.result.upserted.length,\n                            insertedId: insertedId,\n                          });\n                        }\n                      }));\n  };\n\n  doUpdate();\n};\n\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n  MongoConnection.prototype[method] = function (/* arguments */) {\n    var self = this;\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n  };\n});\n\n// XXX MongoConnection.upsert() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsert = function (collectionName, selector, mod,\n                                             options, callback) {\n  var self = this;\n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(collectionName, selector, mod,\n                     _.extend({}, options, {\n                       upsert: true,\n                       _returnObject: true\n                     }), callback);\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOne = function (collection_name, selector,\n                                              options) {\n  var self = this;\n  if (arguments.length === 1)\n    selector = {};\n\n  options = options || {};\n  options.limit = 1;\n  return self.find(collection_name, selector, options).fetch()[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype._ensureIndex = function (collectionName, index,\n                                                   options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.ensureIndex(index, options, future.resolver());\n  future.wait();\n};\nMongoConnection.prototype._dropIndex = function (collectionName, index) {\n  var self = this;\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.dropIndex(index, future.resolver());\n  future.wait();\n};\n\n// CURSORS\n\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\n_.each(['forEach', 'map', 'fetch', 'count'], function (method) {\n  Cursor.prototype[method] = function () {\n    var self = this;\n\n    // You can only observe a tailable cursor.\n    if (self._cursorDescription.options.tailable)\n      throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n\n    if (!self._synchronousCursor) {\n      self._synchronousCursor = self._mongo._createSynchronousCursor(\n        self._cursorDescription, {\n          // Make sure that the \"self\" argument to forEach/map callbacks is the\n          // Cursor, not the SynchronousCursor.\n          selfForIteration: self,\n          useTransform: true\n        });\n    }\n\n    return self._synchronousCursor[method].apply(\n      self._synchronousCursor, arguments);\n  };\n});\n\n// Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\nCursor.prototype.rewind = function () {\n};\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n};\n\n// When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\n\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n};\n\n// Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n};\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeChanges = function (callbacks) {\n  var self = this;\n  var methods = [\n    'addedAt',\n    'added',\n    'changedAt',\n    'changed',\n    'removedAt',\n    'removed',\n    'movedTo'\n  ];\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n\n  // XXX: Can we find out if callbacks are from observe?\n  var exceptionName = ' observe/observeChanges callback'; \n  methods.forEach(function (method) {\n    if (callbacks[method] && typeof callbacks[method] == \"function\") {\n      callbacks[method] = Meteor.bindEnvironment(callbacks[method], method + exceptionName);\n    }\n  });\n  \n  return self._mongo._observeChanges(\n    self._cursorDescription, ordered, callbacks);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function(\n    cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    mongoOptions.tailable = true;\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    mongoOptions.awaitdata = true;\n    // ... and to keep querying the server indefinitely rather than just 5 times\n    // if there's no more data.\n    mongoOptions.numberOfRetries = -1;\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n        cursorDescription.selector.ts) {\n      mongoOptions.oplogReplay = true;\n    }\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    cursorOptions.fields, mongoOptions);\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new SynchronousCursor(dbCursor, cursorDescription, options);\n};\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription;\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n  self._selfForIteration = options.selfForIteration || self;\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(\n      cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  }\n\n  // Need to specify that the callback is the first argument to nextObject,\n  // since otherwise when we try to call it with no args the driver will\n  // interpret \"undefined\" first arg as an options hash and crash.\n  self._synchronousNextObject = Future.wrap(\n    dbCursor.nextObject.bind(dbCursor), 0);\n  self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));\n  self._visitedIds = new LocalCollection._IdMap;\n};\n\n_.extend(SynchronousCursor.prototype, {\n  _nextObject: function () {\n    var self = this;\n\n    while (true) {\n      var doc = self._synchronousNextObject().wait();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform)\n        doc = self._transform(doc);\n\n      return doc;\n    }\n  },\n\n  forEach: function (callback, thisArg) {\n    var self = this;\n\n    // Get back to the beginning.\n    self._rewind();\n\n    // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n    var index = 0;\n    while (true) {\n      var doc = self._nextObject();\n      if (!doc) return;\n      callback.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(callback.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n\n  _rewind: function () {\n    var self = this;\n\n    // known to be synchronous\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap;\n  },\n\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n\n  fetch: function () {\n    var self = this;\n    return self.map(_.identity);\n  },\n\n  count: function (applySkipLimit = false) {\n    var self = this;\n    return self._synchronousCount(applySkipLimit).wait();\n  },\n\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nMongoConnection.prototype.tail = function (cursorDescription, docCallback) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n  var loop = function () {\n    var doc = null;\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        doc = cursor._nextObject();\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error\n        // from Mongo. Ah well. But either way, we need to retry the cursor\n        // (unless the failure was because the observe got stopped).\n        doc = null;\n      }\n      // Since cursor._nextObject can yield, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = _.clone(cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createSynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        Meteor.setTimeout(loop, 100);\n        break;\n      }\n    }\n  };\n\n  Meteor.defer(loop);\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nMongoConnection.prototype._observeChanges = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  if (cursorDescription.options.tailable) {\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n  }\n\n  // You may not filter out _id when observing changes, because the id is a core\n  // part of the observeChanges API.\n  if (cursorDescription.options.fields &&\n      (cursorDescription.options.fields._id === 0 ||\n       cursorDescription.options.fields._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n  }\n\n  var observeKey = EJSON.stringify(\n    _.extend({ordered: ordered}, cursorDescription));\n\n  var multiplexer, observeDriver;\n  var firstHandle = false;\n\n  // Find a matching ObserveMultiplexer, or create a new one. This next block is\n  // guaranteed to not yield (and it doesn't call anything that can observe a\n  // new query), so no other calls to this function can interleave with it.\n  Meteor._noYieldsAllowed(function () {\n    if (_.has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          observeDriver.stop();\n        }\n      });\n      self._observeMultiplexers[observeKey] = multiplexer;\n    }\n  });\n\n  var observeHandle = new ObserveHandle(multiplexer, callbacks);\n\n  if (firstHandle) {\n    var matcher, sorter;\n    var canUseOplog = _.all([\n      function () {\n        // At a bare minimum, using the oplog requires us to have an oplog, to\n        // want unordered callbacks, and to not want a callback on the polls\n        // that won't happen.\n        return self._oplogHandle && !ordered &&\n          !callbacks._testOnlyPollCallback;\n      }, function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }, function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      }, function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort)\n          return true;\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort,\n                                        { matcher: matcher });\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }], function (f) { return f(); });  // invoke each function\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher,  // ignored by polling\n      sorter: sorter,  // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n    });\n\n    // This field is only set for use in tests.\n    multiplexer._observeDriver = observeDriver;\n  }\n\n  // Blocks until the initial adds have been sent.\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n  return observeHandle;\n};\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nlistenAll = function (cursorDescription, listenCallback) {\n  var listeners = [];\n  forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(\n      trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      _.each(listeners, function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = function (cursorDescription, triggerCallback) {\n  var key = {collection: cursorDescription.collectionName};\n  var specificIds = LocalCollection._idsMatchedBySelector(\n    cursorDescription.selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      triggerCallback(_.extend({id: id}, key));\n    });\n    triggerCallback(_.extend({dropCollection: true, id: null}, key));\n  } else {\n    triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  triggerCallback({ dropDatabase: true });\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n      (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n                    + \" tailable cursor without a \"\n                    + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n\nMongoInternals.Connection = MongoConnection;\n"]},"hash":"daf554c07b5cb756ac3b5dbdd4b880c872aac0dc"}
