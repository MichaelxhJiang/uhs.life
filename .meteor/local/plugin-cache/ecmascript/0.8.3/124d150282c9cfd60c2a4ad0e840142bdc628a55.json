{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./namespace.js","imported":["DDP","LivedataTest"],"specifiers":[{"kind":"named","imported":"DDP","local":"DDP"},{"kind":"named","imported":"LivedataTest","local":"LivedataTest"}]},{"source":"./id_map.js","imported":["MongoIDMap"],"specifiers":[{"kind":"named","imported":"MongoIDMap","local":"MongoIDMap"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/ddp-client/livedata_connection.js","filenameRelative":"packages/ddp-client/livedata_connection.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ddp-client/livedata_connection.js.map","sourceFileName":"packages/ddp-client/livedata_connection.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"livedata_connection"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar DDP = void 0,\n    LivedataTest = void 0;\nmodule.watch(require(\"./namespace.js\"), {\n  DDP: function (v) {\n    DDP = v;\n  },\n  LivedataTest: function (v) {\n    LivedataTest = v;\n  }\n}, 0);\nvar MongoIDMap = void 0;\nmodule.watch(require(\"./id_map.js\"), {\n  MongoIDMap: function (v) {\n    MongoIDMap = v;\n  }\n}, 1);\n\nif (Meteor.isServer) {\n  var Fiber = Npm.require('fibers');\n\n  var Future = Npm.require('fibers/future');\n} // @param url {String|Object} URL to Meteor app,\n//   or an object as a test hook (see code)\n// Options:\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n//   headers: extra headers to send on the websockets connection, for\n//     server-to-server DDP only\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n//\n// XXX There should be a way to destroy a DDP connection, causing all\n// outstanding method calls to fail.\n//\n// XXX Our current way of handling failure and reconnection is great\n// for an app (where we want to tolerate being disconnected as an\n// expect state, and keep trying forever to reconnect) but cumbersome\n// for something like a command line tool that wants to make a\n// connection, call a method, and print an error if connection\n// fails. We should have better usability in the latter case (while\n// still transparently reconnecting if it's just a transient failure\n// or the server migrating us).\n\n\nvar Connection = function (url, options) {\n  var self = this;\n  options = _.extend({\n    onConnected: function () {},\n    onDDPVersionNegotiationFailure: function (description) {\n      Meteor._debug(description);\n    },\n    heartbeatInterval: 17500,\n    heartbeatTimeout: 15000,\n    npmFayeOptions: {},\n    // These options are only for testing.\n    reloadWithOutstanding: false,\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n    retry: true,\n    respondToPings: true,\n    // When updates are coming within this ms interval, batch them together.\n    bufferedWritesInterval: 5,\n    // Flush buffers immediately if writes are happening continuously for more than this many ms.\n    bufferedWritesMaxAge: 500\n  }, options); // If set, called when we reconnect, queuing method calls _before_ the\n  // existing outstanding ones.\n  // NOTE: This feature has been preserved for backwards compatibility. The\n  // preferred method of setting a callback on reconnect is to use\n  // DDP.onReconnect.\n\n  self.onReconnect = null; // as a test hook, allow passing a stream instead of a url.\n\n  if ((typeof url === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(url)) === \"object\") {\n    self._stream = url;\n  } else {\n    self._stream = new LivedataTest.ClientStream(url, {\n      retry: options.retry,\n      headers: options.headers,\n      _sockjsOptions: options._sockjsOptions,\n      // Used to keep some tests quiet, or for other cases in which\n      // the right thing to do with connection errors is to silently\n      // fail (e.g. sending package usage stats). At some point we\n      // should have a real API for handling client-stream-level\n      // errors.\n      _dontPrintErrors: options._dontPrintErrors,\n      connectTimeoutMs: options.connectTimeoutMs,\n      npmFayeOptions: options.npmFayeOptions\n    });\n  }\n\n  self._lastSessionId = null;\n  self._versionSuggestion = null; // The last proposed DDP version.\n\n  self._version = null; // The DDP version agreed on by client and server.\n\n  self._stores = {}; // name -> object with methods\n\n  self._methodHandlers = {}; // name -> func\n\n  self._nextMethodId = 1;\n  self._supportedDDPVersions = options.supportedDDPVersions;\n  self._heartbeatInterval = options.heartbeatInterval;\n  self._heartbeatTimeout = options.heartbeatTimeout; // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all\n  // of their writes to be written to the local cache). Map from method ID to\n  // MethodInvoker object.\n\n  self._methodInvokers = {}; // Tracks methods which the user has called but whose result messages have not\n  // arrived yet.\n  //\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n  // represents a set of methods that can run at the same time. The first block\n  // represents the methods which are currently in flight; subsequent blocks\n  // must wait for previous blocks to be fully finished before they can be sent\n  // to the server.\n  //\n  // Each block is an object with the following fields:\n  // - methods: a list of MethodInvoker objects\n  // - wait: a boolean; if true, this block had a single method invoked with\n  //         the \"wait\" option\n  //\n  // There will never be adjacent blocks with wait=false, because the only thing\n  // that makes methods need to be serialized is a wait method.\n  //\n  // Methods are removed from the first block when their \"result\" is\n  // received. The entire first block is only removed when all of the in-flight\n  // methods have received their results (so the \"methods\" list is empty) *AND*\n  // all of the data written by those methods are visible in the local cache. So\n  // it is possible for the first block's methods list to be empty, if we are\n  // still waiting for some objects to quiesce.\n  //\n  // Example:\n  //  _outstandingMethodBlocks = [\n  //    {wait: false, methods: []},\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n  //                            <MethodInvoker for 'bar'>]}]\n  // This means that there were some methods which were sent to the server and\n  // which have returned their results, but some of the data written by\n  // the methods may not be visible in the local cache. Once all that data is\n  // visible, we will send a 'login' method. Once the login method has returned\n  // and all the data is visible (including re-running subs if userId changes),\n  // we will send the 'foo' and 'bar' methods in parallel.\n\n  self._outstandingMethodBlocks = []; // method ID -> array of objects with keys 'collection' and 'id', listing\n  // documents written by a given method's stub. keys are associated with\n  // methods whose stub wrote at least one document, and whose data-done message\n  // has not yet been received.\n\n  self._documentsWrittenByStub = {}; // collection -> IdMap of \"server document\" object. A \"server document\" has:\n  // - \"document\": the version of the document according the\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n  //   received from the server)\n  //   It is undefined if we think the document does not exist\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n  //   whose \"data done\" messages have not yet been processed\n\n  self._serverDocuments = {}; // Array of callbacks to be called after the next update of the local\n  // cache. Used for:\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n  //    the relevant data is flushed.\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n  //    quiescence. Specifically, methods whose result was received over the old\n  //    connection (so we don't re-send it) but whose data had not been made\n  //    visible.\n\n  self._afterUpdateCallbacks = []; // In two contexts, we buffer all incoming data messages and then process them\n  // all at once in a single update:\n  //   - During reconnect, we buffer all data messages until all subs that had\n  //     been ready before reconnect are ready again, and all methods that are\n  //     active have returned their \"data done message\"; then\n  //   - During the execution of a \"wait\" method, we buffer all data messages\n  //     until the wait method gets its \"data done\" message. (If the wait method\n  //     occurs during reconnect, it doesn't get any special handling.)\n  // all data messages are processed in one update.\n  //\n  // The following fields are used for this \"quiescence\" process.\n  // This buffers the messages that aren't being processed yet.\n\n  self._messagesBufferedUntilQuiescence = []; // Map from method ID -> true. Methods are removed from this when their\n  // \"data done\" message is received, and we will not quiesce until it is\n  // empty.\n\n  self._methodsBlockingQuiescence = {}; // map from sub ID -> true for subs that were ready (ie, called the sub\n  // ready callback) before reconnect but haven't become ready again yet\n\n  self._subsBeingRevived = {}; // map from sub._id -> true\n  // if true, the next data update should reset all stores. (set during\n  // reconnect.)\n\n  self._resetStores = false; // name -> array of updates for (yet to be created) collections\n\n  self._updatesForUnknownStores = {}; // if we're blocking a migration, the retry func\n\n  self._retryMigrate = null;\n  self.__flushBufferedWrites = Meteor.bindEnvironment(self._flushBufferedWrites, \"flushing DDP buffered writes\", self); // Collection name -> array of messages.\n\n  self._bufferedWrites = {}; // When current buffer of updates must be flushed at, in ms timestamp.\n\n  self._bufferedWritesFlushAt = null; // Timeout handle for the next processing of all pending writes\n\n  self._bufferedWritesFlushHandle = null;\n  self._bufferedWritesInterval = options.bufferedWritesInterval;\n  self._bufferedWritesMaxAge = options.bufferedWritesMaxAge; // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id\n  //   - name\n  //   - params\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\n  //   - ready (has the 'ready' message been received?)\n  //   - readyCallback (an optional callback to call when ready)\n  //   - errorCallback (an optional callback to call if the sub terminates with\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\n  //   - stopCallback (an optional callback to call when the sub terminates\n  //     for any reason, with an error argument if an error triggered the stop)\n\n  self._subscriptions = {}; // Reactive userId.\n\n  self._userId = null;\n  self._userIdDeps = new Tracker.Dependency(); // Block auto-reload while we're waiting for method responses.\n\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n    Package.reload.Reload._onMigrate(function (retry) {\n      if (!self._readyToMigrate()) {\n        if (self._retryMigrate) throw new Error(\"Two migrations in progress?\");\n        self._retryMigrate = retry;\n        return false;\n      } else {\n        return [true];\n      }\n    });\n  }\n\n  var onMessage = function (raw_msg) {\n    try {\n      var msg = DDPCommon.parseDDP(raw_msg);\n    } catch (e) {\n      Meteor._debug(\"Exception while parsing DDP\", e);\n\n      return;\n    } // Any message counts as receiving a pong, as it demonstrates that\n    // the server is still alive.\n\n\n    if (self._heartbeat) {\n      self._heartbeat.messageReceived();\n    }\n\n    if (msg === null || !msg.msg) {\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n      // compat.  Remove this 'if' once the server stops sending welcome\n      // messages (stream_server.js).\n      if (!(msg && msg.server_id)) Meteor._debug(\"discarding invalid livedata message\", msg);\n      return;\n    }\n\n    if (msg.msg === 'connected') {\n      self._version = self._versionSuggestion;\n\n      self._livedata_connected(msg);\n\n      options.onConnected();\n    } else if (msg.msg === 'failed') {\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\n        self._versionSuggestion = msg.version;\n\n        self._stream.reconnect({\n          _force: true\n        });\n      } else {\n        var description = \"DDP version negotiation failed; server requested version \" + msg.version;\n\n        self._stream.disconnect({\n          _permanent: true,\n          _error: description\n        });\n\n        options.onDDPVersionNegotiationFailure(description);\n      }\n    } else if (msg.msg === 'ping' && options.respondToPings) {\n      self._send({\n        msg: \"pong\",\n        id: msg.id\n      });\n    } else if (msg.msg === 'pong') {// noop, as we assume everything's a pong\n    } else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg)) self._livedata_data(msg);else if (msg.msg === 'nosub') self._livedata_nosub(msg);else if (msg.msg === 'result') self._livedata_result(msg);else if (msg.msg === 'error') self._livedata_error(msg);else Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };\n\n  var onReset = function () {\n    // Send a connect message at the beginning of the stream.\n    // NOTE: reset is called even on the first connection, so this is\n    // the only place we send this message.\n    var msg = {\n      msg: 'connect'\n    };\n    if (self._lastSessionId) msg.session = self._lastSessionId;\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n    self._versionSuggestion = msg.version;\n    msg.support = self._supportedDDPVersions;\n\n    self._send(msg); // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n    // current block is pretty important to making sure that quiescence is properly calculated, as\n    // well as possibly moving on to another useful block.\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n    // we are connecting for the first time.\n\n\n    if (self._outstandingMethodBlocks.length > 0) {\n      // If there is an outstanding method block, we only care about the first one as that is the\n      // one that could have already sent messages with no response, that are not allowed to retry.\n      var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n      self._outstandingMethodBlocks[0].methods = currentMethodBlock.filter(function (methodInvoker) {\n        // Methods with 'noRetry' option set are not allowed to re-send after\n        // recovering dropped connection.\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n          // Make sure that the method is told that it failed.\n          methodInvoker.receiveResult(new Meteor.Error('invocation-failed', 'Method invocation might have failed due to dropped connection. ' + 'Failing because `noRetry` option was passed to Meteor.apply.'));\n        } // Only keep a method if it wasn't sent or it's allowed to retry.\n        // This may leave the block empty, but we don't move on to the next\n        // block until the callback has been delivered, in _outstandingMethodFinished.\n\n\n        return !(methodInvoker.sentMessage && methodInvoker.noRetry);\n      });\n    } // Now, to minimize setup latency, go ahead and blast out all of\n    // our pending methods ands subscriptions before we've even taken\n    // the necessary RTT to know if we successfully reconnected. (1)\n    // They're supposed to be idempotent, and where they are not,\n    // they can block retry in apply; (2) even if we did reconnect,\n    // we're not sure what messages might have gotten lost\n    // (in either direction) since we were disconnected (TCP being\n    // sloppy about that.)\n    // If the current block of methods all got their results (but didn't all get\n    // their data visible), discard the empty block now.\n\n\n    if (!_.isEmpty(self._outstandingMethodBlocks) && _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n      self._outstandingMethodBlocks.shift();\n    } // Mark all messages as unsent, they have not yet been sent on this\n    // connection.\n\n\n    _.each(self._methodInvokers, function (m) {\n      m.sentMessage = false;\n    }); // If an `onReconnect` handler is set, call it first. Go through\n    // some hoops to ensure that methods that are called from within\n    // `onReconnect` get executed _before_ ones that were originally\n    // outstanding (since `onReconnect` is used to re-establish auth\n    // certificates)\n\n\n    self._callOnReconnectAndSendAppropriateOutstandingMethods(); // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.\n\n\n    _.each(self._subscriptions, function (sub, id) {\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: sub.name,\n        params: sub.params\n      });\n    });\n  };\n\n  var onDisconnect = function () {\n    if (self._heartbeat) {\n      self._heartbeat.stop();\n\n      self._heartbeat = null;\n    }\n  };\n\n  if (Meteor.isServer) {\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n  } else {\n    self._stream.on('message', onMessage);\n\n    self._stream.on('reset', onReset);\n\n    self._stream.on('disconnect', onDisconnect);\n  }\n}; // A MethodInvoker manages sending a method to the server and calling the user's\n// callbacks. On construction, it registers itself in the connection's\n// _methodInvokers map; it removes itself once the method is fully finished and\n// the callback is invoked. This occurs when it has both received a result,\n// and the data written by it is fully visible.\n\n\nvar MethodInvoker = function (options) {\n  var self = this; // Public (within this file) fields.\n\n  self.methodId = options.methodId;\n  self.sentMessage = false;\n  self._callback = options.callback;\n  self._connection = options.connection;\n  self._message = options.message;\n\n  self._onResultReceived = options.onResultReceived || function () {};\n\n  self._wait = options.wait;\n  self.noRetry = options.noRetry;\n  self._methodResult = null;\n  self._dataVisible = false; // Register with the connection.\n\n  self._connection._methodInvokers[self.methodId] = self;\n};\n\n_.extend(MethodInvoker.prototype, {\n  // Sends the method message to the server. May be called additional times if\n  // we lose the connection and reconnect before receiving a result.\n  sendMessage: function () {\n    var self = this; // This function is called before sending a method (including resending on\n    // reconnect). We should only (re)send methods where we don't already have a\n    // result!\n\n    if (self.gotResult()) throw new Error(\"sendingMethod is called on method with result\"); // If we're re-sending it, it doesn't matter if data was written the first\n    // time.\n\n    self._dataVisible = false;\n    self.sentMessage = true; // If this is a wait method, make all data messages be buffered until it is\n    // done.\n\n    if (self._wait) self._connection._methodsBlockingQuiescence[self.methodId] = true; // Actually send the message.\n\n    self._connection._send(self._message);\n  },\n  // Invoke the callback, if we have both a result and know that all data has\n  // been written to the local cache.\n  _maybeInvokeCallback: function () {\n    var self = this;\n\n    if (self._methodResult && self._dataVisible) {\n      // Call the callback. (This won't throw: the callback was wrapped with\n      // bindEnvironment.)\n      self._callback(self._methodResult[0], self._methodResult[1]); // Forget about this method.\n\n\n      delete self._connection._methodInvokers[self.methodId]; // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.\n\n      self._connection._outstandingMethodFinished();\n    }\n  },\n  // Call with the result of the method from the server. Only may be called\n  // once; once it is called, you should not call sendMessage again.\n  // If the user provided an onResultReceived callback, call it immediately.\n  // Then invoke the main callback if data is also visible.\n  receiveResult: function (err, result) {\n    var self = this;\n    if (self.gotResult()) throw new Error(\"Methods should only receive results once\");\n    self._methodResult = [err, result];\n\n    self._onResultReceived(err, result);\n\n    self._maybeInvokeCallback();\n  },\n  // Call this when all data written by the method is visible. This means that\n  // the method has returns its \"data is done\" message *AND* all server\n  // documents that are buffered at that time have been written to the local\n  // cache. Invokes the main callback if the result has been received.\n  dataVisible: function () {\n    var self = this;\n    self._dataVisible = true;\n\n    self._maybeInvokeCallback();\n  },\n  // True if receiveResult has been called.\n  gotResult: function () {\n    var self = this;\n    return !!self._methodResult;\n  }\n});\n\n_.extend(Connection.prototype, {\n  // 'name' is the name of the data on the wire that should go in the\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n  registerStore: function (name, wrappedStore) {\n    var self = this;\n    if (name in self._stores) return false; // Wrap the input object in an object which makes any store method not\n    // implemented by 'store' into a no-op.\n\n    var store = {};\n\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals', 'retrieveOriginals', 'getDoc', '_getCollection'], function (method) {\n      store[method] = function () {\n        return wrappedStore[method] ? wrappedStore[method].apply(wrappedStore, arguments) : undefined;\n      };\n    });\n\n    self._stores[name] = store;\n    var queued = self._updatesForUnknownStores[name];\n\n    if (queued) {\n      store.beginUpdate(queued.length, false);\n\n      _.each(queued, function (msg) {\n        store.update(msg);\n      });\n\n      store.endUpdate();\n      delete self._updatesForUnknownStores[name];\n    }\n\n    return true;\n  },\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Subscribe to a record set.  Returns a handle that provides\n   * `stop()` and `ready()` methods.\n   * @locus Client\n   * @param {String} name Name of the subscription.  Matches the name of the\n   * server's `publish()` call.\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n   * function on server.\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n   * and `onReady` callbacks. If there is an error, it is passed as an\n   * argument to `onStop`. If a function is passed instead of an object, it\n   * is interpreted as an `onReady` callback.\n   */subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\n    var self = this;\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n\n      if (_.isFunction(lastParam)) {\n        callbacks.onReady = params.pop();\n      } else if (lastParam && // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n      // onStop with an error callback instead.\n      _.any([lastParam.onReady, lastParam.onError, lastParam.onStop], _.isFunction)) {\n        callbacks = params.pop();\n      }\n    } // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n\n\n    var existing = _.find(self._subscriptions, function (sub) {\n      return sub.inactive && sub.name === name && EJSON.equals(sub.params, params);\n    });\n\n    var id;\n\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false; // reactivate\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        // If the sub is already ready, run the ready callback right away.\n        // It seems that users would expect an onReady callback inside an\n        // autorun to trigger once the the sub first becomes ready and also\n        // when re-subs happens.\n        if (existing.ready) {\n          callbacks.onReady();\n        } else {\n          existing.readyCallback = callbacks.onReady;\n        }\n      } // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n      // onStop with an optional error argument\n\n\n      if (callbacks.onError) {\n        // Replace existing callback if any, so that errors aren't\n        // double-reported.\n        existing.errorCallback = callbacks.onError;\n      }\n\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n    } else {\n      // New sub! Generate an id, save it locally, and send message.\n      id = Random.id();\n      self._subscriptions[id] = {\n        id: id,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Tracker.Dependency(),\n        readyCallback: callbacks.onReady,\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        errorCallback: callbacks.onError,\n        stopCallback: callbacks.onStop,\n        connection: self,\n        remove: function () {\n          delete this.connection._subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n        },\n        stop: function () {\n          this.connection._send({\n            msg: 'unsub',\n            id: id\n          });\n\n          this.remove();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: name,\n        params: params\n      });\n    } // return a handle to the application.\n\n\n    var handle = {\n      stop: function () {\n        if (!_.has(self._subscriptions, id)) return;\n\n        self._subscriptions[id].stop();\n      },\n      ready: function () {\n        // return false if we've unsubscribed.\n        if (!_.has(self._subscriptions, id)) return false;\n        var record = self._subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Tracker.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Tracker.onInvalidate(function (c) {\n        if (_.has(self._subscriptions, id)) self._subscriptions[id].inactive = true;\n        Tracker.afterFlush(function () {\n          if (_.has(self._subscriptions, id) && self._subscriptions[id].inactive) handle.stop();\n        });\n      });\n    }\n\n    return handle;\n  },\n  // options:\n  // - onLateError {Function(error)} called if an error was received after the ready event.\n  //     (errors received before ready cause an error to be thrown)\n  _subscribeAndWait: function (name, args, options) {\n    var self = this;\n    var f = new Future();\n    var ready = false;\n    var handle;\n    args = args || [];\n    args.push({\n      onReady: function () {\n        ready = true;\n        f['return']();\n      },\n      onError: function (e) {\n        if (!ready) f['throw'](e);else options && options.onLateError && options.onLateError(e);\n      }\n    });\n    handle = self.subscribe.apply(self, [name].concat(args));\n    f.wait();\n    return handle;\n  },\n  methods: function (methods) {\n    var self = this;\n\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self._methodHandlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self._methodHandlers[name] = func;\n    });\n  },\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invokes a method passing any number of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */call: function (name /* .. [arguments] .. callback */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n  // @param options {Optional Object}\n  //   wait: Boolean - Should we wait to call this until all current methods\n  //                   are fully finished, and block subsequent method calls\n  //                   until this method is fully finished?\n  //                   (does not affect methods called from within this method)\n  //   onResultReceived: Function - a callback to call as soon as the method\n  //                                result is received. the data written by\n  //                                the method may not yet be in the cache!\n  //   returnStubValue: Boolean - If true then in cases where we would have\n  //                              otherwise discarded the stub's return value\n  //                              and returned undefined, instead we go ahead\n  //                              and return it.  Specifically, this is any\n  //                              time other than when (a) we are already\n  //                              inside a stub or (b) we are in Node and no\n  //                              callback was provided.  Currently we require\n  //                              this flag to be explicitly passed to reduce\n  //                              the likelihood that stub return values will\n  //                              be confused with server return values; we\n  //                              may improve this in future.\n  // @param callback {Optional Function}\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invoke a method passing an array of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable[]} args Method arguments\n   * @param {Object} [options]\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Boolean} options.throwStubExceptions (Client only) If true, exceptions thrown by method stubs will be thrown instead of logged, and the method will not be invoked on the server.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n   */apply: function (name, args, options, callback) {\n    var self = this; // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n\n    if (callback) {\n      // XXX would it be better form to do the binding in stream.on,\n      // or caller, instead of here?\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");\n    } // Keep our args safe from mutation (eg if we don't send the message for a\n    // while because of a wait method).\n\n\n    args = EJSON.clone(args); // Lazily allocate method ID once we know that it'll be needed.\n\n    var methodId = function () {\n      var id;\n      return function () {\n        if (id === undefined) id = '' + self._nextMethodId++;\n        return id;\n      };\n    }();\n\n    var enclosing = DDP._CurrentMethodInvocation.get();\n\n    var alreadyInSimulation = enclosing && enclosing.isSimulation; // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client\n    // and the server; if the client doesn't generate any 'random' values\n    // then we don't expect the server to generate any either.\n    // Less commonly, the server may perform different actions from the client,\n    // and may in fact generate values where the client did not, but we don't\n    // have any client-side values to match, so even here we may as well just\n    // use a random seed on the server.  In that case, we don't pass the\n    // randomSeed to save bandwidth, and we don't even generate it to save a\n    // bit of CPU and to avoid consuming entropy.\n\n    var randomSeed = null;\n\n    var randomSeedGenerator = function () {\n      if (randomSeed === null) {\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n      }\n\n      return randomSeed;\n    }; // Run the stub, if we have one. The stub is supposed to make some\n    // temporary writes to the database to give the user a smooth experience\n    // until the actual result of executing the method comes back from the\n    // server (whereupon the temporary writes to the database will be reversed\n    // during the beginUpdate/endUpdate process.)\n    //\n    // Normally, we ignore the return value of the stub (even if it is an\n    // exception), in favor of the real return value from the server. The\n    // exception is if the *caller* is a stub. In that case, we're not going\n    // to do a RPC, so we use the return value of the stub as our return\n    // value.\n\n\n    var stub = self._methodHandlers[name];\n\n    if (stub) {\n      var setUserId = function (userId) {\n        self.setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: true,\n        userId: self.userId(),\n        setUserId: setUserId,\n        randomSeed: function () {\n          return randomSeedGenerator();\n        }\n      });\n      if (!alreadyInSimulation) self._saveOriginals();\n\n      try {\n        // Note that unlike in the corresponding server code, we never audit\n        // that stubs check() their arguments.\n        var stubReturnValue = DDP._CurrentMethodInvocation.withValue(invocation, function () {\n          if (Meteor.isServer) {\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\n            // don't allow stubs to yield.\n            return Meteor._noYieldsAllowed(function () {\n              // re-clone, so that the stub can't affect our caller's values\n              return stub.apply(invocation, EJSON.clone(args));\n            });\n          } else {\n            return stub.apply(invocation, EJSON.clone(args));\n          }\n        });\n      } catch (e) {\n        var exception = e;\n      }\n\n      if (!alreadyInSimulation) self._retrieveAndStoreOriginals(methodId());\n    } // If we're in a simulation, stop and return the result we have,\n    // rather than going on to do an RPC. If there was no stub,\n    // we'll end up returning undefined.\n\n\n    if (alreadyInSimulation) {\n      if (callback) {\n        callback(exception, stubReturnValue);\n        return undefined;\n      }\n\n      if (exception) throw exception;\n      return stubReturnValue;\n    } // If an exception occurred in a stub, and we're ignoring it\n    // because we're doing an RPC and want to use what the server\n    // returns instead, log it so the developer knows\n    // (unless they explicitly ask to see the error).\n    //\n    // Tests can set the 'expected' flag on an exception so it won't\n    // go to log.\n\n\n    if (exception) {\n      if (options.throwStubExceptions) {\n        throw exception;\n      } else if (!exception.expected) {\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" + name + \"'\", exception, exception.stack);\n      }\n    } // At this point we're definitely doing an RPC, and we're going to\n    // return the value of the RPC to the caller.\n    // If the caller didn't give a callback, decide what to do.\n\n\n    if (!callback) {\n      if (Meteor.isClient) {\n        // On the client, we don't have fibers, so we can't block. The\n        // only thing we can do is to return undefined and discard the\n        // result of the RPC. If an error occurred then print the error\n        // to the console.\n        callback = function (err) {\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\", err.message);\n        };\n      } else {\n        // On the server, make the function synchronous. Throw on\n        // errors, return on success.\n        var future = new Future();\n        callback = future.resolver();\n      }\n    } // Send the RPC. Note that on the client, it is important that the\n    // stub have finished before we send the RPC, so that we know we have\n    // a complete list of which local documents the stub wrote.\n\n\n    var message = {\n      msg: 'method',\n      method: name,\n      params: args,\n      id: methodId()\n    }; // Send the randomSeed only if we used it\n\n    if (randomSeed !== null) {\n      message.randomSeed = randomSeed;\n    }\n\n    var methodInvoker = new MethodInvoker({\n      methodId: methodId(),\n      callback: callback,\n      connection: self,\n      onResultReceived: options.onResultReceived,\n      wait: !!options.wait,\n      message: message,\n      noRetry: !!options.noRetry\n    });\n\n    if (options.wait) {\n      // It's a wait method! Wait methods go in their own block.\n      self._outstandingMethodBlocks.push({\n        wait: true,\n        methods: [methodInvoker]\n      });\n    } else {\n      // Not a wait method. Start a new block if the previous block was a wait\n      // block, and add it to the last block of methods.\n      if (_.isEmpty(self._outstandingMethodBlocks) || _.last(self._outstandingMethodBlocks).wait) self._outstandingMethodBlocks.push({\n        wait: false,\n        methods: []\n      });\n\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n    } // If we added it to the first block, send it out now.\n\n\n    if (self._outstandingMethodBlocks.length === 1) methodInvoker.sendMessage(); // If we're using the default callback on the server,\n    // block waiting for the result.\n\n    if (future) {\n      return future.wait();\n    }\n\n    return options.returnStubValue ? stubReturnValue : undefined;\n  },\n  // Before calling a method stub, prepare all stores to track changes and allow\n  // _retrieveAndStoreOriginals to get the original versions of changed\n  // documents.\n  _saveOriginals: function () {\n    var self = this;\n    if (!self._waitingForQuiescence()) self._flushBufferedWrites();\n\n    _.each(self._stores, function (s) {\n      s.saveOriginals();\n    });\n  },\n  // Retrieves the original versions of all documents modified by the stub for\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n  // by document) and _documentsWrittenByStub (keyed by method ID).\n  _retrieveAndStoreOriginals: function (methodId) {\n    var self = this;\n    if (self._documentsWrittenByStub[methodId]) throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n    var docsWritten = [];\n\n    _.each(self._stores, function (s, collection) {\n      var originals = s.retrieveOriginals(); // not all stores define retrieveOriginals\n\n      if (!originals) return;\n      originals.forEach(function (doc, id) {\n        docsWritten.push({\n          collection: collection,\n          id: id\n        });\n        if (!_.has(self._serverDocuments, collection)) self._serverDocuments[collection] = new MongoIDMap();\n\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n\n        if (serverDoc.writtenByStubs) {\n          // We're not the first stub to write this doc. Just add our method ID\n          // to the record.\n          serverDoc.writtenByStubs[methodId] = true;\n        } else {\n          // First stub! Save the original value and our method ID.\n          serverDoc.document = doc;\n          serverDoc.flushCallbacks = [];\n          serverDoc.writtenByStubs = {};\n          serverDoc.writtenByStubs[methodId] = true;\n        }\n      });\n    });\n\n    if (!_.isEmpty(docsWritten)) {\n      self._documentsWrittenByStub[methodId] = docsWritten;\n    }\n  },\n  // This is very much a private function we use to make the tests\n  // take up fewer server resources after they complete.\n  _unsubscribeAll: function () {\n    var self = this;\n\n    _.each(_.clone(self._subscriptions), function (sub, id) {\n      // Avoid killing the autoupdate subscription so that developers\n      // still get hot code pushes when writing tests.\n      //\n      // XXX it's a hack to encode knowledge about autoupdate here,\n      // but it doesn't seem worth it yet to have a special API for\n      // subscriptions to preserve after unit tests.\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n        self._subscriptions[id].stop();\n      }\n    });\n  },\n  // Sends the DDP stringification of the given message object\n  _send: function (obj) {\n    var self = this;\n\n    self._stream.send(DDPCommon.stringifyDDP(obj));\n  },\n  // We detected via DDP-level heartbeats that we've lost the\n  // connection.  Unlike `disconnect` or `close`, a lost connection\n  // will be automatically retried.\n  _lostConnection: function (error) {\n    var self = this;\n\n    self._stream._lostConnection(error);\n  },\n  /**\n   * @summary Get the current connection status. A reactive data source.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */status: function () /*passthrough args*/{\n    var self = this;\n    return self._stream.status.apply(self._stream, arguments);\n  },\n  /**\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n   This method does nothing if the client is already connected.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */reconnect: function () /*passthrough args*/{\n    var self = this;\n    return self._stream.reconnect.apply(self._stream, arguments);\n  },\n  /**\n   * @summary Disconnect the client from the server.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */disconnect: function () /*passthrough args*/{\n    var self = this;\n    return self._stream.disconnect.apply(self._stream, arguments);\n  },\n  close: function () {\n    var self = this;\n    return self._stream.disconnect({\n      _permanent: true\n    });\n  },\n  ///\n  /// Reactive user system\n  ///\n  userId: function () {\n    var self = this;\n    if (self._userIdDeps) self._userIdDeps.depend();\n    return self._userId;\n  },\n  setUserId: function (userId) {\n    var self = this; // Avoid invalidating dependents if setUserId is called with current value.\n\n    if (self._userId === userId) return;\n    self._userId = userId;\n    if (self._userIdDeps) self._userIdDeps.changed();\n  },\n  // Returns true if we are in a state after reconnect of waiting for subs to be\n  // revived or early methods to finish their data, or we are waiting for a\n  // \"wait\" method to finish.\n  _waitingForQuiescence: function () {\n    var self = this;\n    return !_.isEmpty(self._subsBeingRevived) || !_.isEmpty(self._methodsBlockingQuiescence);\n  },\n  // Returns true if any method whose message has been sent to the server has\n  // not yet invoked its user callback.\n  _anyMethodsAreOutstanding: function () {\n    var self = this;\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n  },\n  _livedata_connected: function (msg) {\n    var self = this;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout: function () {\n          self._lostConnection(new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n        },\n        sendPing: function () {\n          self._send({\n            msg: 'ping'\n          });\n        }\n      });\n\n      self._heartbeat.start();\n    } // If this is a reconnect, we'll have to reset all stores.\n\n\n    if (self._lastSessionId) self._resetStores = true;\n\n    if (typeof msg.session === \"string\") {\n      var reconnectedToPreviousSession = self._lastSessionId === msg.session;\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.  Note that right\n      // now, this never happens: the server never connects us to a previous\n      // session, because DDP doesn't provide enough data for the server to know\n      // what messages the client has processed. We need to improve DDP to make\n      // this possible, at which point we'll probably need more code here.\n      return;\n    } // Server doesn't have our data any more. Re-sync a new session.\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n\n\n    self._updatesForUnknownStores = {};\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = {};\n      self._serverDocuments = {};\n    } // Clear _afterUpdateCallbacks.\n\n\n    self._afterUpdateCallbacks = []; // Mark all named subscriptions which are ready (ie, we already called the\n    // ready callback) as needing to be revived.\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\n\n    self._subsBeingRevived = {};\n\n    _.each(self._subscriptions, function (sub, id) {\n      if (sub.ready) self._subsBeingRevived[id] = true;\n    }); // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n\n\n    self._methodsBlockingQuiescence = {};\n\n    if (self._resetStores) {\n      _.each(self._methodInvokers, function (invoker) {\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = []; // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        _.each(self._stores, function (s) {\n          s.beginUpdate(0, true);\n          s.endUpdate();\n        });\n\n        self._resetStores = false;\n      }\n\n      self._runAfterUpdateCallbacks();\n    }\n  },\n  _processOneDataMessage: function (msg, updates) {\n    var self = this; // Using underscore here so as not to need to capitalize.\n\n    self['_process_' + msg.msg](msg, updates);\n  },\n  _livedata_data: function (msg) {\n    var self = this;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === \"nosub\") delete self._subsBeingRevived[msg.id];\n\n      _.each(msg.subs || [], function (subId) {\n        delete self._subsBeingRevived[subId];\n      });\n\n      _.each(msg.methods || [], function (methodId) {\n        delete self._methodsBlockingQuiescence[methodId];\n      });\n\n      if (self._waitingForQuiescence()) return; // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n        self._processOneDataMessage(bufferedMsg, self._bufferedWrites);\n      });\n\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      self._processOneDataMessage(msg, self._bufferedWrites);\n    } // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n\n\n    var standardWrite = _.include(['added', 'changed', 'removed'], msg.msg);\n\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      self._flushBufferedWrites();\n\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      self._flushBufferedWrites();\n\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n\n    self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites, self._bufferedWritesInterval);\n  },\n  _flushBufferedWrites: function () {\n    var self = this;\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n      self._bufferedWritesFlushHandle = null;\n    }\n\n    self._bufferedWritesFlushAt = null; // We need to clear the buffer before passing it to\n    //  performWrites. As there's no guarantee that it\n    //  will exit cleanly.\n\n    var writes = self._bufferedWrites;\n    self._bufferedWrites = {};\n\n    self._performWrites(writes);\n  },\n  _performWrites: function (updates) {\n    var self = this;\n\n    if (self._resetStores || !_.isEmpty(updates)) {\n      // Begin a transactional update of each store.\n      _.each(self._stores, function (s, storeName) {\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0, self._resetStores);\n      });\n\n      self._resetStores = false;\n\n      _.each(updates, function (updateMessages, storeName) {\n        var store = self._stores[storeName];\n\n        if (store) {\n          _.each(updateMessages, function (updateMessage) {\n            store.update(updateMessage);\n          });\n        } else {\n          // Nobody's listening for this data. Queue it up until\n          // someone wants it.\n          // XXX memory use will grow without bound if you forget to\n          // create a collection or just don't care about it... going\n          // to have to do something about that.\n          if (!_.has(self._updatesForUnknownStores, storeName)) self._updatesForUnknownStores[storeName] = [];\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName], updateMessages);\n        }\n      }); // End update transaction.\n\n\n      _.each(self._stores, function (s) {\n        s.endUpdate();\n      });\n    }\n\n    self._runAfterUpdateCallbacks();\n  },\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n  // relevant docs have been flushed, as well as dataVisible callbacks at\n  // reconnect-quiescence time.\n  _runAfterUpdateCallbacks: function () {\n    var self = this;\n    var callbacks = self._afterUpdateCallbacks;\n    self._afterUpdateCallbacks = [];\n\n    _.each(callbacks, function (c) {\n      c();\n    });\n  },\n  _pushUpdate: function (updates, collection, msg) {\n    var self = this;\n\n    if (!_.has(updates, collection)) {\n      updates[collection] = [];\n    }\n\n    updates[collection].push(msg);\n  },\n  _getServerDoc: function (collection, id) {\n    var self = this;\n    if (!_.has(self._serverDocuments, collection)) return null;\n    var serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  },\n  _process_added: function (msg, updates) {\n    var self = this;\n    var id = MongoID.idParse(msg.id);\n\n    var serverDoc = self._getServerDoc(msg.collection, id);\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      var isExisting = serverDoc.document !== undefined;\n      serverDoc.document = msg.fields || {};\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n\n        if (currentDoc !== undefined) msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n  _process_changed: function (msg, updates) {\n    var self = this;\n\n    var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      if (serverDoc.document === undefined) throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n  _process_removed: function (msg, updates) {\n    var self = this;\n\n    var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined) throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  },\n  _process_updated: function (msg, updates) {\n    var self = this; // Process \"method done\" messages.\n\n    _.each(msg.methods, function (methodId) {\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\n        var serverDoc = self._getServerDoc(written.collection, written.id);\n\n        if (!serverDoc) throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n        if (!serverDoc.writtenByStubs[methodId]) throw new Error(\"Doc \" + JSON.stringify(written) + \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];\n\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          }); // Call all flush callbacks.\n\n\n          _.each(serverDoc.flushCallbacks, function (c) {\n            c();\n          }); // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n\n\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n\n      delete self._documentsWrittenByStub[methodId]; // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n\n      var callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker) throw new Error(\"No callback invoker for method \" + methodId);\n\n      self._runWhenAllServerDocsAreFlushed(_.bind(callbackInvoker.dataVisible, callbackInvoker));\n    });\n  },\n  _process_ready: function (msg, updates) {\n    var self = this; // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n\n    _.each(msg.subs, function (subId) {\n      self._runWhenAllServerDocsAreFlushed(function () {\n        var subRecord = self._subscriptions[subId]; // Did we already unsubscribe?\n\n        if (!subRecord) return; // Did we already receive a ready message? (Oops!)\n\n        if (subRecord.ready) return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  },\n  // Ensures that \"f\" will be called after all documents currently in\n  // _serverDocuments have been written to the local cache. f will not be called\n  // if the connection is lost before then!\n  _runWhenAllServerDocsAreFlushed: function (f) {\n    var self = this;\n\n    var runFAfterUpdates = function () {\n      self._afterUpdateCallbacks.push(f);\n    };\n\n    var unflushedServerDocCount = 0;\n\n    var onServerDocFlush = function () {\n      --unflushedServerDocCount;\n\n      if (unflushedServerDocCount === 0) {\n        // This was the last doc to flush! Arrange to run f after the updates\n        // have been applied.\n        runFAfterUpdates();\n      }\n    };\n\n    _.each(self._serverDocuments, function (collectionDocs) {\n      collectionDocs.forEach(function (serverDoc) {\n        var writtenByStubForAMethodWithSentMessage = _.any(serverDoc.writtenByStubs, function (dummy, methodId) {\n          var invoker = self._methodInvokers[methodId];\n          return invoker && invoker.sentMessage;\n        });\n\n        if (writtenByStubForAMethodWithSentMessage) {\n          ++unflushedServerDocCount;\n          serverDoc.flushCallbacks.push(onServerDocFlush);\n        }\n      });\n    });\n\n    if (unflushedServerDocCount === 0) {\n      // There aren't any buffered docs --- we can call f as soon as the current\n      // round of updates is applied!\n      runFAfterUpdates();\n    }\n  },\n  _livedata_nosub: function (msg) {\n    var self = this; // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n\n    self._livedata_data(msg); // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n    // we weren't subbed anyway, or we initiated the unsub.\n\n\n    if (!_.has(self._subscriptions, msg.id)) return; // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    var meteorErrorFromMsg = function (msgArg) {\n      return msgArg && msgArg.error && new Meteor.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }; // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  },\n  _process_nosub: function () {// This is called as part of the \"buffer until quiescence\" process, but\n    // nosub's effect is always immediate. It only goes in the buffer at all\n    // because it's possible for a nosub to be the thing that triggers\n    // quiescence, if we were waiting for a sub to be revived and it dies\n    // instead.\n  },\n  _livedata_result: function (msg) {\n    // id, result or error. error has error (code), reason, details\n    var self = this; // Lets make sure there are no buffered writes before returning result.\n\n    if (!_.isEmpty(self._bufferedWrites)) {\n      self._flushBufferedWrites();\n    } // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n\n\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug(\"Received method result but no methods outstanding\");\n\n      return;\n    }\n\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    var m;\n\n    for (var i = 0; i < currentMethodBlock.length; i++) {\n      m = currentMethodBlock[i];\n      if (m.methodId === msg.id) break;\n    }\n\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n\n      return;\n    } // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n\n\n    currentMethodBlock.splice(i, 1);\n\n    if (_.has(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a\n      // value\n      m.receiveResult(undefined, msg.result);\n    }\n  },\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\n  // the last outstanding method in the current block, runs the next block. If\n  // there are no more methods, consider accepting a hot code push.\n  _outstandingMethodFinished: function () {\n    var self = this;\n    if (self._anyMethodsAreOutstanding()) return; // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that\n    // half-finished before disconnect/reconnect.)\n\n    if (!_.isEmpty(self._outstandingMethodBlocks)) {\n      var firstBlock = self._outstandingMethodBlocks.shift();\n\n      if (!_.isEmpty(firstBlock.methods)) throw new Error(\"No methods outstanding but nonempty block: \" + JSON.stringify(firstBlock)); // Send the outstanding methods now in the first block.\n\n      if (!_.isEmpty(self._outstandingMethodBlocks)) self._sendOutstandingMethods();\n    } // Maybe accept a hot code push.\n\n\n    self._maybeMigrate();\n  },\n  // Sends messages for all the methods in the first block in\n  // _outstandingMethodBlocks.\n  _sendOutstandingMethods: function () {\n    var self = this;\n    if (_.isEmpty(self._outstandingMethodBlocks)) return;\n\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n      m.sendMessage();\n    });\n  },\n  _livedata_error: function (msg) {\n    Meteor._debug(\"Received error from server: \", msg.reason);\n\n    if (msg.offendingMessage) Meteor._debug(\"For: \", msg.offendingMessage);\n  },\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function () {\n    var self = this;\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n    self._outstandingMethodBlocks = [];\n    self.onReconnect && self.onReconnect();\n\n    DDP._reconnectHook.each(function (callback) {\n      callback(self);\n      return true;\n    });\n\n    if (_.isEmpty(oldOutstandingMethodBlocks)) return; // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just\n    // restore all outstanding methods and run the first block.\n\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n\n      self._sendOutstandingMethods();\n\n      return;\n    } // OK, there are blocks on both sides. Special case: merge the last block of\n    // the reconnect methods with the first block of the original methods, if\n    // neither of them are \"wait\" blocks.\n\n\n    if (!_.last(self._outstandingMethodBlocks).wait && !oldOutstandingMethodBlocks[0].wait) {\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n        _.last(self._outstandingMethodBlocks).methods.push(m); // If this \"last block\" is also the first block, send the message.\n\n\n        if (self._outstandingMethodBlocks.length === 1) m.sendMessage();\n      });\n\n      oldOutstandingMethodBlocks.shift();\n    } // Now add the rest of the original blocks on.\n\n\n    _.each(oldOutstandingMethodBlocks, function (block) {\n      self._outstandingMethodBlocks.push(block);\n    });\n  },\n  // We can accept a hot code push if there are no methods in flight.\n  _readyToMigrate: function () {\n    var self = this;\n    return _.isEmpty(self._methodInvokers);\n  },\n  // If we were blocking a migration, see if it's now possible to continue.\n  // Call whenever the set of outstanding/blocked methods shrinks.\n  _maybeMigrate: function () {\n    var self = this;\n\n    if (self._retryMigrate && self._readyToMigrate()) {\n      self._retryMigrate();\n\n      self._retryMigrate = null;\n    }\n  }\n});\n\nLivedataTest.Connection = Connection; // @param url {String} URL to Meteor app,\n//     e.g.:\n//     \"subdomain.meteor.com\",\n//     \"http://subdomain.meteor.com\",\n//     \"/\",\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n/**\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere\n * @param {String} url The URL of another Meteor application.\n */\n\nDDP.connect = function (url, options) {\n  var ret = new Connection(url, options);\n  allConnections.push(ret); // hack. see below.\n\n  return ret;\n};\n\nDDP._reconnectHook = new Hook({\n  bindEnvironment: false\n}); /**\n     * @summary Register a function to call as the first step of\n     * reconnecting. This function can call methods which will be executed before\n     * any other outstanding methods. For example, this can be used to re-establish\n     * the appropriate authentication context on the connection.\n     * @locus Anywhere\n     * @param {Function} callback The function to call. It will be called with a\n     * single argument, the [connection object](#ddp_connect) that is reconnecting.\n     */\n\nDDP.onReconnect = function (callback) {\n  return DDP._reconnectHook.register(callback);\n}; // Hack for `spiderable` package: a way to see if the page is done\n// loading all the data it needs.\n//\n\n\nallConnections = [];\n\nDDP._allSubscriptionsReady = function () {\n  return _.all(allConnections, function (conn) {\n    return _.all(conn._subscriptions, function (sub) {\n      return sub.ready;\n    });\n  });\n};","map":{"version":3,"sources":["packages/ddp-client/livedata_connection.js"],"names":["DDP","LivedataTest","module","watch","require","v","MongoIDMap","Meteor","isServer","Fiber","Npm","Future","Connection","url","options","self","_","extend","onConnected","onDDPVersionNegotiationFailure","description","_debug","heartbeatInterval","heartbeatTimeout","npmFayeOptions","reloadWithOutstanding","supportedDDPVersions","DDPCommon","SUPPORTED_DDP_VERSIONS","retry","respondToPings","bufferedWritesInterval","bufferedWritesMaxAge","onReconnect","_stream","ClientStream","headers","_sockjsOptions","_dontPrintErrors","connectTimeoutMs","_lastSessionId","_versionSuggestion","_version","_stores","_methodHandlers","_nextMethodId","_supportedDDPVersions","_heartbeatInterval","_heartbeatTimeout","_methodInvokers","_outstandingMethodBlocks","_documentsWrittenByStub","_serverDocuments","_afterUpdateCallbacks","_messagesBufferedUntilQuiescence","_methodsBlockingQuiescence","_subsBeingRevived","_resetStores","_updatesForUnknownStores","_retryMigrate","__flushBufferedWrites","bindEnvironment","_flushBufferedWrites","_bufferedWrites","_bufferedWritesFlushAt","_bufferedWritesFlushHandle","_bufferedWritesInterval","_bufferedWritesMaxAge","_subscriptions","_userId","_userIdDeps","Tracker","Dependency","isClient","Package","reload","Reload","_onMigrate","_readyToMigrate","Error","onMessage","raw_msg","msg","parseDDP","e","_heartbeat","messageReceived","server_id","_livedata_connected","contains","version","reconnect","_force","disconnect","_permanent","_error","_send","id","include","_livedata_data","_livedata_nosub","_livedata_result","_livedata_error","onReset","session","support","length","currentMethodBlock","methods","filter","methodInvoker","sentMessage","noRetry","receiveResult","isEmpty","shift","each","m","_callOnReconnectAndSendAppropriateOutstandingMethods","sub","name","params","onDisconnect","stop","on","MethodInvoker","methodId","_callback","callback","_connection","connection","_message","message","_onResultReceived","onResultReceived","_wait","wait","_methodResult","_dataVisible","prototype","sendMessage","gotResult","_maybeInvokeCallback","_outstandingMethodFinished","err","result","dataVisible","registerStore","wrappedStore","store","method","apply","arguments","undefined","queued","beginUpdate","update","endUpdate","subscribe","Array","slice","call","callbacks","lastParam","isFunction","onReady","pop","any","onError","onStop","existing","find","inactive","EJSON","equals","ready","readyCallback","errorCallback","stopCallback","Random","clone","readyDeps","remove","changed","handle","has","record","depend","subscriptionId","active","onInvalidate","c","afterFlush","_subscribeAndWait","args","f","push","onLateError","concat","func","enclosing","_CurrentMethodInvocation","get","alreadyInSimulation","isSimulation","randomSeed","randomSeedGenerator","makeRpcSeed","stub","setUserId","userId","invocation","MethodInvocation","_saveOriginals","stubReturnValue","withValue","_noYieldsAllowed","exception","_retrieveAndStoreOriginals","throwStubExceptions","expected","stack","future","resolver","last","returnStubValue","_waitingForQuiescence","s","saveOriginals","docsWritten","collection","originals","retrieveOriginals","forEach","doc","serverDoc","setDefault","writtenByStubs","document","flushCallbacks","_unsubscribeAll","obj","send","stringifyDDP","_lostConnection","error","status","close","_anyMethodsAreOutstanding","pluck","Heartbeat","onTimeout","ConnectionError","sendPing","start","reconnectedToPreviousSession","invoker","bind","_runAfterUpdateCallbacks","_processOneDataMessage","updates","subs","subId","bufferedMsg","standardWrite","Date","valueOf","clearTimeout","setTimeout","writes","_performWrites","storeName","updateMessages","updateMessage","_pushUpdate","_getServerDoc","serverDocsForCollection","_process_added","MongoID","idParse","isExisting","fields","_id","currentDoc","getDoc","_process_changed","DiffSequence","applyChanges","_process_removed","_process_updated","written","JSON","stringify","idStringify","replace","callbackInvoker","_runWhenAllServerDocsAreFlushed","_process_ready","subRecord","runFAfterUpdates","unflushedServerDocCount","onServerDocFlush","collectionDocs","writtenByStubForAMethodWithSentMessage","dummy","meteorErrorFromMsg","msgArg","reason","details","_process_nosub","i","splice","firstBlock","_sendOutstandingMethods","_maybeMigrate","offendingMessage","oldOutstandingMethodBlocks","_reconnectHook","block","connect","ret","allConnections","Hook","register","_allSubscriptionsReady","all","conn"],"mappings":"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","file":"packages/ddp-client/livedata_connection.js.map","sourcesContent":["import { DDP, LivedataTest } from \"./namespace.js\";\nimport { MongoIDMap } from \"./id_map.js\";\n\nif (Meteor.isServer) {\n  var Fiber = Npm.require('fibers');\n  var Future = Npm.require('fibers/future');\n}\n\n// @param url {String|Object} URL to Meteor app,\n//   or an object as a test hook (see code)\n// Options:\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n//   headers: extra headers to send on the websockets connection, for\n//     server-to-server DDP only\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n//\n// XXX There should be a way to destroy a DDP connection, causing all\n// outstanding method calls to fail.\n//\n// XXX Our current way of handling failure and reconnection is great\n// for an app (where we want to tolerate being disconnected as an\n// expect state, and keep trying forever to reconnect) but cumbersome\n// for something like a command line tool that wants to make a\n// connection, call a method, and print an error if connection\n// fails. We should have better usability in the latter case (while\n// still transparently reconnecting if it's just a transient failure\n// or the server migrating us).\nvar Connection = function (url, options) {\n  var self = this;\n  options = _.extend({\n    onConnected: function () {},\n    onDDPVersionNegotiationFailure: function (description) {\n      Meteor._debug(description);\n    },\n    heartbeatInterval: 17500,\n    heartbeatTimeout: 15000,\n    npmFayeOptions: {},\n    // These options are only for testing.\n    reloadWithOutstanding: false,\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n    retry: true,\n    respondToPings: true,\n    // When updates are coming within this ms interval, batch them together.\n    bufferedWritesInterval: 5,\n    // Flush buffers immediately if writes are happening continuously for more than this many ms.\n    bufferedWritesMaxAge: 500\n  }, options);\n\n  // If set, called when we reconnect, queuing method calls _before_ the\n  // existing outstanding ones.\n  // NOTE: This feature has been preserved for backwards compatibility. The\n  // preferred method of setting a callback on reconnect is to use\n  // DDP.onReconnect.\n  self.onReconnect = null;\n\n  // as a test hook, allow passing a stream instead of a url.\n  if (typeof url === \"object\") {\n    self._stream = url;\n  } else {\n    self._stream = new LivedataTest.ClientStream(url, {\n      retry: options.retry,\n      headers: options.headers,\n      _sockjsOptions: options._sockjsOptions,\n      // Used to keep some tests quiet, or for other cases in which\n      // the right thing to do with connection errors is to silently\n      // fail (e.g. sending package usage stats). At some point we\n      // should have a real API for handling client-stream-level\n      // errors.\n      _dontPrintErrors: options._dontPrintErrors,\n      connectTimeoutMs: options.connectTimeoutMs,\n      npmFayeOptions: options.npmFayeOptions\n    });\n  }\n\n  self._lastSessionId = null;\n  self._versionSuggestion = null;  // The last proposed DDP version.\n  self._version = null;   // The DDP version agreed on by client and server.\n  self._stores = {}; // name -> object with methods\n  self._methodHandlers = {}; // name -> func\n  self._nextMethodId = 1;\n  self._supportedDDPVersions = options.supportedDDPVersions;\n\n  self._heartbeatInterval = options.heartbeatInterval;\n  self._heartbeatTimeout = options.heartbeatTimeout;\n\n  // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all\n  // of their writes to be written to the local cache). Map from method ID to\n  // MethodInvoker object.\n  self._methodInvokers = {};\n\n  // Tracks methods which the user has called but whose result messages have not\n  // arrived yet.\n  //\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n  // represents a set of methods that can run at the same time. The first block\n  // represents the methods which are currently in flight; subsequent blocks\n  // must wait for previous blocks to be fully finished before they can be sent\n  // to the server.\n  //\n  // Each block is an object with the following fields:\n  // - methods: a list of MethodInvoker objects\n  // - wait: a boolean; if true, this block had a single method invoked with\n  //         the \"wait\" option\n  //\n  // There will never be adjacent blocks with wait=false, because the only thing\n  // that makes methods need to be serialized is a wait method.\n  //\n  // Methods are removed from the first block when their \"result\" is\n  // received. The entire first block is only removed when all of the in-flight\n  // methods have received their results (so the \"methods\" list is empty) *AND*\n  // all of the data written by those methods are visible in the local cache. So\n  // it is possible for the first block's methods list to be empty, if we are\n  // still waiting for some objects to quiesce.\n  //\n  // Example:\n  //  _outstandingMethodBlocks = [\n  //    {wait: false, methods: []},\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n  //                            <MethodInvoker for 'bar'>]}]\n  // This means that there were some methods which were sent to the server and\n  // which have returned their results, but some of the data written by\n  // the methods may not be visible in the local cache. Once all that data is\n  // visible, we will send a 'login' method. Once the login method has returned\n  // and all the data is visible (including re-running subs if userId changes),\n  // we will send the 'foo' and 'bar' methods in parallel.\n  self._outstandingMethodBlocks = [];\n\n  // method ID -> array of objects with keys 'collection' and 'id', listing\n  // documents written by a given method's stub. keys are associated with\n  // methods whose stub wrote at least one document, and whose data-done message\n  // has not yet been received.\n  self._documentsWrittenByStub = {};\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:\n  // - \"document\": the version of the document according the\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n  //   received from the server)\n  //   It is undefined if we think the document does not exist\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n  //   whose \"data done\" messages have not yet been processed\n  self._serverDocuments = {};\n\n  // Array of callbacks to be called after the next update of the local\n  // cache. Used for:\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n  //    the relevant data is flushed.\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n  //    quiescence. Specifically, methods whose result was received over the old\n  //    connection (so we don't re-send it) but whose data had not been made\n  //    visible.\n  self._afterUpdateCallbacks = [];\n\n  // In two contexts, we buffer all incoming data messages and then process them\n  // all at once in a single update:\n  //   - During reconnect, we buffer all data messages until all subs that had\n  //     been ready before reconnect are ready again, and all methods that are\n  //     active have returned their \"data done message\"; then\n  //   - During the execution of a \"wait\" method, we buffer all data messages\n  //     until the wait method gets its \"data done\" message. (If the wait method\n  //     occurs during reconnect, it doesn't get any special handling.)\n  // all data messages are processed in one update.\n  //\n  // The following fields are used for this \"quiescence\" process.\n\n  // This buffers the messages that aren't being processed yet.\n  self._messagesBufferedUntilQuiescence = [];\n  // Map from method ID -> true. Methods are removed from this when their\n  // \"data done\" message is received, and we will not quiesce until it is\n  // empty.\n  self._methodsBlockingQuiescence = {};\n  // map from sub ID -> true for subs that were ready (ie, called the sub\n  // ready callback) before reconnect but haven't become ready again yet\n  self._subsBeingRevived = {}; // map from sub._id -> true\n  // if true, the next data update should reset all stores. (set during\n  // reconnect.)\n  self._resetStores = false;\n\n  // name -> array of updates for (yet to be created) collections\n  self._updatesForUnknownStores = {};\n  // if we're blocking a migration, the retry func\n  self._retryMigrate = null;\n\n  self.__flushBufferedWrites = Meteor.bindEnvironment(\n    self._flushBufferedWrites, \"flushing DDP buffered writes\", self);\n  // Collection name -> array of messages.\n  self._bufferedWrites = {};\n  // When current buffer of updates must be flushed at, in ms timestamp.\n  self._bufferedWritesFlushAt = null;\n  // Timeout handle for the next processing of all pending writes\n  self._bufferedWritesFlushHandle = null;\n\n  self._bufferedWritesInterval = options.bufferedWritesInterval;\n  self._bufferedWritesMaxAge = options.bufferedWritesMaxAge;\n\n  // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id\n  //   - name\n  //   - params\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\n  //   - ready (has the 'ready' message been received?)\n  //   - readyCallback (an optional callback to call when ready)\n  //   - errorCallback (an optional callback to call if the sub terminates with\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\n  //   - stopCallback (an optional callback to call when the sub terminates\n  //     for any reason, with an error argument if an error triggered the stop)\n  self._subscriptions = {};\n\n  // Reactive userId.\n  self._userId = null;\n  self._userIdDeps = new Tracker.Dependency;\n\n  // Block auto-reload while we're waiting for method responses.\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n    Package.reload.Reload._onMigrate(function (retry) {\n      if (!self._readyToMigrate()) {\n        if (self._retryMigrate)\n          throw new Error(\"Two migrations in progress?\");\n        self._retryMigrate = retry;\n        return false;\n      } else {\n        return [true];\n      }\n    });\n  }\n\n  var onMessage = function (raw_msg) {\n    try {\n      var msg = DDPCommon.parseDDP(raw_msg);\n    } catch (e) {\n      Meteor._debug(\"Exception while parsing DDP\", e);\n      return;\n    }\n\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the server is still alive.\n    if (self._heartbeat) {\n      self._heartbeat.messageReceived();\n    }\n\n    if (msg === null || !msg.msg) {\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n      // compat.  Remove this 'if' once the server stops sending welcome\n      // messages (stream_server.js).\n      if (! (msg && msg.server_id))\n        Meteor._debug(\"discarding invalid livedata message\", msg);\n      return;\n    }\n\n    if (msg.msg === 'connected') {\n      self._version = self._versionSuggestion;\n      self._livedata_connected(msg);\n      options.onConnected();\n    }\n    else if (msg.msg === 'failed') {\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\n        self._versionSuggestion = msg.version;\n        self._stream.reconnect({_force: true});\n      } else {\n        var description =\n              \"DDP version negotiation failed; server requested version \" + msg.version;\n        self._stream.disconnect({_permanent: true, _error: description});\n        options.onDDPVersionNegotiationFailure(description);\n      }\n    }\n    else if (msg.msg === 'ping' && options.respondToPings) {\n      self._send({msg: \"pong\", id: msg.id});\n    }\n    else if (msg.msg === 'pong') {\n      // noop, as we assume everything's a pong\n    }\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\n      self._livedata_data(msg);\n    else if (msg.msg === 'nosub')\n      self._livedata_nosub(msg);\n    else if (msg.msg === 'result')\n      self._livedata_result(msg);\n    else if (msg.msg === 'error')\n      self._livedata_error(msg);\n    else\n      Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };\n\n  var onReset = function () {\n    // Send a connect message at the beginning of the stream.\n    // NOTE: reset is called even on the first connection, so this is\n    // the only place we send this message.\n    var msg = {msg: 'connect'};\n    if (self._lastSessionId)\n      msg.session = self._lastSessionId;\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n    self._versionSuggestion = msg.version;\n    msg.support = self._supportedDDPVersions;\n    self._send(msg);\n\n    // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n    // current block is pretty important to making sure that quiescence is properly calculated, as\n    // well as possibly moving on to another useful block.\n\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n    // we are connecting for the first time.\n    if (self._outstandingMethodBlocks.length > 0) {\n      // If there is an outstanding method block, we only care about the first one as that is the\n      // one that could have already sent messages with no response, that are not allowed to retry.\n      const currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n      self._outstandingMethodBlocks[0].methods = currentMethodBlock.filter((methodInvoker) => {\n\n        // Methods with 'noRetry' option set are not allowed to re-send after\n        // recovering dropped connection.\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n          // Make sure that the method is told that it failed.\n          methodInvoker.receiveResult(new Meteor.Error('invocation-failed',\n            'Method invocation might have failed due to dropped connection. ' +\n            'Failing because `noRetry` option was passed to Meteor.apply.'));\n        }\n\n        // Only keep a method if it wasn't sent or it's allowed to retry.\n        // This may leave the block empty, but we don't move on to the next\n        // block until the callback has been delivered, in _outstandingMethodFinished.\n        return !(methodInvoker.sentMessage && methodInvoker.noRetry);\n      });\n    }\n\n    // Now, to minimize setup latency, go ahead and blast out all of\n    // our pending methods ands subscriptions before we've even taken\n    // the necessary RTT to know if we successfully reconnected. (1)\n    // They're supposed to be idempotent, and where they are not,\n    // they can block retry in apply; (2) even if we did reconnect,\n    // we're not sure what messages might have gotten lost\n    // (in either direction) since we were disconnected (TCP being\n    // sloppy about that.)\n\n    // If the current block of methods all got their results (but didn't all get\n    // their data visible), discard the empty block now.\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n      self._outstandingMethodBlocks.shift();\n    }\n\n    // Mark all messages as unsent, they have not yet been sent on this\n    // connection.\n    _.each(self._methodInvokers, function (m) {\n      m.sentMessage = false;\n    });\n\n    // If an `onReconnect` handler is set, call it first. Go through\n    // some hoops to ensure that methods that are called from within\n    // `onReconnect` get executed _before_ ones that were originally\n    // outstanding (since `onReconnect` is used to re-establish auth\n    // certificates)\n    self._callOnReconnectAndSendAppropriateOutstandingMethods();\n\n    // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.\n    _.each(self._subscriptions, function (sub, id) {\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: sub.name,\n        params: sub.params\n      });\n    });\n  };\n\n  var onDisconnect = function () {\n    if (self._heartbeat) {\n      self._heartbeat.stop();\n      self._heartbeat = null;\n    }\n  };\n\n  if (Meteor.isServer) {\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n  } else {\n    self._stream.on('message', onMessage);\n    self._stream.on('reset', onReset);\n    self._stream.on('disconnect', onDisconnect);\n  }\n};\n\n// A MethodInvoker manages sending a method to the server and calling the user's\n// callbacks. On construction, it registers itself in the connection's\n// _methodInvokers map; it removes itself once the method is fully finished and\n// the callback is invoked. This occurs when it has both received a result,\n// and the data written by it is fully visible.\nvar MethodInvoker = function (options) {\n  var self = this;\n\n  // Public (within this file) fields.\n  self.methodId = options.methodId;\n  self.sentMessage = false;\n\n  self._callback = options.callback;\n  self._connection = options.connection;\n  self._message = options.message;\n  self._onResultReceived = options.onResultReceived || function () {};\n  self._wait = options.wait;\n  self.noRetry = options.noRetry;\n  self._methodResult = null;\n  self._dataVisible = false;\n\n  // Register with the connection.\n  self._connection._methodInvokers[self.methodId] = self;\n};\n_.extend(MethodInvoker.prototype, {\n  // Sends the method message to the server. May be called additional times if\n  // we lose the connection and reconnect before receiving a result.\n  sendMessage: function () {\n    var self = this;\n    // This function is called before sending a method (including resending on\n    // reconnect). We should only (re)send methods where we don't already have a\n    // result!\n    if (self.gotResult())\n      throw new Error(\"sendingMethod is called on method with result\");\n\n\n    // If we're re-sending it, it doesn't matter if data was written the first\n    // time.\n    self._dataVisible = false;\n    self.sentMessage = true;\n\n    // If this is a wait method, make all data messages be buffered until it is\n    // done.\n    if (self._wait)\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\n\n    // Actually send the message.\n    self._connection._send(self._message);\n  },\n  // Invoke the callback, if we have both a result and know that all data has\n  // been written to the local cache.\n  _maybeInvokeCallback: function () {\n    var self = this;\n    if (self._methodResult && self._dataVisible) {\n      // Call the callback. (This won't throw: the callback was wrapped with\n      // bindEnvironment.)\n      self._callback(self._methodResult[0], self._methodResult[1]);\n\n      // Forget about this method.\n      delete self._connection._methodInvokers[self.methodId];\n\n      // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.\n      self._connection._outstandingMethodFinished();\n    }\n  },\n  // Call with the result of the method from the server. Only may be called\n  // once; once it is called, you should not call sendMessage again.\n  // If the user provided an onResultReceived callback, call it immediately.\n  // Then invoke the main callback if data is also visible.\n  receiveResult: function (err, result) {\n    var self = this;\n    if (self.gotResult())\n      throw new Error(\"Methods should only receive results once\");\n    self._methodResult = [err, result];\n    self._onResultReceived(err, result);\n    self._maybeInvokeCallback();\n  },\n  // Call this when all data written by the method is visible. This means that\n  // the method has returns its \"data is done\" message *AND* all server\n  // documents that are buffered at that time have been written to the local\n  // cache. Invokes the main callback if the result has been received.\n  dataVisible: function () {\n    var self = this;\n    self._dataVisible = true;\n    self._maybeInvokeCallback();\n  },\n  // True if receiveResult has been called.\n  gotResult: function () {\n    var self = this;\n    return !!self._methodResult;\n  }\n});\n\n_.extend(Connection.prototype, {\n  // 'name' is the name of the data on the wire that should go in the\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n  registerStore: function (name, wrappedStore) {\n    var self = this;\n\n    if (name in self._stores)\n      return false;\n\n    // Wrap the input object in an object which makes any store method not\n    // implemented by 'store' into a no-op.\n    var store = {};\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\n            'retrieveOriginals', 'getDoc',\n\t\t\t'_getCollection'], function (method) {\n              store[method] = function () {\n                return (wrappedStore[method]\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\n                        : undefined);\n              };\n            });\n\n    self._stores[name] = store;\n\n    var queued = self._updatesForUnknownStores[name];\n    if (queued) {\n      store.beginUpdate(queued.length, false);\n      _.each(queued, function (msg) {\n        store.update(msg);\n      });\n      store.endUpdate();\n      delete self._updatesForUnknownStores[name];\n    }\n\n    return true;\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Subscribe to a record set.  Returns a handle that provides\n   * `stop()` and `ready()` methods.\n   * @locus Client\n   * @param {String} name Name of the subscription.  Matches the name of the\n   * server's `publish()` call.\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n   * function on server.\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n   * and `onReady` callbacks. If there is an error, it is passed as an\n   * argument to `onStop`. If a function is passed instead of an object, it\n   * is interpreted as an `onReady` callback.\n   */\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\n    var self = this;\n\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n      if (_.isFunction(lastParam)) {\n        callbacks.onReady = params.pop();\n      } else if (lastParam &&\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n        // onStop with an error callback instead.\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\n          _.isFunction)) {\n        callbacks = params.pop();\n      }\n    }\n\n    // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n    var existing = _.find(self._subscriptions, function (sub) {\n      return sub.inactive && sub.name === name &&\n        EJSON.equals(sub.params, params);\n    });\n\n    var id;\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false; // reactivate\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        // If the sub is already ready, run the ready callback right away.\n        // It seems that users would expect an onReady callback inside an\n        // autorun to trigger once the the sub first becomes ready and also\n        // when re-subs happens.\n        if (existing.ready) {\n          callbacks.onReady();\n        } else {\n          existing.readyCallback = callbacks.onReady;\n        }\n      }\n\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n      // onStop with an optional error argument\n      if (callbacks.onError) {\n        // Replace existing callback if any, so that errors aren't\n        // double-reported.\n        existing.errorCallback = callbacks.onError;\n      }\n\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n    } else {\n      // New sub! Generate an id, save it locally, and send message.\n      id = Random.id();\n      self._subscriptions[id] = {\n        id: id,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Tracker.Dependency,\n        readyCallback: callbacks.onReady,\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        errorCallback: callbacks.onError,\n        stopCallback: callbacks.onStop,\n        connection: self,\n        remove: function() {\n          delete this.connection._subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n        },\n        stop: function() {\n          this.connection._send({msg: 'unsub', id: id});\n          this.remove();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n      self._send({msg: 'sub', id: id, name: name, params: params});\n    }\n\n    // return a handle to the application.\n    var handle = {\n      stop: function () {\n        if (!_.has(self._subscriptions, id))\n          return;\n\n        self._subscriptions[id].stop();\n      },\n      ready: function () {\n        // return false if we've unsubscribed.\n        if (!_.has(self._subscriptions, id))\n          return false;\n        var record = self._subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Tracker.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Tracker.onInvalidate(function (c) {\n        if (_.has(self._subscriptions, id))\n          self._subscriptions[id].inactive = true;\n\n        Tracker.afterFlush(function () {\n          if (_.has(self._subscriptions, id) &&\n              self._subscriptions[id].inactive)\n            handle.stop();\n        });\n      });\n    }\n\n    return handle;\n  },\n\n  // options:\n  // - onLateError {Function(error)} called if an error was received after the ready event.\n  //     (errors received before ready cause an error to be thrown)\n  _subscribeAndWait: function (name, args, options) {\n    var self = this;\n    var f = new Future();\n    var ready = false;\n    var handle;\n    args = args || [];\n    args.push({\n      onReady: function () {\n        ready = true;\n        f['return']();\n      },\n      onError: function (e) {\n        if (!ready)\n          f['throw'](e);\n        else\n          options && options.onLateError && options.onLateError(e);\n      }\n    });\n\n    handle = self.subscribe.apply(self, [name].concat(args));\n    f.wait();\n    return handle;\n  },\n\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self._methodHandlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self._methodHandlers[name] = func;\n    });\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invokes a method passing any number of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */\n  call: function (name /* .. [arguments] .. callback */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  //   wait: Boolean - Should we wait to call this until all current methods\n  //                   are fully finished, and block subsequent method calls\n  //                   until this method is fully finished?\n  //                   (does not affect methods called from within this method)\n  //   onResultReceived: Function - a callback to call as soon as the method\n  //                                result is received. the data written by\n  //                                the method may not yet be in the cache!\n  //   returnStubValue: Boolean - If true then in cases where we would have\n  //                              otherwise discarded the stub's return value\n  //                              and returned undefined, instead we go ahead\n  //                              and return it.  Specifically, this is any\n  //                              time other than when (a) we are already\n  //                              inside a stub or (b) we are in Node and no\n  //                              callback was provided.  Currently we require\n  //                              this flag to be explicitly passed to reduce\n  //                              the likelihood that stub return values will\n  //                              be confused with server return values; we\n  //                              may improve this in future.\n  // @param callback {Optional Function}\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invoke a method passing an array of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable[]} args Method arguments\n   * @param {Object} [options]\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Boolean} options.throwStubExceptions (Client only) If true, exceptions thrown by method stubs will be thrown instead of logged, and the method will not be invoked on the server.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n   */\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback) {\n      // XXX would it be better form to do the binding in stream.on,\n      // or caller, instead of here?\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n    }\n\n    // Keep our args safe from mutation (eg if we don't send the message for a\n    // while because of a wait method).\n    args = EJSON.clone(args);\n\n    // Lazily allocate method ID once we know that it'll be needed.\n    var methodId = (function () {\n      var id;\n      return function () {\n        if (id === undefined)\n          id = '' + (self._nextMethodId++);\n        return id;\n      };\n    })();\n\n    var enclosing = DDP._CurrentMethodInvocation.get();\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\n\n    // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client\n    // and the server; if the client doesn't generate any 'random' values\n    // then we don't expect the server to generate any either.\n    // Less commonly, the server may perform different actions from the client,\n    // and may in fact generate values where the client did not, but we don't\n    // have any client-side values to match, so even here we may as well just\n    // use a random seed on the server.  In that case, we don't pass the\n    // randomSeed to save bandwidth, and we don't even generate it to save a\n    // bit of CPU and to avoid consuming entropy.\n    var randomSeed = null;\n    var randomSeedGenerator = function () {\n      if (randomSeed === null) {\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n      }\n      return randomSeed;\n    };\n\n    // Run the stub, if we have one. The stub is supposed to make some\n    // temporary writes to the database to give the user a smooth experience\n    // until the actual result of executing the method comes back from the\n    // server (whereupon the temporary writes to the database will be reversed\n    // during the beginUpdate/endUpdate process.)\n    //\n    // Normally, we ignore the return value of the stub (even if it is an\n    // exception), in favor of the real return value from the server. The\n    // exception is if the *caller* is a stub. In that case, we're not going\n    // to do a RPC, so we use the return value of the stub as our return\n    // value.\n\n    var stub = self._methodHandlers[name];\n    if (stub) {\n      var setUserId = function(userId) {\n        self.setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: true,\n        userId: self.userId(),\n        setUserId: setUserId,\n        randomSeed: function () { return randomSeedGenerator(); }\n      });\n\n      if (!alreadyInSimulation)\n        self._saveOriginals();\n\n      try {\n        // Note that unlike in the corresponding server code, we never audit\n        // that stubs check() their arguments.\n        var stubReturnValue = DDP._CurrentMethodInvocation.withValue(invocation, function () {\n          if (Meteor.isServer) {\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\n            // don't allow stubs to yield.\n            return Meteor._noYieldsAllowed(function () {\n              // re-clone, so that the stub can't affect our caller's values\n              return stub.apply(invocation, EJSON.clone(args));\n            });\n          } else {\n            return stub.apply(invocation, EJSON.clone(args));\n          }\n        });\n      }\n      catch (e) {\n        var exception = e;\n      }\n\n      if (!alreadyInSimulation)\n        self._retrieveAndStoreOriginals(methodId());\n    }\n\n    // If we're in a simulation, stop and return the result we have,\n    // rather than going on to do an RPC. If there was no stub,\n    // we'll end up returning undefined.\n    if (alreadyInSimulation) {\n      if (callback) {\n        callback(exception, stubReturnValue);\n        return undefined;\n      }\n      if (exception)\n        throw exception;\n      return stubReturnValue;\n    }\n\n    // If an exception occurred in a stub, and we're ignoring it\n    // because we're doing an RPC and want to use what the server\n    // returns instead, log it so the developer knows\n    // (unless they explicitly ask to see the error).\n    //\n    // Tests can set the 'expected' flag on an exception so it won't\n    // go to log.\n    if (exception) {\n      if (options.throwStubExceptions) {\n        throw exception;\n      } else if (!exception.expected) {\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +\n          name + \"'\", exception, exception.stack);\n      }\n    }\n\n\n    // At this point we're definitely doing an RPC, and we're going to\n    // return the value of the RPC to the caller.\n\n    // If the caller didn't give a callback, decide what to do.\n    if (!callback) {\n      if (Meteor.isClient) {\n        // On the client, we don't have fibers, so we can't block. The\n        // only thing we can do is to return undefined and discard the\n        // result of the RPC. If an error occurred then print the error\n        // to the console.\n        callback = function (err) {\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",\n                               err.message);\n        };\n      } else {\n        // On the server, make the function synchronous. Throw on\n        // errors, return on success.\n        var future = new Future;\n        callback = future.resolver();\n      }\n    }\n    // Send the RPC. Note that on the client, it is important that the\n    // stub have finished before we send the RPC, so that we know we have\n    // a complete list of which local documents the stub wrote.\n    var message = {\n      msg: 'method',\n      method: name,\n      params: args,\n      id: methodId()\n    };\n\n    // Send the randomSeed only if we used it\n    if (randomSeed !== null) {\n      message.randomSeed = randomSeed;\n    }\n\n    var methodInvoker = new MethodInvoker({\n      methodId: methodId(),\n      callback: callback,\n      connection: self,\n      onResultReceived: options.onResultReceived,\n      wait: !!options.wait,\n      message: message,\n      noRetry: !!options.noRetry\n    });\n\n    if (options.wait) {\n      // It's a wait method! Wait methods go in their own block.\n      self._outstandingMethodBlocks.push(\n        {wait: true, methods: [methodInvoker]});\n    } else {\n      // Not a wait method. Start a new block if the previous block was a wait\n      // block, and add it to the last block of methods.\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\n          _.last(self._outstandingMethodBlocks).wait)\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n    }\n\n    // If we added it to the first block, send it out now.\n    if (self._outstandingMethodBlocks.length === 1)\n      methodInvoker.sendMessage();\n\n    // If we're using the default callback on the server,\n    // block waiting for the result.\n    if (future) {\n      return future.wait();\n    }\n    return options.returnStubValue ? stubReturnValue : undefined;\n  },\n\n  // Before calling a method stub, prepare all stores to track changes and allow\n  // _retrieveAndStoreOriginals to get the original versions of changed\n  // documents.\n  _saveOriginals: function () {\n    var self = this;\n    if (!self._waitingForQuiescence())\n      self._flushBufferedWrites();\n    _.each(self._stores, function (s) {\n      s.saveOriginals();\n    });\n  },\n  // Retrieves the original versions of all documents modified by the stub for\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n  // by document) and _documentsWrittenByStub (keyed by method ID).\n  _retrieveAndStoreOriginals: function (methodId) {\n    var self = this;\n    if (self._documentsWrittenByStub[methodId])\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n\n    var docsWritten = [];\n    _.each(self._stores, function (s, collection) {\n      var originals = s.retrieveOriginals();\n      // not all stores define retrieveOriginals\n      if (!originals)\n        return;\n      originals.forEach(function (doc, id) {\n        docsWritten.push({collection: collection, id: id});\n        if (!_.has(self._serverDocuments, collection))\n          self._serverDocuments[collection] = new MongoIDMap;\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n        if (serverDoc.writtenByStubs) {\n          // We're not the first stub to write this doc. Just add our method ID\n          // to the record.\n          serverDoc.writtenByStubs[methodId] = true;\n        } else {\n          // First stub! Save the original value and our method ID.\n          serverDoc.document = doc;\n          serverDoc.flushCallbacks = [];\n          serverDoc.writtenByStubs = {};\n          serverDoc.writtenByStubs[methodId] = true;\n        }\n      });\n    });\n    if (!_.isEmpty(docsWritten)) {\n      self._documentsWrittenByStub[methodId] = docsWritten;\n    }\n  },\n\n  // This is very much a private function we use to make the tests\n  // take up fewer server resources after they complete.\n  _unsubscribeAll: function () {\n    var self = this;\n    _.each(_.clone(self._subscriptions), function (sub, id) {\n      // Avoid killing the autoupdate subscription so that developers\n      // still get hot code pushes when writing tests.\n      //\n      // XXX it's a hack to encode knowledge about autoupdate here,\n      // but it doesn't seem worth it yet to have a special API for\n      // subscriptions to preserve after unit tests.\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n        self._subscriptions[id].stop();\n      }\n    });\n  },\n\n  // Sends the DDP stringification of the given message object\n  _send: function (obj) {\n    var self = this;\n    self._stream.send(DDPCommon.stringifyDDP(obj));\n  },\n\n  // We detected via DDP-level heartbeats that we've lost the\n  // connection.  Unlike `disconnect` or `close`, a lost connection\n  // will be automatically retried.\n  _lostConnection: function (error) {\n    var self = this;\n    self._stream._lostConnection(error);\n  },\n\n  /**\n   * @summary Get the current connection status. A reactive data source.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  status: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.status.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n\n  This method does nothing if the client is already connected.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  reconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.reconnect.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Disconnect the client from the server.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  disconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.disconnect.apply(self._stream, arguments);\n  },\n\n  close: function () {\n    var self = this;\n    return self._stream.disconnect({_permanent: true});\n  },\n\n  ///\n  /// Reactive user system\n  ///\n  userId: function () {\n    var self = this;\n    if (self._userIdDeps)\n      self._userIdDeps.depend();\n    return self._userId;\n  },\n\n  setUserId: function (userId) {\n    var self = this;\n    // Avoid invalidating dependents if setUserId is called with current value.\n    if (self._userId === userId)\n      return;\n    self._userId = userId;\n    if (self._userIdDeps)\n      self._userIdDeps.changed();\n  },\n\n  // Returns true if we are in a state after reconnect of waiting for subs to be\n  // revived or early methods to finish their data, or we are waiting for a\n  // \"wait\" method to finish.\n  _waitingForQuiescence: function () {\n    var self = this;\n    return (! _.isEmpty(self._subsBeingRevived) ||\n            ! _.isEmpty(self._methodsBlockingQuiescence));\n  },\n\n  // Returns true if any method whose message has been sent to the server has\n  // not yet invoked its user callback.\n  _anyMethodsAreOutstanding: function () {\n    var self = this;\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n  },\n\n  _livedata_connected: function (msg) {\n    var self = this;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout: function () {\n          self._lostConnection(\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n        },\n        sendPing: function () {\n          self._send({msg: 'ping'});\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId)\n      self._resetStores = true;\n\n    if (typeof (msg.session) === \"string\") {\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.  Note that right\n      // now, this never happens: the server never connects us to a previous\n      // session, because DDP doesn't provide enough data for the server to know\n      // what messages the client has processed. We need to improve DDP to make\n      // this possible, at which point we'll probably need more code here.\n      return;\n    }\n\n    // Server doesn't have our data any more. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = {};\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = {};\n      self._serverDocuments = {};\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready (ie, we already called the\n    // ready callback) as needing to be revived.\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\n    self._subsBeingRevived = {};\n    _.each(self._subscriptions, function (sub, id) {\n      if (sub.ready)\n        self._subsBeingRevived[id] = true;\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = {};\n    if (self._resetStores) {\n      _.each(self._methodInvokers, function (invoker) {\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        _.each(self._stores, function (s) {\n          s.beginUpdate(0, true);\n          s.endUpdate();\n        });\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  },\n\n\n  _processOneDataMessage: function (msg, updates) {\n    var self = this;\n    // Using underscore here so as not to need to capitalize.\n    self['_process_' + msg.msg](msg, updates);\n  },\n\n\n  _livedata_data: function (msg) {\n    var self = this;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === \"nosub\")\n        delete self._subsBeingRevived[msg.id];\n\n      _.each(msg.subs || [], function (subId) {\n        delete self._subsBeingRevived[subId];\n      });\n      _.each(msg.methods || [], function (methodId) {\n        delete self._methodsBlockingQuiescence[methodId];\n      });\n\n      if (self._waitingForQuiescence())\n        return;\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n        self._processOneDataMessage(bufferedMsg, self._bufferedWrites);\n      });\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      self._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    var standardWrite = _.include(['added', 'changed', 'removed'], msg.msg);\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n    }\n    else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites,\n                                                      self._bufferedWritesInterval);\n  },\n\n  _flushBufferedWrites: function () {\n    var self = this;\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n      self._bufferedWritesFlushHandle = null;\n    }\n\n    self._bufferedWritesFlushAt = null;\n    // We need to clear the buffer before passing it to\n    //  performWrites. As there's no guarantee that it\n    //  will exit cleanly.\n    var writes = self._bufferedWrites;\n    self._bufferedWrites = {};\n    self._performWrites(writes);\n  },\n\n  _performWrites: function(updates){\n    var self = this;\n\n    if (self._resetStores || !_.isEmpty(updates)) {\n      // Begin a transactional update of each store.\n      _.each(self._stores, function (s, storeName) {\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\n                      self._resetStores);\n      });\n      self._resetStores = false;\n\n      _.each(updates, function (updateMessages, storeName) {\n        var store = self._stores[storeName];\n        if (store) {\n          _.each(updateMessages, function (updateMessage) {\n            store.update(updateMessage);\n          });\n        } else {\n          // Nobody's listening for this data. Queue it up until\n          // someone wants it.\n          // XXX memory use will grow without bound if you forget to\n          // create a collection or just don't care about it... going\n          // to have to do something about that.\n          if (!_.has(self._updatesForUnknownStores, storeName))\n            self._updatesForUnknownStores[storeName] = [];\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\n                                     updateMessages);\n        }\n      });\n\n      // End update transaction.\n      _.each(self._stores, function (s) { s.endUpdate(); });\n    }\n\n    self._runAfterUpdateCallbacks();\n  },\n\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n  // relevant docs have been flushed, as well as dataVisible callbacks at\n  // reconnect-quiescence time.\n  _runAfterUpdateCallbacks: function () {\n    var self = this;\n    var callbacks = self._afterUpdateCallbacks;\n    self._afterUpdateCallbacks = [];\n    _.each(callbacks, function (c) {\n      c();\n    });\n  },\n\n  _pushUpdate: function (updates, collection, msg) {\n    var self = this;\n    if (!_.has(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  },\n\n  _getServerDoc: function (collection, id) {\n    var self = this;\n    if (!_.has(self._serverDocuments, collection))\n      return null;\n    var serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  },\n\n  _process_added: function (msg, updates) {\n    var self = this;\n    var id = MongoID.idParse(msg.id);\n    var serverDoc = self._getServerDoc(msg.collection, id);\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      var isExisting = (serverDoc.document !== undefined);\n\n      serverDoc.document = msg.fields || {};\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined)\n          msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_changed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_removed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  },\n\n  _process_updated: function (msg, updates) {\n    var self = this;\n    // Process \"method done\" messages.\n    _.each(msg.methods, function (methodId) {\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\n        var serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc)\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n        if (!serverDoc.writtenByStubs[methodId])\n          throw new Error(\"Doc \" + JSON.stringify(written) +\n                          \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          _.each(serverDoc.flushCallbacks, function (c) {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      var callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker)\n        throw new Error(\"No callback invoker for method \" + methodId);\n      self._runWhenAllServerDocsAreFlushed(\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\n    });\n  },\n\n  _process_ready: function (msg, updates) {\n    var self = this;\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    _.each(msg.subs, function (subId) {\n      self._runWhenAllServerDocsAreFlushed(function () {\n        var subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord)\n          return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready)\n          return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  },\n\n  // Ensures that \"f\" will be called after all documents currently in\n  // _serverDocuments have been written to the local cache. f will not be called\n  // if the connection is lost before then!\n  _runWhenAllServerDocsAreFlushed: function (f) {\n    var self = this;\n    var runFAfterUpdates = function () {\n      self._afterUpdateCallbacks.push(f);\n    };\n    var unflushedServerDocCount = 0;\n    var onServerDocFlush = function () {\n      --unflushedServerDocCount;\n      if (unflushedServerDocCount === 0) {\n        // This was the last doc to flush! Arrange to run f after the updates\n        // have been applied.\n        runFAfterUpdates();\n      }\n    };\n    _.each(self._serverDocuments, function (collectionDocs) {\n      collectionDocs.forEach(function (serverDoc) {\n        var writtenByStubForAMethodWithSentMessage = _.any(\n          serverDoc.writtenByStubs, function (dummy, methodId) {\n            var invoker = self._methodInvokers[methodId];\n            return invoker && invoker.sentMessage;\n          });\n        if (writtenByStubForAMethodWithSentMessage) {\n          ++unflushedServerDocCount;\n          serverDoc.flushCallbacks.push(onServerDocFlush);\n        }\n      });\n    });\n    if (unflushedServerDocCount === 0) {\n      // There aren't any buffered docs --- we can call f as soon as the current\n      // round of updates is applied!\n      runFAfterUpdates();\n    }\n  },\n\n  _livedata_nosub: function (msg) {\n    var self = this;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    self._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!_.has(self._subscriptions, msg.id))\n      return;\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    var meteorErrorFromMsg = function (msgArg) {\n      return msgArg && msgArg.error && new Meteor.Error(\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  },\n\n  _process_nosub: function () {\n    // This is called as part of the \"buffer until quiescence\" process, but\n    // nosub's effect is always immediate. It only goes in the buffer at all\n    // because it's possible for a nosub to be the thing that triggers\n    // quiescence, if we were waiting for a sub to be revived and it dies\n    // instead.\n  },\n\n  _livedata_result: function (msg) {\n    // id, result or error. error has error (code), reason, details\n\n    var self = this;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!_.isEmpty(self._bufferedWrites)) {\n      self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug(\"Received method result but no methods outstanding\");\n      return;\n    }\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    var m;\n    for (var i = 0; i < currentMethodBlock.length; i++) {\n      m = currentMethodBlock[i];\n      if (m.methodId === msg.id)\n        break;\n    }\n\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (_.has(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(\n        msg.error.error, msg.error.reason,\n        msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a\n      // value\n      m.receiveResult(undefined, msg.result);\n    }\n  },\n\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\n  // the last outstanding method in the current block, runs the next block. If\n  // there are no more methods, consider accepting a hot code push.\n  _outstandingMethodFinished: function () {\n    var self = this;\n    if (self._anyMethodsAreOutstanding())\n      return;\n\n    // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that\n    // half-finished before disconnect/reconnect.)\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\n      var firstBlock = self._outstandingMethodBlocks.shift();\n      if (! _.isEmpty(firstBlock.methods))\n        throw new Error(\"No methods outstanding but nonempty block: \" +\n                        JSON.stringify(firstBlock));\n\n      // Send the outstanding methods now in the first block.\n      if (!_.isEmpty(self._outstandingMethodBlocks))\n        self._sendOutstandingMethods();\n    }\n\n    // Maybe accept a hot code push.\n    self._maybeMigrate();\n  },\n\n  // Sends messages for all the methods in the first block in\n  // _outstandingMethodBlocks.\n  _sendOutstandingMethods: function() {\n    var self = this;\n    if (_.isEmpty(self._outstandingMethodBlocks))\n      return;\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n      m.sendMessage();\n    });\n  },\n\n  _livedata_error: function (msg) {\n    Meteor._debug(\"Received error from server: \", msg.reason);\n    if (msg.offendingMessage)\n      Meteor._debug(\"For: \", msg.offendingMessage);\n  },\n\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\n    var self = this;\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n    self._outstandingMethodBlocks = [];\n\n    self.onReconnect && self.onReconnect();\n    DDP._reconnectHook.each(function (callback) {\n      callback(self);\n      return true;\n    });\n\n    if (_.isEmpty(oldOutstandingMethodBlocks))\n      return;\n\n    // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just\n    // restore all outstanding methods and run the first block.\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n      self._sendOutstandingMethods();\n      return;\n    }\n\n    // OK, there are blocks on both sides. Special case: merge the last block of\n    // the reconnect methods with the first block of the original methods, if\n    // neither of them are \"wait\" blocks.\n    if (!_.last(self._outstandingMethodBlocks).wait &&\n        !oldOutstandingMethodBlocks[0].wait) {\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n        _.last(self._outstandingMethodBlocks).methods.push(m);\n\n        // If this \"last block\" is also the first block, send the message.\n        if (self._outstandingMethodBlocks.length === 1)\n          m.sendMessage();\n      });\n\n      oldOutstandingMethodBlocks.shift();\n    }\n\n    // Now add the rest of the original blocks on.\n    _.each(oldOutstandingMethodBlocks, function (block) {\n      self._outstandingMethodBlocks.push(block);\n    });\n  },\n\n  // We can accept a hot code push if there are no methods in flight.\n  _readyToMigrate: function() {\n    var self = this;\n    return _.isEmpty(self._methodInvokers);\n  },\n\n  // If we were blocking a migration, see if it's now possible to continue.\n  // Call whenever the set of outstanding/blocked methods shrinks.\n  _maybeMigrate: function () {\n    var self = this;\n    if (self._retryMigrate && self._readyToMigrate()) {\n      self._retryMigrate();\n      self._retryMigrate = null;\n    }\n  }\n});\n\nLivedataTest.Connection = Connection;\n\n// @param url {String} URL to Meteor app,\n//     e.g.:\n//     \"subdomain.meteor.com\",\n//     \"http://subdomain.meteor.com\",\n//     \"/\",\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n/**\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere\n * @param {String} url The URL of another Meteor application.\n */\nDDP.connect = function (url, options) {\n  var ret = new Connection(url, options);\n  allConnections.push(ret); // hack. see below.\n  return ret;\n};\n\nDDP._reconnectHook = new Hook({ bindEnvironment: false });\n\n/**\n * @summary Register a function to call as the first step of\n * reconnecting. This function can call methods which will be executed before\n * any other outstanding methods. For example, this can be used to re-establish\n * the appropriate authentication context on the connection.\n * @locus Anywhere\n * @param {Function} callback The function to call. It will be called with a\n * single argument, the [connection object](#ddp_connect) that is reconnecting.\n */\nDDP.onReconnect = function (callback) {\n  return DDP._reconnectHook.register(callback);\n};\n\n// Hack for `spiderable` package: a way to see if the page is done\n// loading all the data it needs.\n//\nallConnections = [];\nDDP._allSubscriptionsReady = function () {\n  return _.all(allConnections, function (conn) {\n    return _.all(conn._subscriptions, function (sub) {\n      return sub.ready;\n    });\n  });\n};\n"]},"hash":"124d150282c9cfd60c2a4ad0e840142bdc628a55"}
