{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"./namespace.js","imported":["DDP","LivedataTest"],"specifiers":[{"kind":"named","imported":"DDP","local":"DDP"},{"kind":"named","imported":"LivedataTest","local":"LivedataTest"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/ddp-client/stream_client_sockjs.js","filenameRelative":"packages/ddp-client/stream_client_sockjs.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ddp-client/stream_client_sockjs.js.map","sourceFileName":"packages/ddp-client/stream_client_sockjs.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"stream_client_sockjs"},"ignored":false,"code":"var DDP = void 0,\n    LivedataTest = void 0;\nmodule.watch(require(\"./namespace.js\"), {\n  DDP: function (v) {\n    DDP = v;\n  },\n  LivedataTest: function (v) {\n    LivedataTest = v;\n  }\n}, 0);\n\n// @param url {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\nLivedataTest.ClientStream = function (url, options) {\n  var self = this;\n  self.options = _.extend({\n    retry: true\n  }, options);\n\n  self._initCommon(self.options); //// Constants\n  // how long between hearing heartbeat from the server until we declare\n  // the connection dead. heartbeats come every 45s (stream_server.js)\n  //\n  // NOTE: this is a older timeout mechanism. We now send heartbeats at\n  // the DDP level (https://github.com/meteor/meteor/pull/1865), and\n  // expect those timeouts to kill a non-responsive connection before\n  // this timeout fires. This is kept around for compatibility (when\n  // talking to a server that doesn't support DDP heartbeats) and can be\n  // removed later.\n\n\n  self.HEARTBEAT_TIMEOUT = 100 * 1000;\n  self.rawUrl = url;\n  self.socket = null;\n  self.heartbeatTimer = null; // Listen to global 'online' event if we are running in a browser.\n  // (IE8 does not support addEventListener)\n\n  if (typeof window !== 'undefined' && window.addEventListener) window.addEventListener(\"online\", _.bind(self._online, self), false /* useCapture. make FF3.6 happy. */); //// Kickoff!\n\n  self._launchConnection();\n};\n\n_.extend(LivedataTest.ClientStream.prototype, {\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send: function (data) {\n    var self = this;\n\n    if (self.currentStatus.connected) {\n      self.socket.send(data);\n    }\n  },\n  // Changes where this connection points\n  _changeUrl: function (url) {\n    var self = this;\n    self.rawUrl = url;\n  },\n  _connected: function () {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n\n    if (self.currentStatus.connected) {\n      // already connected. do nothing. this probably shouldn't happen.\n      return;\n    } // update status\n\n\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged(); // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n\n    _.each(self.eventCallbacks.reset, function (callback) {\n      callback();\n    });\n  },\n  _cleanup: function (maybeError) {\n    var self = this;\n\n    self._clearConnectionAndHeartbeatTimers();\n\n    if (self.socket) {\n      self.socket.onmessage = self.socket.onclose = self.socket.onerror = self.socket.onheartbeat = function () {};\n\n      self.socket.close();\n      self.socket = null;\n    }\n\n    _.each(self.eventCallbacks.disconnect, function (callback) {\n      callback(maybeError);\n    });\n  },\n  _clearConnectionAndHeartbeatTimers: function () {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n\n    if (self.heartbeatTimer) {\n      clearTimeout(self.heartbeatTimer);\n      self.heartbeatTimer = null;\n    }\n  },\n  _heartbeat_timeout: function () {\n    var self = this;\n\n    Meteor._debug(\"Connection timeout. No sockjs heartbeat received.\");\n\n    self._lostConnection(new DDP.ConnectionError(\"Heartbeat timed out\"));\n  },\n  _heartbeat_received: function () {\n    var self = this; // If we've already permanently shut down this stream, the timeout is\n    // already cleared, and we don't need to set it again.\n\n    if (self._forcedToDisconnect) return;\n    if (self.heartbeatTimer) clearTimeout(self.heartbeatTimer);\n    self.heartbeatTimer = setTimeout(_.bind(self._heartbeat_timeout, self), self.HEARTBEAT_TIMEOUT);\n  },\n  _sockjsProtocolsWhitelist: function () {\n    // only allow polling protocols. no streaming.  streaming\n    // makes safari spin.\n    var protocolsWhitelist = ['xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling']; // iOS 4 and 5 and below crash when using websockets over certain\n    // proxies. this seems to be resolved with iOS 6. eg\n    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.\n    //\n    // iOS <4 doesn't support websockets at all so sockjs will just\n    // immediately fall back to http\n\n    var noWebsockets = navigator && /iPhone|iPad|iPod/.test(navigator.userAgent) && /OS 4_|OS 5_/.test(navigator.userAgent);\n    if (!noWebsockets) protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);\n    return protocolsWhitelist;\n  },\n  _launchConnection: function () {\n    var self = this;\n\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n\n    var options = _.extend({\n      protocols_whitelist: self._sockjsProtocolsWhitelist()\n    }, self.options._sockjsOptions); // Convert raw URL to SockJS URL each time we open a connection, so that we\n    // can connect to random hostnames and get around browser per-host\n    // connection limits.\n\n\n    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);\n\n    self.socket.onopen = function (data) {\n      self._connected();\n    };\n\n    self.socket.onmessage = function (data) {\n      self._heartbeat_received();\n\n      if (self.currentStatus.connected) _.each(self.eventCallbacks.message, function (callback) {\n        callback(data.data);\n      });\n    };\n\n    self.socket.onclose = function () {\n      self._lostConnection();\n    };\n\n    self.socket.onerror = function () {\n      // XXX is this ever called?\n      Meteor._debug(\"stream error\", _.toArray(arguments), new Date().toDateString());\n    };\n\n    self.socket.onheartbeat = function () {\n      self._heartbeat_received();\n    };\n\n    if (self.connectionTimer) clearTimeout(self.connectionTimer);\n    self.connectionTimer = setTimeout(function () {\n      self._lostConnection(new DDP.ConnectionError(\"DDP connection timed out\"));\n    }, self.CONNECT_TIMEOUT);\n  }\n});","map":{"version":3,"sources":["packages/ddp-client/stream_client_sockjs.js"],"names":["DDP","LivedataTest","module","watch","require","v","ClientStream","url","options","self","_","extend","retry","_initCommon","HEARTBEAT_TIMEOUT","rawUrl","socket","heartbeatTimer","window","addEventListener","bind","_online","_launchConnection","prototype","send","data","currentStatus","connected","_changeUrl","_connected","connectionTimer","clearTimeout","status","retryCount","statusChanged","each","eventCallbacks","reset","callback","_cleanup","maybeError","_clearConnectionAndHeartbeatTimers","onmessage","onclose","onerror","onheartbeat","close","disconnect","_heartbeat_timeout","Meteor","_debug","_lostConnection","ConnectionError","_heartbeat_received","_forcedToDisconnect","setTimeout","_sockjsProtocolsWhitelist","protocolsWhitelist","noWebsockets","navigator","test","userAgent","concat","protocols_whitelist","_sockjsOptions","SockJS","toSockjsUrl","undefined","onopen","message","toArray","arguments","Date","toDateString","CONNECT_TIMEOUT"],"mappings":"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","file":"packages/ddp-client/stream_client_sockjs.js.map","sourcesContent":["import { DDP, LivedataTest } from \"./namespace.js\";\n\n// @param url {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\nLivedataTest.ClientStream = function (url, options) {\n  var self = this;\n  self.options = _.extend({\n    retry: true\n  }, options);\n  self._initCommon(self.options);\n\n  //// Constants\n\n\n  // how long between hearing heartbeat from the server until we declare\n  // the connection dead. heartbeats come every 45s (stream_server.js)\n  //\n  // NOTE: this is a older timeout mechanism. We now send heartbeats at\n  // the DDP level (https://github.com/meteor/meteor/pull/1865), and\n  // expect those timeouts to kill a non-responsive connection before\n  // this timeout fires. This is kept around for compatibility (when\n  // talking to a server that doesn't support DDP heartbeats) and can be\n  // removed later.\n  self.HEARTBEAT_TIMEOUT = 100*1000;\n\n  self.rawUrl = url;\n  self.socket = null;\n\n  self.heartbeatTimer = null;\n\n  // Listen to global 'online' event if we are running in a browser.\n  // (IE8 does not support addEventListener)\n  if (typeof window !== 'undefined' && window.addEventListener)\n    window.addEventListener(\"online\", _.bind(self._online, self),\n                            false /* useCapture. make FF3.6 happy. */);\n\n  //// Kickoff!\n  self._launchConnection();\n};\n\n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send: function (data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.socket.send(data);\n    }\n  },\n\n  // Changes where this connection points\n  _changeUrl: function (url) {\n    var self = this;\n    self.rawUrl = url;\n  },\n\n  _connected: function () {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n\n    if (self.currentStatus.connected) {\n      // already connected. do nothing. this probably shouldn't happen.\n      return;\n    }\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n\n  },\n\n  _cleanup: function (maybeError) {\n    var self = this;\n\n    self._clearConnectionAndHeartbeatTimers();\n    if (self.socket) {\n      self.socket.onmessage = self.socket.onclose\n        = self.socket.onerror = self.socket.onheartbeat = function () {};\n      self.socket.close();\n      self.socket = null;\n    }\n\n    _.each(self.eventCallbacks.disconnect, function (callback) {\n      callback(maybeError);\n    });\n  },\n\n  _clearConnectionAndHeartbeatTimers: function () {\n    var self = this;\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n    if (self.heartbeatTimer) {\n      clearTimeout(self.heartbeatTimer);\n      self.heartbeatTimer = null;\n    }\n  },\n\n  _heartbeat_timeout: function () {\n    var self = this;\n    Meteor._debug(\"Connection timeout. No sockjs heartbeat received.\");\n    self._lostConnection(new DDP.ConnectionError(\"Heartbeat timed out\"));\n  },\n\n  _heartbeat_received: function () {\n    var self = this;\n    // If we've already permanently shut down this stream, the timeout is\n    // already cleared, and we don't need to set it again.\n    if (self._forcedToDisconnect)\n      return;\n    if (self.heartbeatTimer)\n      clearTimeout(self.heartbeatTimer);\n    self.heartbeatTimer = setTimeout(\n      _.bind(self._heartbeat_timeout, self),\n      self.HEARTBEAT_TIMEOUT);\n  },\n\n  _sockjsProtocolsWhitelist: function () {\n    // only allow polling protocols. no streaming.  streaming\n    // makes safari spin.\n    var protocolsWhitelist = [\n      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];\n\n    // iOS 4 and 5 and below crash when using websockets over certain\n    // proxies. this seems to be resolved with iOS 6. eg\n    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.\n    //\n    // iOS <4 doesn't support websockets at all so sockjs will just\n    // immediately fall back to http\n    var noWebsockets = navigator &&\n          /iPhone|iPad|iPod/.test(navigator.userAgent) &&\n          /OS 4_|OS 5_/.test(navigator.userAgent);\n\n    if (!noWebsockets)\n      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);\n\n    return protocolsWhitelist;\n  },\n\n  _launchConnection: function () {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    var options = _.extend({\n      protocols_whitelist:self._sockjsProtocolsWhitelist()\n    }, self.options._sockjsOptions);\n\n    // Convert raw URL to SockJS URL each time we open a connection, so that we\n    // can connect to random hostnames and get around browser per-host\n    // connection limits.\n    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);\n    self.socket.onopen = function (data) {\n      self._connected();\n    };\n    self.socket.onmessage = function (data) {\n      self._heartbeat_received();\n\n      if (self.currentStatus.connected)\n        _.each(self.eventCallbacks.message, function (callback) {\n          callback(data.data);\n        });\n    };\n    self.socket.onclose = function () {\n      self._lostConnection();\n    };\n    self.socket.onerror = function () {\n      // XXX is this ever called?\n      Meteor._debug(\"stream error\", _.toArray(arguments), (new Date()).toDateString());\n    };\n\n    self.socket.onheartbeat =  function () {\n      self._heartbeat_received();\n    };\n\n    if (self.connectionTimer)\n      clearTimeout(self.connectionTimer);\n    self.connectionTimer = setTimeout(function () {\n      self._lostConnection(\n        new DDP.ConnectionError(\"DDP connection timed out\"));\n    }, self.CONNECT_TIMEOUT);\n  }\n});\n"]},"hash":"c9a60c17d8b3e2b8f0b3880b6c098920fb681776"}
