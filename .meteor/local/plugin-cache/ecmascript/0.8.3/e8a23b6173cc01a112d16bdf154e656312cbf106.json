{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"lolex","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"lolex"}]},{"source":"./namespace.js","imported":["DDP","LivedataTest"],"specifiers":[{"kind":"named","imported":"DDP","local":"DDP"},{"kind":"named","imported":"LivedataTest","local":"LivedataTest"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/ddp-client/livedata_connection_tests.js","filenameRelative":"packages/ddp-client/livedata_connection_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ddp-client/livedata_connection_tests.js.map","sourceFileName":"packages/ddp-client/livedata_connection_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"livedata_connection_tests"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar lolex = void 0;\nmodule.watch(require(\"lolex\"), {\n  \"default\": function (v) {\n    lolex = v;\n  }\n}, 0);\nvar DDP = void 0,\n    LivedataTest = void 0;\nmodule.watch(require(\"./namespace.js\"), {\n  DDP: function (v) {\n    DDP = v;\n  },\n  LivedataTest: function (v) {\n    LivedataTest = v;\n  }\n}, 1);\n\nvar newConnection = function (stream, options) {\n  // Some of these tests leave outstanding methods with no result yet\n  // returned. This should not block us from re-running tests when sources\n  // change.\n  return new LivedataTest.Connection(stream, _.extend({\n    reloadWithOutstanding: true,\n    bufferedWritesInterval: 0\n  }, options));\n};\n\nvar makeConnectMessage = function (session) {\n  var msg = {\n    msg: 'connect',\n    version: LivedataTest.SUPPORTED_DDP_VERSIONS[0],\n    support: LivedataTest.SUPPORTED_DDP_VERSIONS\n  };\n  if (session) msg.session = session;\n  return msg;\n}; // Tests that stream got a message that matches expected.\n// Expected is normally an object, and allows a wildcard value of '*',\n// which will then match any value.\n// Returns the message (parsed as a JSON object if expected is an object);\n// which is particularly handy if you want to extract a value that was\n// matched as a wildcard.\n\n\nvar testGotMessage = function (test, stream, expected) {\n  if (stream.sent.length === 0) {\n    test.fail({\n      error: 'no message received',\n      expected: expected\n    });\n    return undefined;\n  }\n\n  var got = stream.sent.shift();\n  if (typeof got === 'string' && (typeof expected === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(expected)) === 'object') got = JSON.parse(got); // An expected value of '*' matches any value, and the matching value (or\n  // array of matching values, if there are multiple) is returned from this\n  // function.\n\n  if ((typeof expected === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(expected)) === 'object') {\n    var keysWithStarValues = [];\n\n    _.each(expected, function (v, k) {\n      if (v === '*') keysWithStarValues.push(k);\n    });\n\n    _.each(keysWithStarValues, function (k) {\n      expected[k] = got[k];\n    });\n  }\n\n  test.equal(got, expected);\n  return got;\n};\n\nvar startAndConnect = function (test, stream) {\n  stream.reset(); // initial connection start.\n\n  testGotMessage(test, stream, makeConnectMessage());\n  test.length(stream.sent, 0);\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID\n  });\n  test.length(stream.sent, 0);\n};\n\nvar SESSION_ID = '17';\nTinytest.add(\"livedata stub - receive data\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // data comes in for unknown collection.\n\n  var coll_name = Random.id();\n  stream.receive({\n    msg: 'added',\n    collection: coll_name,\n    id: '1234',\n    fields: {\n      a: 1\n    }\n  }); // break throught the black box and test internal state\n\n  test.length(conn._updatesForUnknownStores[coll_name], 1); // XXX: Test that the old signature of passing manager directly instead of in\n  // options works.\n\n  var coll = new Mongo.Collection(coll_name, conn); // queue has been emptied and doc is in db.\n\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n  test.equal(coll.find({}).fetch(), [{\n    _id: '1234',\n    a: 1\n  }]); // second message. applied directly to the db.\n\n  stream.receive({\n    msg: 'changed',\n    collection: coll_name,\n    id: '1234',\n    fields: {\n      a: 2\n    }\n  });\n  test.equal(coll.find({}).fetch(), [{\n    _id: '1234',\n    a: 2\n  }]);\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n});\nTinytest.add(\"livedata stub - buffering data\", function (test) {\n  // Install special setTimeout that allows tick-by-tick control in tests using sinonjs 'lolex'\n  // This needs to be before the connection is instantiated.\n  var clock = lolex.install();\n\n  var tick = function (timeout) {\n    return clock.tick(timeout);\n  };\n\n  var stream = new StubStream();\n  var conn = newConnection(stream, {\n    bufferedWritesInterval: 10,\n    bufferedWritesMaxAge: 40\n  });\n  startAndConnect(test, stream);\n  var coll_name = Random.id();\n  var coll = new Mongo.Collection(coll_name, conn);\n\n  var testDocCount = function (count) {\n    return test.equal(coll.find({}).count(), count);\n  };\n\n  var addDoc = function () {\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: Random.id(),\n      fields: {}\n    });\n  }; // Starting at 0 ticks.  At this point we haven't advanced the fake clock at all.\n\n\n  addDoc(); // 1st Doc\n\n  testDocCount(0); // No doc been recognized yet because it's buffered, waiting for more.\n\n  tick(6); // 6 total ticks\n\n  testDocCount(0); // Ensure that the doc still hasn't shown up, despite the clock moving forward.\n\n  tick(4); // 10 total ticks, 1st buffer interval\n\n  testDocCount(1); // No other docs have arrived, so we 'see' the 1st doc.\n\n  addDoc(); // 2nd doc\n\n  tick(1); // 11 total ticks (1 since last flush)\n\n  testDocCount(1); // Again, second doc hasn't arrived because we're waiting for more...\n\n  tick(9); // 20 total ticks (10 ticks since last flush & the 2nd 10-tick interval)\n\n  testDocCount(2); // Now we're here and got the second document.\n  // Add several docs, frequently enough that we buffer multiple times before the next flush.\n\n  addDoc(); // 3 docs\n\n  tick(6); // 26 ticks (6 since last flush)\n\n  addDoc(); // 4 docs\n\n  tick(6); // 32 ticks (12 since last flush)\n\n  addDoc(); // 5 docs\n\n  tick(6); // 38 ticks (18 since last flush)\n\n  addDoc(); // 6 docs\n\n  tick(6); // 44 ticks (24 since last flush)\n\n  addDoc(); // 7 docs\n\n  tick(9); // 53 ticks (33 since last flush)\n\n  addDoc(); // 8 docs\n\n  tick(9); // 62 ticks! (42 ticks since last flush, over max-age - next interval triggers flush)\n\n  testDocCount(2); // Still at 2 from before! (Just making sure)\n\n  tick(1); // Ok, 63 ticks (10 since last doc, so this should cause the flush of all the docs)\n\n  testDocCount(8); // See all the docs.\n  // Put things back how they were.\n\n  clock.uninstall();\n});\nTinytest.add(\"livedata stub - subscribe\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // subscribe\n\n  var callback_fired = false;\n  var sub = conn.subscribe('my_data', function () {\n    callback_fired = true;\n  });\n  test.isFalse(callback_fired);\n  test.length(stream.sent, 1);\n  var message = JSON.parse(stream.sent.shift());\n  var id = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'my_data',\n    params: []\n  });\n  var reactivelyReady = false;\n  var autorunHandle = Tracker.autorun(function () {\n    reactivelyReady = sub.ready();\n  });\n  test.isFalse(reactivelyReady); // get the sub satisfied. callback fires.\n\n  stream.receive({\n    msg: 'ready',\n    'subs': [id]\n  });\n  test.isTrue(callback_fired);\n  Tracker.flush();\n  test.isTrue(reactivelyReady); // Unsubscribe.\n\n  sub.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: id\n  });\n  Tracker.flush();\n  test.isFalse(reactivelyReady); // Resubscribe.\n\n  conn.subscribe('my_data');\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  var id2 = message.id;\n  test.notEqual(id, id2);\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'my_data',\n    params: []\n  });\n});\nTinytest.add(\"livedata stub - reactive subscribe\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var rFoo = new ReactiveVar('foo1');\n  var rBar = new ReactiveVar('bar1');\n  var onReadyCount = {};\n\n  var onReady = function (tag) {\n    return function () {\n      if (_.has(onReadyCount, tag)) ++onReadyCount[tag];else onReadyCount[tag] = 1;\n    };\n  }; // Subscribe to some subs.\n\n\n  var stopperHandle, completerHandle;\n  var autorunHandle = Tracker.autorun(function () {\n    conn.subscribe(\"foo\", rFoo.get(), onReady(rFoo.get()));\n    conn.subscribe(\"bar\", rBar.get(), onReady(rBar.get()));\n    completerHandle = conn.subscribe(\"completer\", onReady(\"completer\"));\n    stopperHandle = conn.subscribe(\"stopper\", onReady(\"stopper\"));\n  });\n  var completerReady;\n  var readyAutorunHandle = Tracker.autorun(function () {\n    completerReady = completerHandle.ready();\n  }); // Check sub messages. (Assume they are sent in the order executed.)\n\n  test.length(stream.sent, 4);\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo1']\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idBar1 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'bar',\n    params: ['bar1']\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idCompleter = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'completer',\n    params: []\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idStopper = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'stopper',\n    params: []\n  }); // Haven't hit onReady yet.\n\n  test.equal(onReadyCount, {});\n  Tracker.flush();\n  test.isFalse(completerReady); // \"completer\" gets ready now. its callback should fire.\n\n  stream.receive({\n    msg: 'ready',\n    'subs': [idCompleter]\n  });\n  test.equal(onReadyCount, {\n    completer: 1\n  });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(completerReady); // Stop 'stopper'.\n\n  stopperHandle.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idStopper\n  });\n  test.equal(onReadyCount, {\n    completer: 1\n  });\n  Tracker.flush();\n  test.isTrue(completerReady); // Change the foo subscription and flush. We should sub to the new foo\n  // subscription, re-sub to the stopper subscription, and then unsub from the old\n  // foo subscription. The bar subscription should be unaffected. The completer\n  // subscription should call its new onReady callback, because we always\n  // call onReady for a given reactively-saved subscription.\n  // The completerHandle should have been reestablished to the ready handle.\n\n  rFoo.set(\"foo2\");\n  Tracker.flush();\n  test.length(stream.sent, 3);\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo2']\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idStopperAgain = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'stopper',\n    params: []\n  });\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idFoo1\n  });\n  test.equal(onReadyCount, {\n    completer: 2\n  });\n  test.isTrue(completerReady); // Ready the stopper and bar subs. Completing stopper should call only the\n  // onReady from the new subscription because they were separate subscriptions\n  // started at different times and the first one was explicitly torn down by\n  // the client; completing bar should call the onReady from the new\n  // subscription because we always call onReady for a given reactively-saved\n  // subscription.\n\n  stream.receive({\n    msg: 'ready',\n    'subs': [idStopperAgain, idBar1]\n  });\n  test.equal(onReadyCount, {\n    completer: 2,\n    bar1: 1,\n    stopper: 1\n  }); // Shut down the autorun. This should unsub us from all current subs at flush\n  // time.\n\n  autorunHandle.stop();\n  Tracker.flush();\n  test.isFalse(completerReady);\n  readyAutorunHandle.stop();\n  test.length(stream.sent, 4); // The order of unsubs here is not important.\n\n  var unsubMessages = _.map(stream.sent, JSON.parse);\n\n  stream.sent.length = 0;\n  test.equal(_.unique(_.pluck(unsubMessages, 'msg')), ['unsub']);\n\n  var actualIds = _.pluck(unsubMessages, 'id');\n\n  var expectedIds = [idFoo2, idBar1, idCompleter, idStopperAgain];\n  actualIds.sort();\n  expectedIds.sort();\n  test.equal(actualIds, expectedIds);\n});\nTinytest.add(\"livedata stub - reactive subscribe handle correct\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var rFoo = new ReactiveVar('foo1'); // Subscribe to some subs.\n\n  var fooHandle, fooReady;\n  var autorunHandle = Tracker.autorun(function () {\n    fooHandle = conn.subscribe(\"foo\", rFoo.get());\n    Tracker.autorun(function () {\n      fooReady = fooHandle.ready();\n    });\n  });\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo1']\n  }); // Not ready yet\n\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady); // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, reading the new false value, and\n  // setting up a new dep which goes true soon\n\n  rFoo.set(\"foo2\");\n  Tracker.flush();\n  test.length(stream.sent, 2);\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo2']\n  });\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idFoo1\n  });\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady); // \"foo\" gets ready now. The handle should be ready and the autorun rerun\n\n  stream.receive({\n    msg: 'ready',\n    'subs': [idFoo2]\n  });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady); // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, making fooReady false too\n\n  rFoo.set(\"foo3\");\n  Tracker.flush();\n  test.length(stream.sent, 2);\n  message = JSON.parse(stream.sent.shift());\n  var idFoo3 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo3']\n  });\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idFoo2\n  });\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady); // \"foo\" gets ready again\n\n  stream.receive({\n    msg: 'ready',\n    'subs': [idFoo3]\n  });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady);\n  autorunHandle.stop();\n});\nTinytest.add(\"livedata stub - this\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  conn.methods({\n    test_this: function () {\n      test.isTrue(this.isSimulation);\n      this.unblock(); // should be a no-op\n    }\n  }); // should throw no exceptions\n\n  conn.call('test_this', _.identity); // satisfy method, quiesce connection\n\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {\n    msg: 'method',\n    method: 'test_this',\n    params: [],\n    id: message.id\n  });\n  test.length(stream.sent, 0);\n  stream.receive({\n    msg: 'result',\n    id: message.id,\n    result: null\n  });\n  stream.receive({\n    msg: 'updated',\n    'methods': [message.id]\n  });\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - methods\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    }); // setup method\n\n    conn.methods({\n      do_something: function (x) {\n        coll.insert({\n          value: x\n        });\n      }\n    }); // setup observers\n\n    var counts = {\n      added: 0,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    };\n    var handle = coll.find({}).observe({\n      addedAt: function () {\n        counts.added += 1;\n      },\n      removedAt: function () {\n        counts.removed += 1;\n      },\n      changedAt: function () {\n        counts.changed += 1;\n      },\n      movedTo: function () {\n        counts.moved += 1;\n      }\n    }); // call method with results callback\n\n    var callback1Fired = false;\n    conn.call('do_something', 'friday!', function (err, res) {\n      test.isUndefined(err);\n      test.equal(res, '1234');\n      callback1Fired = true;\n    });\n    test.isFalse(callback1Fired); // observers saw the method run.\n\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    }); // get response from server\n\n    var message = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: ['friday!'],\n      id: '*',\n      randomSeed: '*'\n    });\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'friday!'\n    }).count(), 1);\n\n    var docId = coll.findOne({\n      value: 'friday!'\n    })._id; // results does not yet result in callback, because data is not\n    // ready.\n\n\n    stream.receive({\n      msg: 'result',\n      id: message.id,\n      result: \"1234\"\n    });\n    test.isFalse(callback1Fired); // result message doesn't affect data\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'friday!'\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    }); // data methods do not show up (not quiescent yet)\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(docId),\n      fields: {\n        value: 'tuesday'\n      }\n    });\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'friday!'\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    }); // send another methods (unknown on client)\n\n    var callback2Fired = false;\n    conn.call('do_something_else', 'monday', function (err, res) {\n      callback2Fired = true;\n    });\n    test.isFalse(callback1Fired);\n    test.isFalse(callback2Fired); // test we still send a method request to server\n\n    var message2 = JSON.parse(stream.sent.shift());\n    test.isUndefined(message2.randomSeed);\n    test.equal(message2, {\n      msg: 'method',\n      method: 'do_something_else',\n      params: ['monday'],\n      id: message2.id\n    }); // get the first data satisfied message. changes are applied to database even\n    // though another method is outstanding, because the other method didn't have\n    // a stub. and its callback is called.\n\n    stream.receive({\n      msg: 'updated',\n      'methods': [message.id]\n    });\n    test.isTrue(callback1Fired);\n    test.isFalse(callback2Fired);\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'tuesday'\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 1,\n      moved: 0\n    }); // second result\n\n    stream.receive({\n      msg: 'result',\n      id: message2.id,\n      result: \"bupkis\"\n    });\n    test.isFalse(callback2Fired); // get second satisfied; no new changes are applied.\n\n    stream.receive({\n      msg: 'updated',\n      'methods': [message2.id]\n    });\n    test.isTrue(callback2Fired);\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'tuesday',\n      _id: docId\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 1,\n      moved: 0\n    });\n    handle.stop();\n  });\n}\n\nTinytest.add(\"livedata stub - mutating method args\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  conn.methods({\n    mutateArgs: function (arg) {\n      arg.foo = 42;\n    }\n  });\n  conn.call('mutateArgs', {\n    foo: 50\n  }, _.identity); // Method should be called with original arg, not mutated arg.\n\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {\n    msg: 'method',\n    method: 'mutateArgs',\n    params: [{\n      foo: 50\n    }],\n    id: message.id\n  });\n  test.length(stream.sent, 0);\n});\n\nvar observeCursor = function (test, cursor) {\n  var counts = {\n    added: 0,\n    removed: 0,\n    changed: 0,\n    moved: 0\n  };\n\n  var expectedCounts = _.clone(counts);\n\n  var handle = cursor.observe({\n    addedAt: function () {\n      counts.added += 1;\n    },\n    removedAt: function () {\n      counts.removed += 1;\n    },\n    changedAt: function () {\n      counts.changed += 1;\n    },\n    movedTo: function () {\n      counts.moved += 1;\n    }\n  });\n  return {\n    stop: _.bind(handle.stop, handle),\n    expectCallbacks: function (delta) {\n      _.each(delta, function (mod, field) {\n        expectedCounts[field] += mod;\n      });\n\n      test.equal(counts, expectedCounts);\n    }\n  };\n}; // method calls another method in simulation. see not sent.\n\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - methods calling methods\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var coll_name = Random.id();\n    var coll = new Mongo.Collection(coll_name, {\n      connection: conn\n    }); // setup methods\n\n    conn.methods({\n      do_something: function () {\n        conn.call('do_something_else');\n      },\n      do_something_else: function () {\n        coll.insert({\n          a: 1\n        });\n      }\n    });\n    var o = observeCursor(test, coll.find()); // call method.\n\n    conn.call('do_something', _.identity); // see we only send message for outer methods\n\n    var message = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    });\n    test.length(stream.sent, 0); // but inner method runs locally.\n\n    o.expectCallbacks({\n      added: 1\n    });\n    test.equal(coll.find().count(), 1);\n\n    var docId = coll.findOne()._id;\n\n    test.equal(coll.findOne(), {\n      _id: docId,\n      a: 1\n    }); // we get the results\n\n    stream.receive({\n      msg: 'result',\n      id: message.id,\n      result: \"1234\"\n    }); // get data from the method. data from this doc does not show up yet, but data\n    // from another doc does.\n\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: MongoID.idStringify(docId),\n      fields: {\n        value: 'tuesday'\n      }\n    });\n    o.expectCallbacks();\n    test.equal(coll.findOne(docId), {\n      _id: docId,\n      a: 1\n    });\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: 'monkey',\n      fields: {\n        value: 'bla'\n      }\n    });\n    o.expectCallbacks({\n      added: 1\n    });\n    test.equal(coll.findOne(docId), {\n      _id: docId,\n      a: 1\n    });\n    var newDoc = coll.findOne({\n      value: 'bla'\n    });\n    test.isTrue(newDoc);\n    test.equal(newDoc, {\n      _id: newDoc._id,\n      value: 'bla'\n    }); // get method satisfied. all data shows up. the 'a' field is reverted and\n    // 'value' field is set.\n\n    stream.receive({\n      msg: 'updated',\n      'methods': [message.id]\n    });\n    o.expectCallbacks({\n      changed: 1\n    });\n    test.equal(coll.findOne(docId), {\n      _id: docId,\n      value: 'tuesday'\n    });\n    test.equal(coll.findOne(newDoc._id), {\n      _id: newDoc._id,\n      value: 'bla'\n    });\n    o.stop();\n  });\n}\n\nTinytest.add(\"livedata stub - method call before connect\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  var callbackOutput = [];\n  conn.call('someMethod', function (err, result) {\n    callbackOutput.push(result);\n  });\n  test.equal(callbackOutput, []); // the real stream drops all output pre-connection\n\n  stream.sent.length = 0; // Now connect.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage());\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'someMethod',\n    params: [],\n    id: '*'\n  });\n});\nTinytest.add(\"livedata stub - reconnect\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {\n    connection: conn\n  });\n  var o = observeCursor(test, coll.find()); // subscribe\n\n  var subCallbackFired = false;\n  var sub = conn.subscribe('my_data', function () {\n    subCallbackFired = true;\n  });\n  test.isFalse(subCallbackFired);\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {\n    msg: 'sub',\n    name: 'my_data',\n    params: [],\n    id: subMessage.id\n  }); // get some data. it shows up.\n\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '1234',\n    fields: {\n      a: 1\n    }\n  });\n  test.equal(coll.find({}).count(), 1);\n  o.expectCallbacks({\n    added: 1\n  });\n  test.isFalse(subCallbackFired);\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: '1234',\n    fields: {\n      b: 2\n    }\n  });\n  stream.receive({\n    msg: 'ready',\n    subs: [subMessage.id] // satisfy sub\n\n  });\n  test.isTrue(subCallbackFired);\n  subCallbackFired = false; // re-arm for test that it doesn't fire again.\n\n  test.equal(coll.find({\n    a: 1,\n    b: 2\n  }).count(), 1);\n  o.expectCallbacks({\n    changed: 1\n  }); // call method.\n\n  var methodCallbackFired = false;\n  conn.call('do_something', function () {\n    methodCallbackFired = true;\n  });\n  conn.apply('do_something_else', [], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something_later', [], _.identity);\n  test.isFalse(methodCallbackFired); // The non-wait method should send, but not the wait method.\n\n  var methodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(methodMessage.randomSeed);\n  test.equal(methodMessage, {\n    msg: 'method',\n    method: 'do_something',\n    params: [],\n    id: methodMessage.id\n  });\n  test.equal(stream.sent.length, 0); // more data. shows up immediately because there was no relevant method stub.\n\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: '1234',\n    fields: {\n      c: 3\n    }\n  });\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3\n  });\n  o.expectCallbacks({\n    changed: 1\n  }); // stream reset. reconnect!  we send a connect, our pending method, and our\n  // sub. The wait method still is blocked.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, methodMessage);\n  testGotMessage(test, stream, subMessage); // reconnect with different session id\n\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID + 1\n  }); // resend data. doesn't show up: we're in reconnect quiescence.\n\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '1234',\n    fields: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4\n    }\n  });\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '2345',\n    fields: {\n      e: 5\n    }\n  });\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3\n  });\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks(); // satisfy and return the method\n\n  stream.receive({\n    msg: 'updated',\n    methods: [methodMessage.id]\n  });\n  test.isFalse(methodCallbackFired);\n  stream.receive({\n    msg: 'result',\n    id: methodMessage.id,\n    result: \"bupkis\"\n  }); // The callback still doesn't fire (and we don't send the wait method): we're\n  // still in global quiescence\n\n  test.isFalse(methodCallbackFired);\n  test.equal(stream.sent.length, 0); // still no update.\n\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3\n  });\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks(); // re-satisfy sub\n\n  stream.receive({\n    msg: 'ready',\n    subs: [subMessage.id]\n  }); // now the doc changes and method callback is called, and the wait method is\n  // sent. the sub callback isn't re-called.\n\n  test.isTrue(methodCallbackFired);\n  test.isFalse(subCallbackFired);\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4\n  });\n  test.equal(coll.findOne('2345'), {\n    _id: '2345',\n    e: 5\n  });\n  o.expectCallbacks({\n    added: 1,\n    changed: 1\n  });\n  var waitMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(waitMethodMessage.randomSeed);\n  test.equal(waitMethodMessage, {\n    msg: 'method',\n    method: 'do_something_else',\n    params: [],\n    id: waitMethodMessage.id\n  });\n  test.equal(stream.sent.length, 0);\n  stream.receive({\n    msg: 'result',\n    id: waitMethodMessage.id,\n    result: \"bupkis\"\n  });\n  test.equal(stream.sent.length, 0);\n  stream.receive({\n    msg: 'updated',\n    methods: [waitMethodMessage.id]\n  }); // wait method done means we can send the third method\n\n  test.equal(stream.sent.length, 1);\n  var laterMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(laterMethodMessage.randomSeed);\n  test.equal(laterMethodMessage, {\n    msg: 'method',\n    method: 'do_something_later',\n    params: [],\n    id: laterMethodMessage.id\n  });\n  o.stop();\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - reconnect non-idempotent method\", function (test) {\n    // This test is for https://github.com/meteor/meteor/issues/6108\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var firstMethodCallbackFired = false;\n    var firstMethodCallbackErrored = false;\n    var secondMethodCallbackFired = false;\n    var secondMethodCallbackErrored = false; // call with noRetry true so that the method should fail to retry on reconnect.\n\n    conn.apply('do_something', [], {\n      noRetry: true\n    }, function (error) {\n      firstMethodCallbackFired = true; // failure on reconnect should trigger an error.\n\n      if (error && error.error === 'invocation-failed') {\n        firstMethodCallbackErrored = true;\n      }\n    });\n    conn.apply('do_something_else', [], {\n      noRetry: true\n    }, function (error) {\n      secondMethodCallbackFired = true; // failure on reconnect should trigger an error.\n\n      if (error && error.error === 'invocation-failed') {\n        secondMethodCallbackErrored = true;\n      }\n    }); // The method has not succeeded yet\n\n    test.isFalse(firstMethodCallbackFired);\n    test.isFalse(secondMethodCallbackFired); // send the methods\n\n    stream.sent.shift();\n    stream.sent.shift(); // reconnect\n\n    stream.reset(); // verify that a reconnect message was sent.\n\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID)); // Make sure that the stream triggers connection.\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 1\n    }); //The method callback should fire even though the stream has not sent a response.\n    //the callback should have been fired with an error.\n\n    test.isTrue(firstMethodCallbackFired);\n    test.isTrue(firstMethodCallbackErrored);\n    test.isTrue(secondMethodCallbackFired);\n    test.isTrue(secondMethodCallbackErrored); // verify that the method message was not sent.\n\n    test.isUndefined(stream.sent.shift());\n  });\n}\n\nfunction addReconnectTests(name, testFunc) {\n  Tinytest.add(name + \" (deprecated)\", function (test) {\n    function deprecatedSetOnReconnect(conn, handler) {\n      conn.onReconnect = handler;\n    }\n\n    testFunc.call(this, test, deprecatedSetOnReconnect);\n  });\n  Tinytest.add(name, function (test) {\n    var stopper;\n\n    function setOnReconnect(conn, handler) {\n      stopper && stopper.stop();\n      stopper = DDP.onReconnect(function (reconnectingConn) {\n        if (reconnectingConn === conn) {\n          handler();\n        }\n      });\n    }\n\n    testFunc.call(this, test, setOnReconnect);\n    stopper && stopper.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  addReconnectTests(\"livedata stub - reconnect method which only got result\", function (test, setOnReconnect) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    var o = observeCursor(test, coll.find());\n    conn.methods({\n      writeSomething: function () {\n        // stub write\n        coll.insert({\n          foo: 'bar'\n        });\n      }\n    });\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 0); // Call a method. We'll get the result but not data-done before reconnect.\n\n    var callbackOutput = [];\n    var onResultReceivedOutput = [];\n    conn.apply('writeSomething', [], {\n      onResultReceived: function (err, result) {\n        onResultReceivedOutput.push(result);\n      }\n    }, function (err, result) {\n      callbackOutput.push(result);\n    }); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId = coll.findOne({\n      foo: 'bar'\n    })._id;\n\n    o.expectCallbacks({\n      added: 1\n    }); // Callback not called.\n\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, []); // Method sent.\n\n    var methodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'writeSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Get some data.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        baz: 42\n      }\n    }); // It doesn't show up yet.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Get the result.\n\n    stream.receive({\n      msg: 'result',\n      id: methodId,\n      result: 'bla'\n    }); // Data unaffected.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Callback not called, but onResultReceived is.\n\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, ['bla']); // Reset stream. Method does NOT get resent, because its result is already\n    // in. Reconnect quiescence happens as soon as 'connected' is received because\n    // there are no pending methods or subs in need of revival.\n\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID)); // Still holding out hope for session resumption, so nothing updated yet.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, []); // Receive 'connected': time for reconnect quiescence! Data gets updated\n    // locally (ie, data is reset) and callback gets called.\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 1\n    });\n    test.equal(coll.find().count(), 0);\n    o.expectCallbacks({\n      removed: 1\n    });\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']);\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        baz: 42\n      }\n    });\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      baz: 42\n    });\n    o.expectCallbacks({\n      added: 1\n    }); // Run method again. We're going to do the same thing this time, except we're\n    // also going to use an onReconnect to insert another method at reconnect\n    // time, which will delay reconnect quiescence.\n\n    conn.apply('writeSomething', [], {\n      onResultReceived: function (err, result) {\n        onResultReceivedOutput.push(result);\n      }\n    }, function (err, result) {\n      callbackOutput.push(result);\n    }); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId2 = coll.findOne({\n      foo: 'bar'\n    })._id;\n\n    o.expectCallbacks({\n      added: 1\n    }); // Callback not called.\n\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']); // Method sent.\n\n    var methodId2 = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'writeSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Get some data.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId2),\n      fields: {\n        baz: 42\n      }\n    }); // It doesn't show up yet.\n\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Get the result.\n\n    stream.receive({\n      msg: 'result',\n      id: methodId2,\n      result: 'blab'\n    }); // Data unaffected.\n\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Callback not called, but onResultReceived is.\n\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla', 'blab']);\n    setOnReconnect(conn, function () {\n      conn.call('slowMethod', function (err, result) {\n        callbackOutput.push(result);\n      });\n    }); // Reset stream. Method does NOT get resent, because its result is already in,\n    // but slowMethod gets called via onReconnect. Reconnect quiescence is now\n    // blocking on slowMethod.\n\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID + 1));\n    var slowMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'slowMethod',\n      params: [],\n      id: '*'\n    }).id; // Still holding out hope for session resumption, so nothing updated yet.\n\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']); // Receive 'connected'... but no reconnect quiescence yet due to slowMethod.\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 2\n    });\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']); // Receive data matching our stub. It doesn't take effect yet.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId2),\n      fields: {\n        foo: 'bar'\n      }\n    });\n    o.expectCallbacks(); // slowMethod is done writing, so we get full reconnect quiescence (but no\n    // slowMethod callback)... ie, a reset followed by applying the data we just\n    // got, as well as calling the callback from the method that half-finished\n    // before reset. The net effect is deleting doc 'stubWrittenId'.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [slowMethodId]\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks({\n      removed: 1\n    });\n    test.equal(callbackOutput, ['bla', 'blab']); // slowMethod returns a value now.\n\n    stream.receive({\n      msg: 'result',\n      id: slowMethodId,\n      result: 'slow'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla', 'blab', 'slow']);\n    o.stop();\n  });\n}\n\nTinytest.add(\"livedata stub - reconnect method which only got data\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {\n    connection: conn\n  });\n  var o = observeCursor(test, coll.find()); // Call a method. We'll get the data-done message but not the result before\n  // reconnect.\n\n  var callbackOutput = [];\n  var onResultReceivedOutput = [];\n  conn.apply('doLittle', [], {\n    onResultReceived: function (err, result) {\n      onResultReceivedOutput.push(result);\n    }\n  }, function (err, result) {\n    callbackOutput.push(result);\n  }); // Callbacks not called.\n\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Method sent.\n\n  var methodId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'doLittle',\n    params: [],\n    id: '*'\n  }).id;\n  test.equal(stream.sent.length, 0); // Get some data.\n\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: 'photo',\n    fields: {\n      baz: 42\n    }\n  }); // It shows up instantly because the stub didn't write anything.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks({\n    added: 1\n  }); // Get the data-done message.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [methodId]\n  }); // Data still here.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks(); // Method callback not called yet (no result yet).\n\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Reset stream. Method gets resent (with same ID), and blocks reconnect\n  // quiescence.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'doLittle',\n    params: [],\n    id: methodId\n  }); // Still holding out hope for session resumption, so nothing updated yet.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Receive 'connected'. Still blocking on reconnect quiescence.\n\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID + 1\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Receive method result. onResultReceived is called but the main callback\n  // isn't (ie, we don't get confused by the fact that we got data-done the\n  // *FIRST* time through).\n\n  stream.receive({\n    msg: 'result',\n    id: methodId,\n    result: 'res'\n  });\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, ['res']); // Now we get data-done. Collection is reset and callback is called.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [methodId]\n  });\n  test.equal(coll.find().count(), 0);\n  o.expectCallbacks({\n    removed: 1\n  });\n  test.equal(callbackOutput, ['res']);\n  test.equal(onResultReceivedOutput, ['res']);\n  o.stop();\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - multiple stubs same doc\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    var o = observeCursor(test, coll.find());\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({\n          foo: 'bar'\n        });\n      },\n      updateIt: function (id) {\n        coll.update(id, {\n          $set: {\n            baz: 42\n          }\n        });\n      }\n    });\n    test.equal(coll.find().count(), 0); // Call the insert method.\n\n    conn.call('insertSomething', _.identity); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId = coll.findOne({\n      foo: 'bar'\n    })._id;\n\n    o.expectCallbacks({\n      added: 1\n    }); // Method sent.\n\n    var insertMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'insertSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Call update method.\n\n    conn.call('updateIt', stubWrittenId, _.identity); // This stub write is visible too.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks({\n      changed: 1\n    }); // Method sent.\n\n    var updateMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'updateIt',\n      params: [stubWrittenId],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Get some data... slightly different than what we wrote.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        foo: 'barb',\n        other: 'field',\n        other2: 'bla'\n      }\n    }); // It doesn't show up yet.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks(); // And get the first method-done. Still no updates to minimongo: we can't\n    // quiesce the doc until the second method is done.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [insertMethodId]\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks(); // More data. Not quite what we wrote. Also ignored for now.\n\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        baz: 43\n      },\n      cleared: ['other']\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks(); // Second data-ready. Now everything takes effect!\n\n    stream.receive({\n      msg: 'updated',\n      methods: [updateMethodId]\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'barb',\n      other2: 'bla',\n      baz: 43\n    });\n    o.expectCallbacks({\n      changed: 1\n    });\n    o.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - unsent methods don't block quiescence\", function (test) {\n    // This test is for https://github.com/meteor/meteor/issues/555\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({\n          foo: 'bar'\n        });\n      }\n    });\n    test.equal(coll.find().count(), 0); // Call a random method (no-op)\n\n    conn.call('no-op', _.identity); // Call a wait method\n\n    conn.apply('no-op', [], {\n      wait: true\n    }, _.identity); // Call a method with a stub that writes.\n\n    conn.call('insertSomething', _.identity); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId = coll.findOne({\n      foo: 'bar'\n    })._id; // first method sent\n\n\n    var firstMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'no-op',\n      params: [],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // ack the first method\n\n    stream.receive({\n      msg: 'updated',\n      methods: [firstMethodId]\n    });\n    stream.receive({\n      msg: 'result',\n      id: firstMethodId\n    }); // Wait method sent.\n\n    var waitMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'no-op',\n      params: [],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // ack the wait method\n\n    stream.receive({\n      msg: 'updated',\n      methods: [waitMethodId]\n    });\n    stream.receive({\n      msg: 'result',\n      id: waitMethodId\n    }); // insert method sent.\n\n    var insertMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'insertSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // ack the insert method\n\n    stream.receive({\n      msg: 'updated',\n      methods: [insertMethodId]\n    });\n    stream.receive({\n      msg: 'result',\n      id: insertMethodId\n    }); // simulation reverted.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 0);\n  });\n}\n\nTinytest.add(\"livedata stub - reactive resub\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var readiedSubs = {};\n\n  var markAllReady = function () {\n    // synthesize a \"ready\" message in response to any \"sub\"\n    // message with an id we haven't seen before\n    _.each(stream.sent, function (msg) {\n      msg = JSON.parse(msg);\n\n      if (msg.msg === 'sub' && !_.has(readiedSubs, msg.id)) {\n        stream.receive({\n          msg: 'ready',\n          subs: [msg.id]\n        });\n        readiedSubs[msg.id] = true;\n      }\n    });\n  };\n\n  var fooArg = new ReactiveVar('A');\n  var fooReady = 0;\n  var inner;\n  var outer = Tracker.autorun(function () {\n    inner = Tracker.autorun(function () {\n      conn.subscribe(\"foo-sub\", fooArg.get(), function () {\n        fooReady++;\n      });\n    });\n  });\n  markAllReady();\n  var message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo-sub',\n    params: ['A']\n  });\n  test.equal(fooReady, 1); // Rerun the inner autorun with different subscription\n  // arguments.\n\n  fooArg.set('B');\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo-sub',\n    params: ['B']\n  });\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'unsub'\n  });\n  test.equal(fooReady, 2); // Rerun inner again with same args; should be no re-sub.\n\n  inner.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 3); // Rerun outer!  Should still be no re-sub even though\n  // the inner computation is stopped and a new one is\n  // started.\n\n  outer.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 4); // Change the subscription.  Now we should get an onReady.\n\n  fooArg.set('C');\n  Tracker.flush();\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo-sub',\n    params: ['C']\n  });\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'unsub'\n  });\n  test.equal(fooReady, 5);\n});\nTinytest.add(\"livedata connection - reactive userId\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  test.equal(conn.userId(), null);\n  conn.setUserId(1337);\n  test.equal(conn.userId(), 1337);\n});\nTinytest.add(\"livedata connection - two wait methods\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {\n    connection: conn\n  }); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  var responses = [];\n  conn.apply('do_something', ['one!'], function () {\n    responses.push('one');\n  });\n  var one_message = JSON.parse(stream.sent.shift());\n  test.equal(one_message.params, ['one!']);\n  conn.apply('do_something', ['two!'], {\n    wait: true\n  }, function () {\n    responses.push('two');\n  }); // 'two!' isn't sent yet, because it's a wait method.\n\n  test.equal(stream.sent.length, 0);\n  conn.apply('do_something', ['three!'], function () {\n    responses.push('three');\n  });\n  conn.apply('do_something', ['four!'], function () {\n    responses.push('four');\n  });\n  conn.apply('do_something', ['five!'], {\n    wait: true\n  }, function () {\n    responses.push('five');\n  });\n  conn.apply('do_something', ['six!'], function () {\n    responses.push('six');\n  }); // Verify that we did not send any more methods since we are still waiting on\n  // 'one!'.\n\n  test.equal(stream.sent.length, 0); // Receive some data. \"one\" is not a wait method and there are no stubs, so it\n  // gets applied immediately.\n\n  test.equal(coll.find().count(), 0);\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: 'foo',\n    fields: {\n      x: 1\n    }\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {\n    _id: 'foo',\n    x: 1\n  }); // Let \"one!\" finish. Both messages are required to fire the callback.\n\n  stream.receive({\n    msg: 'result',\n    id: one_message.id\n  });\n  test.equal(responses, []);\n  stream.receive({\n    msg: 'updated',\n    methods: [one_message.id]\n  });\n  test.equal(responses, ['one']); // Now we've send out \"two!\".\n\n  var two_message = JSON.parse(stream.sent.shift());\n  test.equal(two_message.params, ['two!']); // But still haven't sent \"three!\".\n\n  test.equal(stream.sent.length, 0); // Receive more data. \"two\" is a wait method, so the data doesn't get applied\n  // yet.\n\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: 'foo',\n    fields: {\n      y: 3\n    }\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {\n    _id: 'foo',\n    x: 1\n  }); // Let \"two!\" finish, with its end messages in the opposite order to \"one!\".\n\n  stream.receive({\n    msg: 'updated',\n    methods: [two_message.id]\n  });\n  test.equal(responses, ['one']);\n  test.equal(stream.sent.length, 0); // data-done message is enough to allow data to be written.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {\n    _id: 'foo',\n    x: 1,\n    y: 3\n  });\n  stream.receive({\n    msg: 'result',\n    id: two_message.id\n  });\n  test.equal(responses, ['one', 'two']); // Verify that we just sent \"three!\" and \"four!\" now that we got\n  // responses for \"one!\" and \"two!\"\n\n  test.equal(stream.sent.length, 2);\n  var three_message = JSON.parse(stream.sent.shift());\n  test.equal(three_message.params, ['three!']);\n  var four_message = JSON.parse(stream.sent.shift());\n  test.equal(four_message.params, ['four!']); // Out of order response is OK for non-wait methods.\n\n  stream.receive({\n    msg: 'result',\n    id: three_message.id\n  });\n  stream.receive({\n    msg: 'result',\n    id: four_message.id\n  });\n  stream.receive({\n    msg: 'updated',\n    methods: [four_message.id]\n  });\n  test.equal(responses, ['one', 'two', 'four']);\n  test.equal(stream.sent.length, 0); // Let three finish too.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [three_message.id]\n  });\n  test.equal(responses, ['one', 'two', 'four', 'three']); // Verify that we just sent \"five!\" (the next wait method).\n\n  test.equal(stream.sent.length, 1);\n  var five_message = JSON.parse(stream.sent.shift());\n  test.equal(five_message.params, ['five!']);\n  test.equal(responses, ['one', 'two', 'four', 'three']); // Let five finish.\n\n  stream.receive({\n    msg: 'result',\n    id: five_message.id\n  });\n  stream.receive({\n    msg: 'updated',\n    methods: [five_message.id]\n  });\n  test.equal(responses, ['one', 'two', 'four', 'three', 'five']);\n  var six_message = JSON.parse(stream.sent.shift());\n  test.equal(six_message.params, ['six!']);\n});\naddReconnectTests(\"livedata connection - onReconnect prepends messages correctly with a wait method\", function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  setOnReconnect(conn, function () {\n    conn.apply('do_something', ['reconnect zero'], _.identity);\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], {\n      wait: true\n    }, _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  });\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something', ['three'], _.identity); // reconnect\n\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId)); // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n\n  test.equal(_.map(stream.sent, function (msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect zero', 'reconnect one']); // white-box test:\n\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [[false, ['reconnect zero', 'reconnect one']], [true, ['reconnect two']], [false, ['reconnect three', 'one']], [true, ['two']], [false, ['three']]]);\n});\nTinytest.add(\"livedata connection - ping without id\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  stream.receive({\n    msg: 'ping'\n  });\n  testGotMessage(test, stream, {\n    msg: 'pong'\n  });\n});\nTinytest.add(\"livedata connection - ping with id\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var id = Random.id();\n  stream.receive({\n    msg: 'ping',\n    id: id\n  });\n  testGotMessage(test, stream, {\n    msg: 'pong',\n    id: id\n  });\n});\n\n_.each(LivedataTest.SUPPORTED_DDP_VERSIONS, function (version) {\n  Tinytest.addAsync(\"livedata connection - ping from \" + version, function (test, onComplete) {\n    var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n      reloadWithOutstanding: true,\n      supportedDDPVersions: [version],\n      onDDPVersionNegotiationFailure: function () {\n        test.fail();\n        onComplete();\n      },\n      onConnected: function () {\n        test.equal(connection._version, version); // It's a little naughty to access _stream and _send, but it works...\n\n        connection._stream.on('message', function (json) {\n          var msg = JSON.parse(json);\n          var done = false;\n\n          if (msg.msg === 'pong') {\n            test.notEqual(version, \"pre1\");\n            done = true;\n          } else if (msg.msg === 'error') {\n            // Version pre1 does not play ping-pong\n            test.equal(version, \"pre1\");\n            done = true;\n          } else {\n            Meteor._debug(\"Got unexpected message: \" + json);\n          }\n\n          if (done) {\n            connection._stream.disconnect({\n              _permanent: true\n            });\n\n            onComplete();\n          }\n        });\n\n        connection._send({\n          msg: 'ping'\n        });\n      }\n    });\n  });\n});\n\nvar getSelfConnectionUrl = function () {\n  if (Meteor.isClient) {\n    var ddpUrl = Meteor._relativeToSiteRootUrl(\"/\");\n\n    if (typeof __meteor_runtime_config__ !== \"undefined\") {\n      if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL) ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n    }\n\n    return ddpUrl;\n  } else {\n    return Meteor.absoluteUrl();\n  }\n};\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    reverse: function (arg) {\n      // Return something notably different from reverse.meteor.com.\n      return arg.split(\"\").reverse().join(\"\") + \" LOCAL\";\n    }\n  });\n}\n\ntestAsyncMulti(\"livedata connection - reconnect to a different server\", [function (test, expect) {\n  var self = this;\n  self.conn = DDP.connect(\"reverse.meteor.com\");\n  pollUntil(expect, function () {\n    return self.conn.status().connected;\n  }, 5000, 100, true); // poll until connected, but don't fail if we don't connect\n}, function (test, expect) {\n  var self = this;\n  self.doTest = self.conn.status().connected;\n\n  if (self.doTest) {\n    self.conn.call(\"reverse\", \"foo\", expect(function (err, res) {\n      test.equal(res, \"oof\");\n    }));\n  }\n}, function (test, expect) {\n  var self = this;\n\n  if (self.doTest) {\n    self.conn.reconnect({\n      url: getSelfConnectionUrl()\n    });\n    self.conn.call(\"reverse\", \"bar\", expect(function (err, res) {\n      test.equal(res, \"rab LOCAL\");\n    }));\n  }\n}]);\nTinytest.addAsync(\"livedata connection - version negotiation requires renegotiating\", function (test, onComplete) {\n  var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: [\"garbled\", LivedataTest.SUPPORTED_DDP_VERSIONS[0]],\n    onDDPVersionNegotiationFailure: function () {\n      test.fail();\n      onComplete();\n    },\n    onConnected: function () {\n      test.equal(connection._version, LivedataTest.SUPPORTED_DDP_VERSIONS[0]);\n\n      connection._stream.disconnect({\n        _permanent: true\n      });\n\n      onComplete();\n    }\n  });\n});\nTinytest.addAsync(\"livedata connection - version negotiation error\", function (test, onComplete) {\n  var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: [\"garbled\", \"more garbled\"],\n    onDDPVersionNegotiationFailure: function () {\n      test.equal(connection.status().status, \"failed\");\n      test.matches(connection.status().reason, /DDP version negotiation failed/);\n      test.isFalse(connection.status().connected);\n      onComplete();\n    },\n    onConnected: function () {\n      test.fail();\n      onComplete();\n    }\n  });\n});\naddReconnectTests(\"livedata connection - onReconnect prepends messages correctly without a wait method\", function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  setOnReconnect(conn, function () {\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  });\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something', ['three'], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something', ['four'], _.identity); // reconnect\n\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId)); // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n\n  test.equal(_.map(stream.sent, function (msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect one', 'reconnect two', 'reconnect three', 'one']); // white-box test:\n\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [[false, ['reconnect one', 'reconnect two', 'reconnect three', 'one']], [true, ['two']], [true, ['three']], [false, ['four']]]);\n});\naddReconnectTests(\"livedata connection - onReconnect with sent messages\", function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  setOnReconnect(conn, function () {\n    conn.apply('do_something', ['login'], {\n      wait: true\n    }, _.identity);\n  });\n  conn.apply('do_something', ['one'], _.identity); // initial connect\n\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId)); // Test that we sent just the login message.\n\n  var loginId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'do_something',\n    params: ['login'],\n    id: '*'\n  }).id; // we connect.\n\n  stream.receive({\n    msg: 'connected',\n    session: Random.id()\n  });\n  test.length(stream.sent, 0); // login got result (but not yet data)\n\n  stream.receive({\n    msg: 'result',\n    id: loginId,\n    result: 'foo'\n  });\n  test.length(stream.sent, 0); // login got data. now we send next method.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [loginId]\n  });\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'do_something',\n    params: ['one'],\n    id: '*'\n  }).id;\n});\naddReconnectTests(\"livedata stub - reconnect double wait method\", function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var output = [];\n  setOnReconnect(conn, function () {\n    conn.apply('reconnectMethod', [], {\n      wait: true\n    }, function (err, result) {\n      output.push('reconnect');\n    });\n  });\n  conn.apply('halfwayMethod', [], {\n    wait: true\n  }, function (err, result) {\n    output.push('halfway');\n  });\n  test.equal(output, []); // Method sent.\n\n  var halfwayId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'halfwayMethod',\n    params: [],\n    id: '*'\n  }).id;\n  test.equal(stream.sent.length, 0); // Get the result. This means it will not be resent.\n\n  stream.receive({\n    msg: 'result',\n    id: halfwayId,\n    result: 'bla'\n  }); // Callback not called.\n\n  test.equal(output, []); // Reset stream. halfwayMethod does NOT get resent, but reconnectMethod does!\n  // Reconnect quiescence happens when reconnectMethod is done.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  var reconnectId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'reconnectMethod',\n    params: [],\n    id: '*'\n  }).id;\n  test.length(stream.sent, 0); // Still holding out hope for session resumption, so no callbacks yet.\n\n  test.equal(output, []); // Receive 'connected', but reconnect quiescence is blocking on\n  // reconnectMethod.\n\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID + 1\n  });\n  test.equal(output, []); // Data-done for reconnectMethod. This gets us to reconnect quiescence, so\n  // halfwayMethod's callback fires. reconnectMethod's is still waiting on its\n  // result.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [reconnectId]\n  });\n  test.equal(output.shift(), 'halfway');\n  test.equal(output, []); // Get result of reconnectMethod. Its callback fires.\n\n  stream.receive({\n    msg: 'result',\n    id: reconnectId,\n    result: 'foo'\n  });\n  test.equal(output.shift(), 'reconnect');\n  test.equal(output, []); // Call another method. It should be delivered immediately. This is a\n  // regression test for a case where it never got delivered because there was\n  // an empty block in _outstandingMethodBlocks blocking it from being sent.\n\n  conn.call('lastMethod', _.identity);\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'lastMethod',\n    params: [],\n    id: '*'\n  });\n});\nTinytest.add(\"livedata stub - subscribe errors\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // subscribe\n\n  var onReadyFired = false;\n  var subErrorInStopped = null;\n  var subErrorInError = null;\n  conn.subscribe('unknownSub', {\n    onReady: function () {\n      onReadyFired = true;\n    },\n    // We now have two ways to get the error from a subscription:\n    // 1. onStop, which is called no matter what when the subscription is\n    //    stopped (a lifecycle callback)\n    // 2. onError, which is deprecated and is called only if there is an\n    //    error\n    onStop: function (error) {\n      subErrorInStopped = error;\n    },\n    onError: function (error) {\n      subErrorInError = error;\n    }\n  });\n  test.isFalse(onReadyFired);\n  test.equal(subErrorInStopped, null); // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n  test.equal(subErrorInError, null);\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {\n    msg: 'sub',\n    name: 'unknownSub',\n    params: [],\n    id: subMessage.id\n  }); // Reject the sub.\n\n  stream.receive({\n    msg: 'nosub',\n    id: subMessage.id,\n    error: new Meteor.Error(404, \"Subscription not found\")\n  });\n  test.isFalse(onReadyFired); // Check the error passed to the stopped callback was correct\n\n  test.instanceOf(subErrorInStopped, Meteor.Error);\n  test.equal(subErrorInStopped.error, 404);\n  test.equal(subErrorInStopped.reason, \"Subscription not found\"); // Check the error passed to the error callback was correct\n  // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n  test.instanceOf(subErrorInError, Meteor.Error);\n  test.equal(subErrorInError.error, 404);\n  test.equal(subErrorInError.reason, \"Subscription not found\"); // stream reset: reconnect!\n\n  stream.reset(); // We send a connect.\n\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID)); // We should NOT re-sub to the sub, because we processed the error.\n\n  test.length(stream.sent, 0);\n  test.isFalse(onReadyFired);\n});\nTinytest.add(\"livedata stub - subscribe stop\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // subscribe\n\n  var onReadyFired = false;\n  var onStopFired = false;\n  var subErrorInStopped = null;\n  var sub = conn.subscribe('my_data', {\n    onStop: function (error) {\n      onStopFired = true;\n      subErrorInStopped = error;\n    }\n  });\n  test.equal(subErrorInStopped, null);\n  sub.stop();\n  test.isTrue(onStopFired);\n  test.equal(subErrorInStopped, undefined);\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - stubs before connected\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    }); // Start and send \"connect\", but DON'T get 'connected' quite yet.\n\n    stream.reset(); // initial connection start.\n\n    testGotMessage(test, stream, makeConnectMessage());\n    test.length(stream.sent, 0); // Insert a document. The stub updates \"conn\" directly.\n\n    coll.insert({\n      _id: \"foo\",\n      bar: 42\n    }, _.identity);\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(), {\n      _id: \"foo\",\n      bar: 42\n    }); // It also sends the method message.\n\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.isUndefined(methodMessage.randomSeed);\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: '/' + collName + '/insert',\n      params: [{\n        _id: \"foo\",\n        bar: 42\n      }],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0); // Now receive a connected message. This should not clear the\n    // _documentsWrittenByStub state!\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID\n    });\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 1); // Now receive the \"updated\" message for the method. This should revert the\n    // insert.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [methodMessage.id]\n    });\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 0);\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - method call between reset and quiescence\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    conn.methods({\n      update_value: function () {\n        coll.update('aaa', {\n          value: 222\n        });\n      }\n    }); // Set up test subscription.\n\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {\n      msg: 'sub',\n      name: 'test_data',\n      params: [],\n      id: subMessage.id\n    });\n    test.length(stream.sent, 0);\n    var subDocMessage = {\n      msg: 'added',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        value: 111\n      }\n    };\n    var subReadyMessage = {\n      msg: 'ready',\n      'subs': [subMessage.id]\n    };\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.isTrue(coll.findOne('aaa').value == 111); // Initiate reconnect.\n\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    testGotMessage(test, stream, subMessage);\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 1\n    }); // Now in reconnect, can still see the document.\n\n    test.isTrue(coll.findOne('aaa').value == 111);\n    conn.call('update_value'); // Observe the stub-written value.\n\n    test.isTrue(coll.findOne('aaa').value == 222);\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: 'update_value',\n      params: [],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0);\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage); // By this point quiescence is reached and stores have been reset.\n    // The stub-written value is still there.\n\n    test.isTrue(coll.findOne('aaa').value == 222);\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        value: 333\n      }\n    });\n    stream.receive({\n      msg: 'updated',\n      'methods': [methodMessage.id]\n    });\n    stream.receive({\n      msg: 'result',\n      id: methodMessage.id,\n      result: null\n    }); // Server wrote a different value, make sure it's visible now.\n\n    test.isTrue(coll.findOne('aaa').value == 333);\n  });\n  Tinytest.add(\"livedata stub - buffering and methods interaction\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream, {\n      // A very high values so that all messages are effectively buffered.\n      bufferedWritesInterval: 10000,\n      bufferedWritesMaxAge: 10000\n    });\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    conn.methods({\n      update_value: function () {\n        var value = coll.findOne('aaa').subscription; // Method should have access to the latest value of the collection.\n\n        coll.update('aaa', {\n          $set: {\n            method: value + 110\n          }\n        });\n      }\n    }); // Set up test subscription.\n\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {\n      msg: 'sub',\n      name: 'test_data',\n      params: [],\n      id: subMessage.id\n    });\n    test.length(stream.sent, 0);\n    var subDocMessage = {\n      msg: 'added',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        subscription: 111\n      }\n    };\n    var subReadyMessage = {\n      msg: 'ready',\n      'subs': [subMessage.id]\n    };\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.equal(coll.findOne('aaa').subscription, 111);\n    var subDocChangeMessage = {\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        subscription: 112\n      }\n    };\n    stream.receive(subDocChangeMessage); // Still 111 because buffer has not been flushed.\n\n    test.equal(coll.findOne('aaa').subscription, 111); // Call updates the stub.\n\n    conn.call('update_value'); // Observe the stub-written value.\n\n    test.equal(coll.findOne('aaa').method, 222); // subscription field is updated to the latest value\n    // because of the method call.\n\n    test.equal(coll.findOne('aaa').subscription, 112);\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: 'update_value',\n      params: [],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0); // \"Server-side\" change from the method arrives and method returns.\n    // With potentially fixed value for method field, if stub didn't\n    // use 112 as the subscription field value.\n\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        method: 222\n      }\n    });\n    stream.receive({\n      msg: 'updated',\n      'methods': [methodMessage.id]\n    });\n    stream.receive({\n      msg: 'result',\n      id: methodMessage.id,\n      result: null\n    });\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112); // Buffer should already be flushed because of a non-update message.\n    // And after a flush we really want subscription field to be 112.\n\n    conn._flushBufferedWrites();\n\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112);\n  });\n} // XXX also test:\n// - reconnect, with session resume.\n// - restart on update flag\n// - on_update event\n// - reloading when the app changes, including session migration","map":{"version":3,"sources":["packages/ddp-client/livedata_connection_tests.js"],"names":["lolex","module","watch","require","v","DDP","LivedataTest","newConnection","stream","options","Connection","_","extend","reloadWithOutstanding","bufferedWritesInterval","makeConnectMessage","session","msg","version","SUPPORTED_DDP_VERSIONS","support","testGotMessage","test","expected","sent","length","fail","error","undefined","got","shift","JSON","parse","keysWithStarValues","each","k","push","equal","startAndConnect","reset","receive","SESSION_ID","Tinytest","add","StubStream","conn","coll_name","Random","id","collection","fields","a","_updatesForUnknownStores","coll","Mongo","Collection","isUndefined","find","fetch","_id","clock","install","tick","timeout","bufferedWritesMaxAge","testDocCount","count","addDoc","uninstall","callback_fired","sub","subscribe","isFalse","message","name","params","reactivelyReady","autorunHandle","Tracker","autorun","ready","isTrue","flush","stop","id2","notEqual","rFoo","ReactiveVar","rBar","onReadyCount","onReady","tag","has","stopperHandle","completerHandle","get","completerReady","readyAutorunHandle","idFoo1","idBar1","idCompleter","idStopper","completer","set","idFoo2","idStopperAgain","bar1","stopper","unsubMessages","map","unique","pluck","actualIds","expectedIds","sort","fooHandle","fooReady","idFoo3","methods","test_this","isSimulation","unblock","call","identity","randomSeed","method","result","Meteor","isClient","collName","connection","do_something","x","insert","value","counts","added","removed","changed","moved","handle","observe","addedAt","removedAt","changedAt","movedTo","callback1Fired","err","res","docId","findOne","MongoID","idStringify","callback2Fired","message2","mutateArgs","arg","foo","observeCursor","cursor","expectedCounts","clone","bind","expectCallbacks","delta","mod","field","do_something_else","o","newDoc","callbackOutput","subCallbackFired","subMessage","b","subs","methodCallbackFired","apply","wait","methodMessage","c","d","e","waitMethodMessage","laterMethodMessage","firstMethodCallbackFired","firstMethodCallbackErrored","secondMethodCallbackFired","secondMethodCallbackErrored","noRetry","addReconnectTests","testFunc","deprecatedSetOnReconnect","handler","onReconnect","setOnReconnect","reconnectingConn","writeSomething","onResultReceivedOutput","onResultReceived","stubWrittenId","methodId","baz","stubWrittenId2","methodId2","slowMethodId","insertSomething","updateIt","update","$set","insertMethodId","updateMethodId","other","other2","cleared","firstMethodId","waitMethodId","readiedSubs","markAllReady","fooArg","inner","outer","invalidated","invalidate","userId","setUserId","responses","one_message","two_message","y","three_message","four_message","five_message","six_message","_lastSessionId","_outstandingMethodBlocks","block","_message","addAsync","onComplete","getSelfConnectionUrl","supportedDDPVersions","onDDPVersionNegotiationFailure","onConnected","_version","_stream","on","json","done","_debug","disconnect","_permanent","_send","ddpUrl","_relativeToSiteRootUrl","__meteor_runtime_config__","DDP_DEFAULT_CONNECTION_URL","absoluteUrl","isServer","reverse","split","join","testAsyncMulti","expect","self","connect","pollUntil","status","connected","doTest","reconnect","url","matches","reason","loginId","output","halfwayId","reconnectId","onReadyFired","subErrorInStopped","subErrorInError","onStop","onError","Error","instanceOf","onStopFired","bar","update_value","subDocMessage","subReadyMessage","subscription","subDocChangeMessage","_flushBufferedWrites"],"mappings":"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","file":"packages/ddp-client/livedata_connection_tests.js.map","sourcesContent":["import lolex from 'lolex';\nimport { DDP, LivedataTest } from \"./namespace.js\";\n\nvar newConnection = function (stream, options) {\n  // Some of these tests leave outstanding methods with no result yet\n  // returned. This should not block us from re-running tests when sources\n  // change.\n  return new LivedataTest.Connection(stream, _.extend({\n    reloadWithOutstanding: true,\n    bufferedWritesInterval: 0\n  }, options));\n};\n\nvar makeConnectMessage = function (session) {\n  var msg = {\n    msg: 'connect',\n    version: LivedataTest.SUPPORTED_DDP_VERSIONS[0],\n    support: LivedataTest.SUPPORTED_DDP_VERSIONS\n  };\n\n  if (session)\n    msg.session = session;\n  return msg;\n};\n\n// Tests that stream got a message that matches expected.\n// Expected is normally an object, and allows a wildcard value of '*',\n// which will then match any value.\n// Returns the message (parsed as a JSON object if expected is an object);\n// which is particularly handy if you want to extract a value that was\n// matched as a wildcard.\nvar testGotMessage = function (test, stream, expected) {\n  if (stream.sent.length === 0) {\n    test.fail({error: 'no message received', expected: expected});\n    return undefined;\n  }\n\n  var got = stream.sent.shift();\n\n  if (typeof got === 'string' && typeof expected === 'object')\n    got = JSON.parse(got);\n\n  // An expected value of '*' matches any value, and the matching value (or\n  // array of matching values, if there are multiple) is returned from this\n  // function.\n  if (typeof expected === 'object') {\n    var keysWithStarValues = [];\n    _.each(expected, function (v, k) {\n      if (v === '*')\n        keysWithStarValues.push(k);\n    });\n    _.each(keysWithStarValues, function (k) {\n      expected[k] = got[k];\n    });\n  }\n\n  test.equal(got, expected);\n  return got;\n};\n\nvar startAndConnect = function(test, stream) {\n  stream.reset(); // initial connection start.\n\n  testGotMessage(test, stream, makeConnectMessage());\n  test.length(stream.sent, 0);\n\n  stream.receive({msg: 'connected', session: SESSION_ID});\n  test.length(stream.sent, 0);\n};\n\nvar SESSION_ID = '17';\n\nTinytest.add(\"livedata stub - receive data\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // data comes in for unknown collection.\n  var coll_name = Random.id();\n  stream.receive({msg: 'added', collection: coll_name, id: '1234',\n                  fields: {a: 1}});\n  // break throught the black box and test internal state\n  test.length(conn._updatesForUnknownStores[coll_name], 1);\n\n  // XXX: Test that the old signature of passing manager directly instead of in\n  // options works.\n  var coll = new Mongo.Collection(coll_name, conn);\n\n  // queue has been emptied and doc is in db.\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n  test.equal(coll.find({}).fetch(), [{_id:'1234', a:1}]);\n\n  // second message. applied directly to the db.\n  stream.receive({msg: 'changed', collection: coll_name, id: '1234',\n                  fields: {a:2}});\n  test.equal(coll.find({}).fetch(), [{_id:'1234', a:2}]);\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n});\n\nTinytest.add(\"livedata stub - buffering data\", function (test) {\n  // Install special setTimeout that allows tick-by-tick control in tests using sinonjs 'lolex'\n  // This needs to be before the connection is instantiated.\n  const clock = lolex.install();\n  const tick = (timeout) => clock.tick(timeout);\n\n  const stream = new StubStream();\n  const conn = newConnection(stream, {\n    bufferedWritesInterval: 10,\n    bufferedWritesMaxAge: 40,\n  });\n\n  startAndConnect(test, stream);\n\n  const coll_name = Random.id();\n  const coll = new Mongo.Collection(coll_name, conn);\n\n  const testDocCount = (count) => test.equal(coll.find({}).count(), count);\n\n  const addDoc = () => {\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: Random.id(),\n      fields: {}\n    });\n  };\n\n  // Starting at 0 ticks.  At this point we haven't advanced the fake clock at all.\n\n  addDoc(); // 1st Doc\n  testDocCount(0);  // No doc been recognized yet because it's buffered, waiting for more.\n  tick(6); // 6 total ticks\n  testDocCount(0); // Ensure that the doc still hasn't shown up, despite the clock moving forward.\n  tick(4) // 10 total ticks, 1st buffer interval\n  testDocCount(1); // No other docs have arrived, so we 'see' the 1st doc.\n\n  addDoc(); // 2nd doc\n  tick(1); // 11 total ticks (1 since last flush)\n  testDocCount(1); // Again, second doc hasn't arrived because we're waiting for more...\n  tick(9); // 20 total ticks (10 ticks since last flush & the 2nd 10-tick interval)\n  testDocCount(2); // Now we're here and got the second document.\n\n  // Add several docs, frequently enough that we buffer multiple times before the next flush.\n  addDoc(); // 3 docs\n  tick(6); // 26 ticks (6 since last flush)\n  addDoc(); // 4 docs\n  tick(6); // 32 ticks (12 since last flush)\n  addDoc(); // 5 docs\n  tick(6); // 38 ticks (18 since last flush)\n  addDoc(); // 6 docs\n  tick(6); // 44 ticks (24 since last flush)\n  addDoc(); // 7 docs\n  tick(9); // 53 ticks (33 since last flush)\n  addDoc(); // 8 docs\n  tick(9); // 62 ticks! (42 ticks since last flush, over max-age - next interval triggers flush)\n  testDocCount(2); // Still at 2 from before! (Just making sure)\n  tick(1); // Ok, 63 ticks (10 since last doc, so this should cause the flush of all the docs)\n  testDocCount(8); // See all the docs.\n\n  // Put things back how they were.\n  clock.uninstall();\n});\n\nTinytest.add(\"livedata stub - subscribe\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var callback_fired = false;\n  var sub = conn.subscribe('my_data', function () {\n    callback_fired = true;\n  });\n  test.isFalse(callback_fired);\n\n  test.length(stream.sent, 1);\n  var message = JSON.parse(stream.sent.shift());\n  var id = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'my_data', params: []});\n\n  var reactivelyReady = false;\n  var autorunHandle = Tracker.autorun(function () {\n    reactivelyReady = sub.ready();\n  });\n  test.isFalse(reactivelyReady);\n\n  // get the sub satisfied. callback fires.\n  stream.receive({msg: 'ready', 'subs': [id]});\n  test.isTrue(callback_fired);\n  Tracker.flush();\n  test.isTrue(reactivelyReady);\n\n  // Unsubscribe.\n  sub.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: id});\n  Tracker.flush();\n  test.isFalse(reactivelyReady);\n\n  // Resubscribe.\n  conn.subscribe('my_data');\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  var id2 = message.id;\n  test.notEqual(id, id2);\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'my_data', params: []});\n});\n\n\nTinytest.add(\"livedata stub - reactive subscribe\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var rFoo = new ReactiveVar('foo1');\n  var rBar = new ReactiveVar('bar1');\n\n  var onReadyCount = {};\n  var onReady = function (tag) {\n    return function () {\n      if (_.has(onReadyCount, tag))\n        ++onReadyCount[tag];\n      else\n        onReadyCount[tag] = 1;\n    };\n  };\n\n  // Subscribe to some subs.\n  var stopperHandle, completerHandle;\n  var autorunHandle = Tracker.autorun(function () {\n    conn.subscribe(\"foo\", rFoo.get(), onReady(rFoo.get()));\n    conn.subscribe(\"bar\", rBar.get(), onReady(rBar.get()));\n    completerHandle = conn.subscribe(\"completer\", onReady(\"completer\"));\n    stopperHandle = conn.subscribe(\"stopper\", onReady(\"stopper\"));\n  });\n\n  var completerReady;\n  var readyAutorunHandle = Tracker.autorun(function() {\n    completerReady = completerHandle.ready();\n  });\n\n  // Check sub messages. (Assume they are sent in the order executed.)\n  test.length(stream.sent, 4);\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo1']});\n\n  message = JSON.parse(stream.sent.shift());\n  var idBar1 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'bar', params: ['bar1']});\n\n  message = JSON.parse(stream.sent.shift());\n  var idCompleter = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'completer', params: []});\n\n  message = JSON.parse(stream.sent.shift());\n  var idStopper = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'stopper', params: []});\n\n  // Haven't hit onReady yet.\n  test.equal(onReadyCount, {});\n  Tracker.flush();\n  test.isFalse(completerReady);\n\n  // \"completer\" gets ready now. its callback should fire.\n  stream.receive({msg: 'ready', 'subs': [idCompleter]});\n  test.equal(onReadyCount, {completer: 1});\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(completerReady);\n\n  // Stop 'stopper'.\n  stopperHandle.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: idStopper});\n\n  test.equal(onReadyCount, {completer: 1});\n  Tracker.flush();\n  test.isTrue(completerReady);\n\n  // Change the foo subscription and flush. We should sub to the new foo\n  // subscription, re-sub to the stopper subscription, and then unsub from the old\n  // foo subscription. The bar subscription should be unaffected. The completer\n  // subscription should call its new onReady callback, because we always\n  // call onReady for a given reactively-saved subscription.\n  // The completerHandle should have been reestablished to the ready handle.\n  rFoo.set(\"foo2\");\n  Tracker.flush();\n  test.length(stream.sent, 3);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo2']});\n\n  message = JSON.parse(stream.sent.shift());\n  var idStopperAgain = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'stopper', params: []});\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: idFoo1});\n\n  test.equal(onReadyCount, {completer: 2});\n  test.isTrue(completerReady);\n\n  // Ready the stopper and bar subs. Completing stopper should call only the\n  // onReady from the new subscription because they were separate subscriptions\n  // started at different times and the first one was explicitly torn down by\n  // the client; completing bar should call the onReady from the new\n  // subscription because we always call onReady for a given reactively-saved\n  // subscription.\n  stream.receive({msg: 'ready', 'subs': [idStopperAgain, idBar1]});\n  test.equal(onReadyCount, {completer: 2, bar1: 1, stopper: 1});\n\n  // Shut down the autorun. This should unsub us from all current subs at flush\n  // time.\n  autorunHandle.stop();\n  Tracker.flush();\n  test.isFalse(completerReady);\n  readyAutorunHandle.stop();\n\n  test.length(stream.sent, 4);\n  // The order of unsubs here is not important.\n  var unsubMessages = _.map(stream.sent, JSON.parse);\n  stream.sent.length = 0;\n  test.equal(_.unique(_.pluck(unsubMessages, 'msg')), ['unsub']);\n  var actualIds = _.pluck(unsubMessages, 'id');\n  var expectedIds = [idFoo2, idBar1, idCompleter, idStopperAgain];\n  actualIds.sort();\n  expectedIds.sort();\n  test.equal(actualIds, expectedIds);\n});\n\nTinytest.add(\"livedata stub - reactive subscribe handle correct\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var rFoo = new ReactiveVar('foo1');\n\n  // Subscribe to some subs.\n  var fooHandle, fooReady;\n  var autorunHandle = Tracker.autorun(function () {\n    fooHandle = conn.subscribe(\"foo\", rFoo.get());\n    Tracker.autorun(function() {\n      fooReady = fooHandle.ready();\n    });\n  });\n\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo1']});\n\n  // Not ready yet\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady);\n\n  // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, reading the new false value, and\n  // setting up a new dep which goes true soon\n  rFoo.set(\"foo2\");\n  Tracker.flush();\n  test.length(stream.sent, 2);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo2']});\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: idFoo1});\n\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady);\n\n  // \"foo\" gets ready now. The handle should be ready and the autorun rerun\n  stream.receive({msg: 'ready', 'subs': [idFoo2]});\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady);\n\n  // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, making fooReady false too\n  rFoo.set(\"foo3\");\n  Tracker.flush();\n  test.length(stream.sent, 2);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo3 = message.id;\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo', params: ['foo3']});\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {msg: 'unsub', id: idFoo2});\n\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady);\n\n  // \"foo\" gets ready again\n  stream.receive({msg: 'ready', 'subs': [idFoo3]});\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady);\n\n  autorunHandle.stop();\n});\n\nTinytest.add(\"livedata stub - this\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n  conn.methods({test_this: function() {\n    test.isTrue(this.isSimulation);\n    this.unblock(); // should be a no-op\n  }});\n\n  // should throw no exceptions\n  conn.call('test_this', _.identity);\n  // satisfy method, quiesce connection\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {msg: 'method', method: 'test_this',\n                       params: [], id:message.id});\n  test.length(stream.sent, 0);\n\n  stream.receive({msg: 'result', id:message.id, result:null});\n  stream.receive({msg: 'updated', 'methods': [message.id]});\n\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - methods\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n\n    // setup method\n    conn.methods({do_something: function (x) {\n      coll.insert({value: x});\n    }});\n\n    // setup observers\n    var counts = {added: 0, removed: 0, changed: 0, moved: 0};\n    var handle = coll.find({}).observe(\n      { addedAt: function () { counts.added += 1; },\n        removedAt: function () { counts.removed += 1; },\n        changedAt: function () { counts.changed += 1; },\n        movedTo: function () { counts.moved += 1; }\n      });\n\n\n    // call method with results callback\n    var callback1Fired = false;\n    conn.call('do_something', 'friday!', function (err, res) {\n      test.isUndefined(err);\n      test.equal(res, '1234');\n      callback1Fired = true;\n    });\n    test.isFalse(callback1Fired);\n\n    // observers saw the method run.\n    test.equal(counts, {added: 1, removed: 0, changed: 0, moved: 0});\n\n    // get response from server\n    var message = testGotMessage(test, stream, {msg: 'method',\n                                                method: 'do_something',\n                                                params: ['friday!'],\n                                                id: '*',\n                                                randomSeed: '*'});\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'friday!'}).count(), 1);\n    var docId = coll.findOne({value: 'friday!'})._id;\n\n    // results does not yet result in callback, because data is not\n    // ready.\n    stream.receive({msg: 'result', id:message.id, result: \"1234\"});\n    test.isFalse(callback1Fired);\n\n    // result message doesn't affect data\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'friday!'}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 0, moved: 0});\n\n    // data methods do not show up (not quiescent yet)\n    stream.receive({msg: 'added', collection: collName, id: MongoID.idStringify(docId),\n                    fields: {value: 'tuesday'}});\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'friday!'}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 0, moved: 0});\n\n    // send another methods (unknown on client)\n    var callback2Fired = false;\n    conn.call('do_something_else', 'monday', function (err, res) {\n      callback2Fired = true;\n    });\n    test.isFalse(callback1Fired);\n    test.isFalse(callback2Fired);\n\n    // test we still send a method request to server\n    var message2 = JSON.parse(stream.sent.shift());\n    test.isUndefined(message2.randomSeed);\n    test.equal(message2, {msg: 'method', method: 'do_something_else',\n                          params: ['monday'], id: message2.id});\n\n    // get the first data satisfied message. changes are applied to database even\n    // though another method is outstanding, because the other method didn't have\n    // a stub. and its callback is called.\n    stream.receive({msg: 'updated', 'methods': [message.id]});\n    test.isTrue(callback1Fired);\n    test.isFalse(callback2Fired);\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'tuesday'}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 1, moved: 0});\n\n    // second result\n    stream.receive({msg: 'result', id:message2.id, result:\"bupkis\"});\n    test.isFalse(callback2Fired);\n\n    // get second satisfied; no new changes are applied.\n    stream.receive({msg: 'updated', 'methods': [message2.id]});\n    test.isTrue(callback2Fired);\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({value: 'tuesday', _id: docId}).count(), 1);\n    test.equal(counts, {added: 1, removed: 0, changed: 1, moved: 0});\n\n    handle.stop();\n  });\n}\n\nTinytest.add(\"livedata stub - mutating method args\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  conn.methods({mutateArgs: function (arg) {\n    arg.foo = 42;\n  }});\n\n  conn.call('mutateArgs', {foo: 50}, _.identity);\n\n  // Method should be called with original arg, not mutated arg.\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {msg: 'method', method: 'mutateArgs',\n                       params: [{foo: 50}], id: message.id});\n  test.length(stream.sent, 0);\n});\n\nvar observeCursor = function (test, cursor) {\n  var counts = {added: 0, removed: 0, changed: 0, moved: 0};\n  var expectedCounts = _.clone(counts);\n  var handle = cursor.observe(\n    { addedAt: function () { counts.added += 1; },\n      removedAt: function () { counts.removed += 1; },\n      changedAt: function () { counts.changed += 1; },\n      movedTo: function () { counts.moved += 1; }\n    });\n  return {\n    stop: _.bind(handle.stop, handle),\n    expectCallbacks: function (delta) {\n      _.each(delta, function (mod, field) {\n        expectedCounts[field] += mod;\n      });\n      test.equal(counts, expectedCounts);\n    }\n  };\n};\n\n// method calls another method in simulation. see not sent.\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - methods calling methods\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var coll_name = Random.id();\n    var coll = new Mongo.Collection(coll_name, {connection: conn});\n\n    // setup methods\n    conn.methods({\n      do_something: function () {\n        conn.call('do_something_else');\n      },\n      do_something_else: function () {\n        coll.insert({a: 1});\n      }\n    });\n\n    var o = observeCursor(test, coll.find());\n\n    // call method.\n    conn.call('do_something', _.identity);\n\n    // see we only send message for outer methods\n    var message = testGotMessage(test, stream, {msg: 'method',\n                                                method: 'do_something',\n                                                params: [],\n                                                id: '*',\n                                                randomSeed: '*'});\n    test.length(stream.sent, 0);\n\n    // but inner method runs locally.\n    o.expectCallbacks({added: 1});\n    test.equal(coll.find().count(), 1);\n    var docId = coll.findOne()._id;\n    test.equal(coll.findOne(), {_id: docId, a: 1});\n\n    // we get the results\n    stream.receive({msg: 'result', id:message.id, result:\"1234\"});\n\n    // get data from the method. data from this doc does not show up yet, but data\n    // from another doc does.\n    stream.receive({msg: 'added', collection: coll_name, id: MongoID.idStringify(docId),\n                    fields: {value: 'tuesday'}});\n    o.expectCallbacks();\n    test.equal(coll.findOne(docId), {_id: docId, a: 1});\n    stream.receive({msg: 'added', collection: coll_name, id: 'monkey',\n                    fields: {value: 'bla'}});\n    o.expectCallbacks({added: 1});\n    test.equal(coll.findOne(docId), {_id: docId, a: 1});\n    var newDoc = coll.findOne({value: 'bla'});\n    test.isTrue(newDoc);\n    test.equal(newDoc, {_id: newDoc._id, value: 'bla'});\n\n    // get method satisfied. all data shows up. the 'a' field is reverted and\n    // 'value' field is set.\n    stream.receive({msg: 'updated', 'methods': [message.id]});\n    o.expectCallbacks({changed: 1});\n    test.equal(coll.findOne(docId), {_id: docId, value: 'tuesday'});\n    test.equal(coll.findOne(newDoc._id), {_id: newDoc._id, value: 'bla'});\n\n    o.stop();\n  });\n}\nTinytest.add(\"livedata stub - method call before connect\", function (test) {\n  var stream = new StubStream;\n  var conn = newConnection(stream);\n\n  var callbackOutput = [];\n  conn.call('someMethod', function (err, result) {\n    callbackOutput.push(result);\n  });\n  test.equal(callbackOutput, []);\n\n  // the real stream drops all output pre-connection\n  stream.sent.length = 0;\n\n  // Now connect.\n  stream.reset();\n\n  testGotMessage(test, stream, makeConnectMessage());\n  testGotMessage(test, stream, {msg: 'method', method: 'someMethod',\n                                params: [], id: '*'});\n});\n\nTinytest.add(\"livedata stub - reconnect\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {connection: conn});\n\n  var o = observeCursor(test, coll.find());\n\n  // subscribe\n  var subCallbackFired = false;\n  var sub = conn.subscribe('my_data', function () {\n    subCallbackFired = true;\n  });\n  test.isFalse(subCallbackFired);\n\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {msg: 'sub', name: 'my_data', params: [],\n                          id: subMessage.id});\n\n  // get some data. it shows up.\n  stream.receive({msg: 'added', collection: collName,\n                  id: '1234', fields: {a:1}});\n\n  test.equal(coll.find({}).count(), 1);\n  o.expectCallbacks({added: 1});\n  test.isFalse(subCallbackFired);\n\n  stream.receive({msg: 'changed', collection: collName,\n                  id: '1234', fields: {b:2}});\n  stream.receive({msg: 'ready',\n                  subs: [subMessage.id] // satisfy sub\n                 });\n  test.isTrue(subCallbackFired);\n  subCallbackFired = false; // re-arm for test that it doesn't fire again.\n\n  test.equal(coll.find({a:1, b:2}).count(), 1);\n  o.expectCallbacks({changed: 1});\n\n  // call method.\n  var methodCallbackFired = false;\n  conn.call('do_something', function () {\n    methodCallbackFired = true;\n  });\n\n  conn.apply('do_something_else', [], {wait: true}, _.identity);\n  conn.apply('do_something_later', [], _.identity);\n\n  test.isFalse(methodCallbackFired);\n\n  // The non-wait method should send, but not the wait method.\n  var methodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(methodMessage.randomSeed);\n  test.equal(methodMessage, {msg: 'method', method: 'do_something',\n                             params: [], id:methodMessage.id});\n  test.equal(stream.sent.length, 0);\n\n  // more data. shows up immediately because there was no relevant method stub.\n  stream.receive({msg: 'changed', collection: collName,\n                  id: '1234', fields: {c:3}});\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3});\n  o.expectCallbacks({changed: 1});\n\n  // stream reset. reconnect!  we send a connect, our pending method, and our\n  // sub. The wait method still is blocked.\n  stream.reset();\n\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, methodMessage);\n  testGotMessage(test, stream, subMessage);\n\n  // reconnect with different session id\n  stream.receive({msg: 'connected', session: SESSION_ID + 1});\n\n  // resend data. doesn't show up: we're in reconnect quiescence.\n  stream.receive({msg: 'added', collection: collName,\n                  id: '1234', fields: {a:1, b:2, c:3, d: 4}});\n  stream.receive({msg: 'added', collection: collName,\n                  id: '2345', fields: {e: 5}});\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3});\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks();\n\n  // satisfy and return the method\n  stream.receive({msg: 'updated',\n                  methods: [methodMessage.id]});\n  test.isFalse(methodCallbackFired);\n  stream.receive({msg: 'result', id:methodMessage.id, result:\"bupkis\"});\n  // The callback still doesn't fire (and we don't send the wait method): we're\n  // still in global quiescence\n  test.isFalse(methodCallbackFired);\n  test.equal(stream.sent.length, 0);\n\n  // still no update.\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3});\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks();\n\n  // re-satisfy sub\n  stream.receive({msg: 'ready', subs: [subMessage.id]});\n\n  // now the doc changes and method callback is called, and the wait method is\n  // sent. the sub callback isn't re-called.\n  test.isTrue(methodCallbackFired);\n  test.isFalse(subCallbackFired);\n  test.equal(coll.findOne('1234'), {_id: '1234', a: 1, b: 2, c: 3, d: 4});\n  test.equal(coll.findOne('2345'), {_id: '2345', e: 5});\n  o.expectCallbacks({added: 1, changed: 1});\n\n  var waitMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(waitMethodMessage.randomSeed);\n  test.equal(waitMethodMessage, {msg: 'method', method: 'do_something_else',\n                                 params: [], id: waitMethodMessage.id});\n  test.equal(stream.sent.length, 0);\n  stream.receive({msg: 'result', id: waitMethodMessage.id, result: \"bupkis\"});\n  test.equal(stream.sent.length, 0);\n  stream.receive({msg: 'updated', methods: [waitMethodMessage.id]});\n\n  // wait method done means we can send the third method\n  test.equal(stream.sent.length, 1);\n  var laterMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(laterMethodMessage.randomSeed);\n  test.equal(laterMethodMessage, {msg: 'method', method: 'do_something_later',\n                                  params: [], id: laterMethodMessage.id});\n\n  o.stop();\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - reconnect non-idempotent method\", function(test) {\n    // This test is for https://github.com/meteor/meteor/issues/6108\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var firstMethodCallbackFired = false;\n    var firstMethodCallbackErrored = false;\n    var secondMethodCallbackFired = false;\n    var secondMethodCallbackErrored = false;\n\n    // call with noRetry true so that the method should fail to retry on reconnect.\n    conn.apply('do_something', [], {noRetry: true}, function(error) {\n      firstMethodCallbackFired = true;\n      // failure on reconnect should trigger an error.\n      if (error && error.error === 'invocation-failed') {\n        firstMethodCallbackErrored = true;\n      }\n    });\n    conn.apply('do_something_else', [], {noRetry: true}, function(error) {\n      secondMethodCallbackFired = true;\n      // failure on reconnect should trigger an error.\n      if (error && error.error === 'invocation-failed') {\n        secondMethodCallbackErrored = true;\n      }\n    });\n\n    // The method has not succeeded yet\n    test.isFalse(firstMethodCallbackFired);\n    test.isFalse(secondMethodCallbackFired);\n\n    // send the methods\n    stream.sent.shift();\n    stream.sent.shift();\n    // reconnect\n    stream.reset();\n\n    // verify that a reconnect message was sent.\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    // Make sure that the stream triggers connection.\n    stream.receive({msg: 'connected', session: SESSION_ID + 1});\n\n    //The method callback should fire even though the stream has not sent a response.\n    //the callback should have been fired with an error.\n    test.isTrue(firstMethodCallbackFired);\n    test.isTrue(firstMethodCallbackErrored);\n    test.isTrue(secondMethodCallbackFired);\n    test.isTrue(secondMethodCallbackErrored);\n\n    // verify that the method message was not sent.\n    test.isUndefined(stream.sent.shift());\n  });\n}\n\nfunction addReconnectTests(name, testFunc) {\n  Tinytest.add(name + \" (deprecated)\", function (test) {\n    function deprecatedSetOnReconnect(conn, handler) {\n      conn.onReconnect = handler;\n    }\n    testFunc.call(this, test, deprecatedSetOnReconnect);\n  });\n\n  Tinytest.add(name, function (test) {\n    var stopper;\n    function setOnReconnect(conn, handler) {\n      stopper && stopper.stop();\n      stopper = DDP.onReconnect(function (reconnectingConn) {\n        if (reconnectingConn === conn) {\n          handler();\n        }\n      });\n    }\n    testFunc.call(this, test, setOnReconnect);\n    stopper && stopper.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  addReconnectTests(\"livedata stub - reconnect method which only got result\", function (test, setOnReconnect) {\n    var stream = new StubStream;\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n    var o = observeCursor(test, coll.find());\n\n    conn.methods({writeSomething: function () {\n      // stub write\n      coll.insert({foo: 'bar'});\n    }});\n\n    test.equal(coll.find({foo: 'bar'}).count(), 0);\n\n    // Call a method. We'll get the result but not data-done before reconnect.\n    var callbackOutput = [];\n    var onResultReceivedOutput = [];\n    conn.apply('writeSomething', [],\n               {onResultReceived: function (err, result) {\n                 onResultReceivedOutput.push(result);\n               }},\n               function (err, result) {\n                 callbackOutput.push(result);\n               });\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId = coll.findOne({foo: 'bar'})._id;\n    o.expectCallbacks({added: 1});\n    // Callback not called.\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, []);\n    // Method sent.\n    var methodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'writeSomething',\n                     params: [], id: '*', randomSeed: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // Get some data.\n    stream.receive({msg: 'added', collection: collName,\n                    id: MongoID.idStringify(stubWrittenId), fields: {baz: 42}});\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, foo: 'bar'});\n    o.expectCallbacks();\n\n    // Get the result.\n    stream.receive({msg: 'result', id: methodId, result: 'bla'});\n    // Data unaffected.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, foo: 'bar'});\n    o.expectCallbacks();\n    // Callback not called, but onResultReceived is.\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, ['bla']);\n\n    // Reset stream. Method does NOT get resent, because its result is already\n    // in. Reconnect quiescence happens as soon as 'connected' is received because\n    // there are no pending methods or subs in need of revival.\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    // Still holding out hope for session resumption, so nothing updated yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, foo: 'bar'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, []);\n\n    // Receive 'connected': time for reconnect quiescence! Data gets updated\n    // locally (ie, data is reset) and callback gets called.\n    stream.receive({msg: 'connected', session: SESSION_ID + 1});\n    test.equal(coll.find().count(), 0);\n    o.expectCallbacks({removed: 1});\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']);\n    stream.receive({msg: 'added', collection: collName,\n                    id: MongoID.idStringify(stubWrittenId), fields: {baz: 42}});\n    test.equal(coll.findOne(stubWrittenId), {_id: stubWrittenId, baz: 42});\n    o.expectCallbacks({added: 1});\n\n\n\n\n    // Run method again. We're going to do the same thing this time, except we're\n    // also going to use an onReconnect to insert another method at reconnect\n    // time, which will delay reconnect quiescence.\n    conn.apply('writeSomething', [],\n               {onResultReceived: function (err, result) {\n                 onResultReceivedOutput.push(result);\n               }},\n               function (err, result) {\n                 callbackOutput.push(result);\n               });\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId2 = coll.findOne({foo: 'bar'})._id;\n    o.expectCallbacks({added: 1});\n    // Callback not called.\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']);\n    // Method sent.\n    var methodId2 = testGotMessage(\n      test, stream, {msg: 'method', method: 'writeSomething',\n                     params: [], id: '*', randomSeed: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // Get some data.\n    stream.receive({msg: 'added', collection: collName,\n                    id: MongoID.idStringify(stubWrittenId2), fields: {baz: 42}});\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n\n    // Get the result.\n    stream.receive({msg: 'result', id: methodId2, result: 'blab'});\n    // Data unaffected.\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n    // Callback not called, but onResultReceived is.\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla', 'blab']);\n    setOnReconnect(conn, function () {\n      conn.call('slowMethod', function (err, result) {\n        callbackOutput.push(result);\n      });\n    });\n\n    // Reset stream. Method does NOT get resent, because its result is already in,\n    // but slowMethod gets called via onReconnect. Reconnect quiescence is now\n    // blocking on slowMethod.\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID + 1));\n    var slowMethodId = testGotMessage(\n      test, stream,\n      {msg: 'method', method: 'slowMethod', params: [], id: '*'}).id;\n    // Still holding out hope for session resumption, so nothing updated yet.\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']);\n\n    // Receive 'connected'... but no reconnect quiescence yet due to slowMethod.\n    stream.receive({msg: 'connected', session: SESSION_ID + 2});\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']);\n\n    // Receive data matching our stub. It doesn't take effect yet.\n    stream.receive({msg: 'added', collection: collName,\n                    id: MongoID.idStringify(stubWrittenId2), fields: {foo: 'bar'}});\n    o.expectCallbacks();\n\n    // slowMethod is done writing, so we get full reconnect quiescence (but no\n    // slowMethod callback)... ie, a reset followed by applying the data we just\n    // got, as well as calling the callback from the method that half-finished\n    // before reset. The net effect is deleting doc 'stubWrittenId'.\n    stream.receive({msg: 'updated', methods: [slowMethodId]});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId2), {_id: stubWrittenId2, foo: 'bar'});\n    o.expectCallbacks({removed: 1});\n    test.equal(callbackOutput, ['bla', 'blab']);\n\n    // slowMethod returns a value now.\n    stream.receive({msg: 'result', id: slowMethodId, result: 'slow'});\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla', 'blab', 'slow']);\n\n    o.stop();\n  });\n}\nTinytest.add(\"livedata stub - reconnect method which only got data\", function (test) {\n  var stream = new StubStream;\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {connection: conn});\n  var o = observeCursor(test, coll.find());\n\n  // Call a method. We'll get the data-done message but not the result before\n  // reconnect.\n  var callbackOutput = [];\n  var onResultReceivedOutput = [];\n  conn.apply('doLittle', [],\n             {onResultReceived: function (err, result) {\n               onResultReceivedOutput.push(result);\n             }},\n             function (err, result) {\n               callbackOutput.push(result);\n             });\n  // Callbacks not called.\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n  // Method sent.\n  var methodId = testGotMessage(\n    test, stream, {msg: 'method', method: 'doLittle',\n                   params: [], id: '*'}).id;\n  test.equal(stream.sent.length, 0);\n\n  // Get some data.\n  stream.receive({msg: 'added', collection: collName,\n                  id: 'photo', fields: {baz: 42}});\n  // It shows up instantly because the stub didn't write anything.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks({added: 1});\n\n  // Get the data-done message.\n  stream.receive({msg: 'updated', methods: [methodId]});\n  // Data still here.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks();\n  // Method callback not called yet (no result yet).\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Reset stream. Method gets resent (with same ID), and blocks reconnect\n  // quiescence.\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(\n    test, stream, {msg: 'method', method: 'doLittle',\n                   params: [], id: methodId});\n  // Still holding out hope for session resumption, so nothing updated yet.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Receive 'connected'. Still blocking on reconnect quiescence.\n  stream.receive({msg: 'connected', session: SESSION_ID + 1});\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {_id: 'photo', baz: 42});\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Receive method result. onResultReceived is called but the main callback\n  // isn't (ie, we don't get confused by the fact that we got data-done the\n  // *FIRST* time through).\n  stream.receive({msg: 'result', id: methodId, result: 'res'});\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, ['res']);\n\n  // Now we get data-done. Collection is reset and callback is called.\n  stream.receive({msg: 'updated', methods: [methodId]});\n  test.equal(coll.find().count(), 0);\n  o.expectCallbacks({removed: 1});\n  test.equal(callbackOutput, ['res']);\n  test.equal(onResultReceivedOutput, ['res']);\n\n  o.stop();\n});\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - multiple stubs same doc\", function (test) {\n    var stream = new StubStream;\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n    var o = observeCursor(test, coll.find());\n\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({foo: 'bar'});\n      },\n      updateIt: function (id) {\n        coll.update(id, {$set: {baz: 42}});\n      }\n    });\n\n    test.equal(coll.find().count(), 0);\n\n    // Call the insert method.\n    conn.call('insertSomething', _.identity);\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId = coll.findOne({foo: 'bar'})._id;\n    o.expectCallbacks({added: 1});\n    // Method sent.\n    var insertMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'insertSomething',\n                     params: [], id: '*', randomSeed: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // Call update method.\n    conn.call('updateIt', stubWrittenId, _.identity);\n    // This stub write is visible too.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks({changed: 1});\n    // Method sent.\n    var updateMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'updateIt',\n                     params: [stubWrittenId], id: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // Get some data... slightly different than what we wrote.\n    stream.receive({msg: 'added', collection: collName,\n                    id: MongoID.idStringify(stubWrittenId), fields: {foo: 'barb', other: 'field',\n                                                                    other2: 'bla'}});\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks();\n\n    // And get the first method-done. Still no updates to minimongo: we can't\n    // quiesce the doc until the second method is done.\n    stream.receive({msg: 'updated', methods: [insertMethodId]});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks();\n\n    // More data. Not quite what we wrote. Also ignored for now.\n    stream.receive({msg: 'changed', collection: collName,\n                    id: MongoID.idStringify(stubWrittenId), fields: {baz: 43}, cleared: ['other']});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'bar', baz: 42});\n    o.expectCallbacks();\n\n    // Second data-ready. Now everything takes effect!\n    stream.receive({msg: 'updated', methods: [updateMethodId]});\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId),\n               {_id: stubWrittenId, foo: 'barb', other2: 'bla',\n                baz: 43});\n    o.expectCallbacks({changed: 1});\n\n    o.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - unsent methods don't block quiescence\", function (test) {\n    // This test is for https://github.com/meteor/meteor/issues/555\n\n    var stream = new StubStream;\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({foo: 'bar'});\n      }\n    });\n\n    test.equal(coll.find().count(), 0);\n\n    // Call a random method (no-op)\n    conn.call('no-op', _.identity);\n    // Call a wait method\n    conn.apply('no-op', [], {wait: true}, _.identity);\n    // Call a method with a stub that writes.\n    conn.call('insertSomething', _.identity);\n\n\n    // Stub write is visible.\n    test.equal(coll.find({foo: 'bar'}).count(), 1);\n    var stubWrittenId = coll.findOne({foo: 'bar'})._id;\n\n    // first method sent\n    var firstMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'no-op',\n                     params: [], id: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // ack the first method\n    stream.receive({msg: 'updated', methods: [firstMethodId]});\n    stream.receive({msg: 'result', id: firstMethodId});\n\n    // Wait method sent.\n    var waitMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'no-op',\n                     params: [], id: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // ack the wait method\n    stream.receive({msg: 'updated', methods: [waitMethodId]});\n    stream.receive({msg: 'result', id: waitMethodId});\n\n    // insert method sent.\n    var insertMethodId = testGotMessage(\n      test, stream, {msg: 'method', method: 'insertSomething',\n                     params: [], id: '*', randomSeed: '*'}).id;\n    test.equal(stream.sent.length, 0);\n\n    // ack the insert method\n    stream.receive({msg: 'updated', methods: [insertMethodId]});\n    stream.receive({msg: 'result', id: insertMethodId});\n\n    // simulation reverted.\n    test.equal(coll.find({foo: 'bar'}).count(), 0);\n\n  });\n}\nTinytest.add(\"livedata stub - reactive resub\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var readiedSubs = {};\n  var markAllReady = function () {\n    // synthesize a \"ready\" message in response to any \"sub\"\n    // message with an id we haven't seen before\n    _.each(stream.sent, function (msg) {\n      msg = JSON.parse(msg);\n      if (msg.msg === 'sub' && ! _.has(readiedSubs, msg.id)) {\n        stream.receive({msg: 'ready', subs: [msg.id]});\n        readiedSubs[msg.id] = true;\n      }\n    });\n  };\n\n  var fooArg = new ReactiveVar('A');\n  var fooReady = 0;\n\n  var inner;\n  var outer = Tracker.autorun(function () {\n    inner = Tracker.autorun(function () {\n      conn.subscribe(\"foo-sub\", fooArg.get(),\n                     function () { fooReady++; });\n    });\n  });\n\n  markAllReady();\n  var message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo-sub', params: ['A']});\n  test.equal(fooReady, 1);\n\n  // Rerun the inner autorun with different subscription\n  // arguments.\n  fooArg.set('B');\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo-sub', params: ['B']});\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {msg: 'unsub'});\n  test.equal(fooReady, 2);\n\n  // Rerun inner again with same args; should be no re-sub.\n  inner.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 3);\n\n  // Rerun outer!  Should still be no re-sub even though\n  // the inner computation is stopped and a new one is\n  // started.\n  outer.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 4);\n\n  // Change the subscription.  Now we should get an onReady.\n  fooArg.set('C');\n  Tracker.flush();\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {msg: 'sub', name: 'foo-sub', params: ['C']});\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {msg: 'unsub'});\n  test.equal(fooReady, 5);\n});\n\n\n\nTinytest.add(\"livedata connection - reactive userId\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  test.equal(conn.userId(), null);\n  conn.setUserId(1337);\n  test.equal(conn.userId(), 1337);\n});\n\nTinytest.add(\"livedata connection - two wait methods\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {connection: conn});\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  var responses = [];\n  conn.apply('do_something', ['one!'], function() { responses.push('one'); });\n  var one_message = JSON.parse(stream.sent.shift());\n  test.equal(one_message.params, ['one!']);\n\n  conn.apply('do_something', ['two!'], {wait: true}, function() {\n    responses.push('two');\n  });\n  // 'two!' isn't sent yet, because it's a wait method.\n  test.equal(stream.sent.length, 0);\n\n  conn.apply('do_something', ['three!'], function() {\n    responses.push('three');\n  });\n  conn.apply('do_something', ['four!'], function() {\n    responses.push('four');\n  });\n\n  conn.apply('do_something', ['five!'], {wait: true}, function() {\n    responses.push('five');\n  });\n\n  conn.apply('do_something', ['six!'], function() { responses.push('six'); });\n\n  // Verify that we did not send any more methods since we are still waiting on\n  // 'one!'.\n  test.equal(stream.sent.length, 0);\n\n  // Receive some data. \"one\" is not a wait method and there are no stubs, so it\n  // gets applied immediately.\n  test.equal(coll.find().count(), 0);\n  stream.receive({msg: 'added', collection: collName,\n                  id: 'foo', fields: {x: 1}});\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {_id: 'foo', x: 1});\n\n  // Let \"one!\" finish. Both messages are required to fire the callback.\n  stream.receive({msg: 'result', id: one_message.id});\n  test.equal(responses, []);\n  stream.receive({msg: 'updated', methods: [one_message.id]});\n  test.equal(responses, ['one']);\n\n  // Now we've send out \"two!\".\n  var two_message = JSON.parse(stream.sent.shift());\n  test.equal(two_message.params, ['two!']);\n\n  // But still haven't sent \"three!\".\n  test.equal(stream.sent.length, 0);\n\n  // Receive more data. \"two\" is a wait method, so the data doesn't get applied\n  // yet.\n  stream.receive({msg: 'changed', collection: collName,\n                  id: 'foo', fields: {y: 3}});\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {_id: 'foo', x: 1});\n\n  // Let \"two!\" finish, with its end messages in the opposite order to \"one!\".\n  stream.receive({msg: 'updated', methods: [two_message.id]});\n  test.equal(responses, ['one']);\n  test.equal(stream.sent.length, 0);\n  // data-done message is enough to allow data to be written.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {_id: 'foo', x: 1, y: 3});\n  stream.receive({msg: 'result', id: two_message.id});\n  test.equal(responses, ['one', 'two']);\n\n  // Verify that we just sent \"three!\" and \"four!\" now that we got\n  // responses for \"one!\" and \"two!\"\n  test.equal(stream.sent.length, 2);\n  var three_message = JSON.parse(stream.sent.shift());\n  test.equal(three_message.params, ['three!']);\n  var four_message = JSON.parse(stream.sent.shift());\n  test.equal(four_message.params, ['four!']);\n\n  // Out of order response is OK for non-wait methods.\n  stream.receive({msg: 'result', id: three_message.id});\n  stream.receive({msg: 'result', id: four_message.id});\n  stream.receive({msg: 'updated', methods: [four_message.id]});\n  test.equal(responses, ['one', 'two', 'four']);\n  test.equal(stream.sent.length, 0);\n\n  // Let three finish too.\n  stream.receive({msg: 'updated', methods: [three_message.id]});\n  test.equal(responses, ['one', 'two', 'four', 'three']);\n\n  // Verify that we just sent \"five!\" (the next wait method).\n  test.equal(stream.sent.length, 1);\n  var five_message = JSON.parse(stream.sent.shift());\n  test.equal(five_message.params, ['five!']);\n  test.equal(responses, ['one', 'two', 'four', 'three']);\n\n  // Let five finish.\n  stream.receive({msg: 'result', id: five_message.id});\n  stream.receive({msg: 'updated', methods: [five_message.id]});\n  test.equal(responses, ['one', 'two', 'four', 'three', 'five']);\n\n  var six_message = JSON.parse(stream.sent.shift());\n  test.equal(six_message.params, ['six!']);\n});\n\naddReconnectTests(\"livedata connection - onReconnect prepends messages correctly with a wait method\", function(test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  setOnReconnect(conn, function() {\n    conn.apply('do_something', ['reconnect zero'], _.identity);\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], {wait: true}, _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  });\n\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {wait: true}, _.identity);\n  conn.apply('do_something', ['three'], _.identity);\n\n  // reconnect\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n  // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n  test.equal(_.map(stream.sent, function(msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect zero', 'reconnect one']);\n\n  // white-box test:\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [\n    [false, ['reconnect zero', 'reconnect one']],\n    [true, ['reconnect two']],\n    [false, ['reconnect three', 'one']],\n    [true, ['two']],\n    [false, ['three']]\n  ]);\n});\n\nTinytest.add(\"livedata connection - ping without id\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  stream.receive({msg: 'ping'});\n  testGotMessage(test, stream, {msg: 'pong'});\n});\n\nTinytest.add(\"livedata connection - ping with id\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var id = Random.id();\n  stream.receive({msg: 'ping', id: id});\n  testGotMessage(test, stream, {msg: 'pong', id: id});\n});\n\n_.each(LivedataTest.SUPPORTED_DDP_VERSIONS, function (version) {\n  Tinytest.addAsync(\"livedata connection - ping from \" + version,\n                    function (test, onComplete) {\n    var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n      reloadWithOutstanding: true,\n      supportedDDPVersions: [version],\n      onDDPVersionNegotiationFailure: function () { test.fail(); onComplete(); },\n      onConnected: function () {\n        test.equal(connection._version, version);\n        // It's a little naughty to access _stream and _send, but it works...\n        connection._stream.on('message', function (json) {\n          var msg = JSON.parse(json);\n          var done = false;\n          if (msg.msg === 'pong') {\n            test.notEqual(version, \"pre1\");\n            done = true;\n          } else if (msg.msg === 'error') {\n            // Version pre1 does not play ping-pong\n            test.equal(version, \"pre1\");\n            done = true;\n          } else {\n            Meteor._debug(\"Got unexpected message: \" + json);\n          }\n          if (done) {\n            connection._stream.disconnect({_permanent: true});\n            onComplete();\n          }\n        });\n        connection._send({msg: 'ping'});\n      }\n    });\n  });\n});\n\nvar getSelfConnectionUrl = function () {\n  if (Meteor.isClient) {\n    var ddpUrl = Meteor._relativeToSiteRootUrl(\"/\");\n    if (typeof __meteor_runtime_config__ !== \"undefined\") {\n      if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)\n        ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n    }\n    return ddpUrl;\n  } else {\n    return Meteor.absoluteUrl();\n  }\n};\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    reverse: function (arg) {\n      // Return something notably different from reverse.meteor.com.\n      return arg.split(\"\").reverse().join(\"\") + \" LOCAL\";\n    }\n  });\n}\n\ntestAsyncMulti(\"livedata connection - reconnect to a different server\", [\n  function (test, expect) {\n    var self = this;\n    self.conn = DDP.connect(\"reverse.meteor.com\");\n    pollUntil(expect, function () {\n      return self.conn.status().connected;\n    }, 5000, 100, true); // poll until connected, but don't fail if we don't connect\n  },\n  function (test, expect) {\n    var self = this;\n    self.doTest = self.conn.status().connected;\n    if (self.doTest) {\n      self.conn.call(\"reverse\", \"foo\", expect(function (err, res) {\n        test.equal(res, \"oof\");\n      }));\n    }\n  },\n  function (test, expect) {\n    var self = this;\n    if (self.doTest) {\n      self.conn.reconnect({url: getSelfConnectionUrl()});\n      self.conn.call(\"reverse\", \"bar\", expect(function (err, res) {\n        test.equal(res, \"rab LOCAL\");\n      }));\n    }\n  }\n]);\n\nTinytest.addAsync(\"livedata connection - version negotiation requires renegotiating\",\n                  function (test, onComplete) {\n  var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: [\"garbled\", LivedataTest.SUPPORTED_DDP_VERSIONS[0]],\n    onDDPVersionNegotiationFailure: function () { test.fail(); onComplete(); },\n    onConnected: function () {\n      test.equal(connection._version, LivedataTest.SUPPORTED_DDP_VERSIONS[0]);\n      connection._stream.disconnect({_permanent: true});\n      onComplete();\n    }\n  });\n});\n\nTinytest.addAsync(\"livedata connection - version negotiation error\",\n                  function (test, onComplete) {\n  var connection = new LivedataTest.Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: [\"garbled\", \"more garbled\"],\n    onDDPVersionNegotiationFailure: function () {\n      test.equal(connection.status().status, \"failed\");\n      test.matches(connection.status().reason, /DDP version negotiation failed/);\n      test.isFalse(connection.status().connected);\n      onComplete();\n    },\n    onConnected: function () {\n      test.fail();\n      onComplete();\n    }\n  });\n});\n\naddReconnectTests(\"livedata connection - onReconnect prepends messages correctly without a wait method\", function(test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  setOnReconnect(conn, function() {\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  });\n\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {wait: true}, _.identity);\n  conn.apply('do_something', ['three'], {wait: true}, _.identity);\n  conn.apply('do_something', ['four'], _.identity);\n\n  // reconnect\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n  // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n  test.equal(_.map(stream.sent, function(msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect one', 'reconnect two', 'reconnect three', 'one']);\n\n  // white-box test:\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [\n    [false, ['reconnect one', 'reconnect two', 'reconnect three', 'one']],\n    [true, ['two']],\n    [true, ['three']],\n    [false, ['four']]\n  ]);\n});\n\naddReconnectTests(\"livedata connection - onReconnect with sent messages\", function(test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  // setup method\n  conn.methods({do_something: function (x) {}});\n\n  setOnReconnect(conn, function() {\n    conn.apply('do_something', ['login'], {wait: true}, _.identity);\n  });\n\n  conn.apply('do_something', ['one'], _.identity);\n\n  // initial connect\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(\n    test, stream, makeConnectMessage(conn._lastSessionId));\n\n  // Test that we sent just the login message.\n  var loginId = testGotMessage(\n    test, stream, {msg: 'method', method: 'do_something',\n                   params: ['login'], id: '*'}).id;\n\n  // we connect.\n  stream.receive({msg: 'connected', session: Random.id()});\n  test.length(stream.sent, 0);\n\n  // login got result (but not yet data)\n  stream.receive({msg: 'result', id: loginId, result: 'foo'});\n  test.length(stream.sent, 0);\n\n  // login got data. now we send next method.\n  stream.receive({msg: 'updated', methods: [loginId]});\n\n  testGotMessage(\n    test, stream, {msg: 'method', method: 'do_something',\n                   params: ['one'], id: '*'}).id;\n});\n\n\n\naddReconnectTests(\"livedata stub - reconnect double wait method\", function (test, setOnReconnect) {\n  var stream = new StubStream;\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var output = [];\n  setOnReconnect(conn, function () {\n    conn.apply('reconnectMethod', [], {wait: true}, function (err, result) {\n      output.push('reconnect');\n    });\n  });\n\n  conn.apply('halfwayMethod', [], {wait: true}, function (err, result) {\n    output.push('halfway');\n  });\n\n  test.equal(output, []);\n  // Method sent.\n  var halfwayId = testGotMessage(\n    test, stream, {msg: 'method', method: 'halfwayMethod',\n                   params: [], id: '*'}).id;\n  test.equal(stream.sent.length, 0);\n\n  // Get the result. This means it will not be resent.\n  stream.receive({msg: 'result', id: halfwayId, result: 'bla'});\n  // Callback not called.\n  test.equal(output, []);\n\n  // Reset stream. halfwayMethod does NOT get resent, but reconnectMethod does!\n  // Reconnect quiescence happens when reconnectMethod is done.\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  var reconnectId = testGotMessage(\n    test, stream, {msg: 'method', method: 'reconnectMethod',\n                   params: [], id: '*'}).id;\n  test.length(stream.sent, 0);\n  // Still holding out hope for session resumption, so no callbacks yet.\n  test.equal(output, []);\n\n  // Receive 'connected', but reconnect quiescence is blocking on\n  // reconnectMethod.\n  stream.receive({msg: 'connected', session: SESSION_ID + 1});\n  test.equal(output, []);\n\n  // Data-done for reconnectMethod. This gets us to reconnect quiescence, so\n  // halfwayMethod's callback fires. reconnectMethod's is still waiting on its\n  // result.\n  stream.receive({msg: 'updated', methods: [reconnectId]});\n  test.equal(output.shift(), 'halfway');\n  test.equal(output, []);\n\n  // Get result of reconnectMethod. Its callback fires.\n  stream.receive({msg: 'result', id: reconnectId, result: 'foo'});\n  test.equal(output.shift(), 'reconnect');\n  test.equal(output, []);\n\n  // Call another method. It should be delivered immediately. This is a\n  // regression test for a case where it never got delivered because there was\n  // an empty block in _outstandingMethodBlocks blocking it from being sent.\n  conn.call('lastMethod', _.identity);\n  testGotMessage(test, stream,\n                 {msg: 'method', method: 'lastMethod', params: [], id: '*'});\n});\n\nTinytest.add(\"livedata stub - subscribe errors\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var onReadyFired = false;\n  var subErrorInStopped = null;\n  var subErrorInError = null;\n\n  conn.subscribe('unknownSub', {\n    onReady: function () {\n      onReadyFired = true;\n    },\n\n    // We now have two ways to get the error from a subscription:\n    // 1. onStop, which is called no matter what when the subscription is\n    //    stopped (a lifecycle callback)\n    // 2. onError, which is deprecated and is called only if there is an\n    //    error\n    onStop: function (error) {\n      subErrorInStopped = error;\n    },\n    onError: function (error) {\n      subErrorInError = error;\n    }\n  });\n\n  test.isFalse(onReadyFired);\n  test.equal(subErrorInStopped, null);\n\n  // XXX COMPAT WITH 1.0.3.1 #errorCallback\n  test.equal(subErrorInError, null);\n\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {msg: 'sub', name: 'unknownSub', params: [],\n                          id: subMessage.id});\n\n  // Reject the sub.\n  stream.receive({msg: 'nosub', id: subMessage.id,\n                  error: new Meteor.Error(404, \"Subscription not found\")});\n  test.isFalse(onReadyFired);\n\n  // Check the error passed to the stopped callback was correct\n  test.instanceOf(subErrorInStopped, Meteor.Error);\n  test.equal(subErrorInStopped.error, 404);\n  test.equal(subErrorInStopped.reason, \"Subscription not found\");\n\n  // Check the error passed to the error callback was correct\n  // XXX COMPAT WITH 1.0.3.1 #errorCallback\n  test.instanceOf(subErrorInError, Meteor.Error);\n  test.equal(subErrorInError.error, 404);\n  test.equal(subErrorInError.reason, \"Subscription not found\");\n\n  // stream reset: reconnect!\n  stream.reset();\n  // We send a connect.\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  // We should NOT re-sub to the sub, because we processed the error.\n  test.length(stream.sent, 0);\n  test.isFalse(onReadyFired);\n});\n\nTinytest.add(\"livedata stub - subscribe stop\", function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var onReadyFired = false;\n  var onStopFired = false;\n  var subErrorInStopped = null;\n\n  var sub = conn.subscribe('my_data', {\n    onStop: function (error) {\n      onStopFired = true;\n      subErrorInStopped = error;\n    }\n  });\n\n  test.equal(subErrorInStopped, null);\n\n  sub.stop();\n\n  test.isTrue(onStopFired);\n  test.equal(subErrorInStopped, undefined);\n});\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - stubs before connected\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n\n    // Start and send \"connect\", but DON'T get 'connected' quite yet.\n    stream.reset(); // initial connection start.\n\n    testGotMessage(test, stream, makeConnectMessage());\n    test.length(stream.sent, 0);\n\n    // Insert a document. The stub updates \"conn\" directly.\n    coll.insert({_id: \"foo\", bar: 42}, _.identity);\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(), {_id: \"foo\", bar: 42});\n    // It also sends the method message.\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.isUndefined(methodMessage.randomSeed);\n    test.equal(methodMessage, {msg: 'method', method: '/' + collName + '/insert',\n                               params: [{_id: \"foo\", bar: 42}],\n                               id: methodMessage.id});\n    test.length(stream.sent, 0);\n\n    // Now receive a connected message. This should not clear the\n    // _documentsWrittenByStub state!\n    stream.receive({msg: 'connected', session: SESSION_ID});\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 1);\n\n    // Now receive the \"updated\" message for the method. This should revert the\n    // insert.\n    stream.receive({msg: 'updated', methods: [methodMessage.id]});\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 0);\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - method call between reset and quiescence\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n\n    conn.methods({\n      update_value: function () {\n        coll.update('aaa', {value: 222});\n      }\n    });\n\n    // Set up test subscription.\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {msg: 'sub', name: 'test_data',\n                            params: [], id:subMessage.id});\n    test.length(stream.sent, 0);\n\n    var subDocMessage = {msg: 'added', collection: collName,\n                         id: 'aaa', fields: {value: 111}};\n\n    var subReadyMessage = {msg: 'ready', 'subs': [subMessage.id]};\n\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.isTrue(coll.findOne('aaa').value == 111);\n\n    // Initiate reconnect.\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    testGotMessage(test, stream, subMessage);\n    stream.receive({msg: 'connected', session: SESSION_ID + 1});\n\n    // Now in reconnect, can still see the document.\n    test.isTrue(coll.findOne('aaa').value == 111);\n\n    conn.call('update_value');\n\n    // Observe the stub-written value.\n    test.isTrue(coll.findOne('aaa').value == 222);\n\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {msg: 'method', method: 'update_value',\n                               params: [], id:methodMessage.id});\n    test.length(stream.sent, 0);\n\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n\n    // By this point quiescence is reached and stores have been reset.\n\n    // The stub-written value is still there.\n    test.isTrue(coll.findOne('aaa').value == 222);\n\n    stream.receive({msg: 'changed', collection: collName,\n                         id: 'aaa', fields: {value: 333}});\n    stream.receive({msg: 'updated', 'methods': [methodMessage.id]});\n    stream.receive({msg: 'result', id:methodMessage.id, result:null});\n\n    // Server wrote a different value, make sure it's visible now.\n    test.isTrue(coll.findOne('aaa').value == 333);\n  });\n\n  Tinytest.add(\"livedata stub - buffering and methods interaction\", function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream, {\n      // A very high values so that all messages are effectively buffered.\n      bufferedWritesInterval: 10000,\n      bufferedWritesMaxAge: 10000\n    });\n\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {connection: conn});\n\n    conn.methods({\n      update_value: function () {\n        const value = coll.findOne('aaa').subscription;\n        // Method should have access to the latest value of the collection.\n        coll.update('aaa', {$set: {method: value + 110}});\n      }\n    });\n\n    // Set up test subscription.\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {msg: 'sub', name: 'test_data',\n                            params: [], id:subMessage.id});\n    test.length(stream.sent, 0);\n\n    var subDocMessage = {msg: 'added', collection: collName,\n                         id: 'aaa', fields: {subscription: 111}};\n\n    var subReadyMessage = {msg: 'ready', 'subs': [subMessage.id]};\n\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.equal(coll.findOne('aaa').subscription, 111);\n\n    var subDocChangeMessage = {msg: 'changed', collection: collName,\n                               id: 'aaa', fields: {subscription: 112}};\n\n    stream.receive(subDocChangeMessage);\n    // Still 111 because buffer has not been flushed.\n    test.equal(coll.findOne('aaa').subscription, 111);\n\n    // Call updates the stub.\n    conn.call('update_value');\n\n    // Observe the stub-written value.\n    test.equal(coll.findOne('aaa').method, 222);\n    // subscription field is updated to the latest value\n    // because of the method call.\n    test.equal(coll.findOne('aaa').subscription, 112);\n\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {msg: 'method', method: 'update_value',\n                               params: [], id:methodMessage.id});\n    test.length(stream.sent, 0);\n\n    // \"Server-side\" change from the method arrives and method returns.\n    // With potentially fixed value for method field, if stub didn't\n    // use 112 as the subscription field value.\n    stream.receive({msg: 'changed', collection: collName,\n                         id: 'aaa', fields: {method: 222}});\n    stream.receive({msg: 'updated', 'methods': [methodMessage.id]});\n    stream.receive({msg: 'result', id:methodMessage.id, result:null});\n\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112);\n\n    // Buffer should already be flushed because of a non-update message.\n    // And after a flush we really want subscription field to be 112.\n    conn._flushBufferedWrites();\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112);\n  });\n}\n\n// XXX also test:\n// - reconnect, with session resume.\n// - restart on update flag\n// - on_update event\n// - reloading when the app changes, including session migration\n"]},"hash":"e8a23b6173cc01a112d16bdf154e656312cbf106"}
